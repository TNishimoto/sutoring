var Sutoring =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/graph-table-svg/dist/common/attribute_names.js":
/*!*********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/attribute_names.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.beginNodeName = \"data-begin-node\";\r\nexports.endNodeName = \"data-end-node\";\r\nexports.isAppropriatelyReverseTextMode = \"data-appropriately-reverse-text\";\r\nexports.controlPointName = \"data-control-point\";\r\nexports.connectPositionChangedEventName = \"connect_position_changed\";\r\nexports.resizeName = \"resized\";\r\nexports.vertexCreatedEventName = \"vertex_created\";\r\nexports.objectCreatedEventName = \"object_created\";\r\nexports.GroupAttribute = \"data-type\";\r\nexports.objectIDName = \"data-objectID\";\r\nexports.customElement = \"data-custom\";\r\nexports.cellEmphasisCellClass = \"___cell-emphasis\";\r\nexports.cellEmphasisBorderClass = \"___border-emphasis\";\r\nexports.cellTemporaryBorderClass = \"___temporary-class\";\r\nexports.defaultCellClass = \"___cell-default\";\r\nexports.defaultCircleRadius = 15;\r\n//export const elementTypeName = \"data-element-type\";\r\n//}\r\n//# sourceMappingURL=attribute_names.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/attribute_names.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/color.js":
/*!***********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/color.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// tslint:disable-next-line: no-namespace\r\n//namespace GraphTableSVG {\r\n/**\r\n * 色に関する名前空間です。\r\n */\r\n//export namespace Color {\r\nconst colorNameArray = new Array(\"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\");\r\nlet colorDic;\r\n// redの16進数の配列\r\nconst rValue = new Array(\"F0\", \"FA\", \"00\", \"7F\", \"F0\", \"F5\", \"FF\", \"00\", \"FF\", \"00\", \"8A\", \"A5\", \"DE\", \"5F\", \"7F\", \"D2\", \"FF\", \"64\", \"FF\", \"DC\", \"00\", \"00\", \"00\", \"B8\", \"A9\", \"00\", \"BD\", \"8B\", \"55\", \"FF\", \"99\", \"8B\", \"E9\", \"8F\", \"48\", \"2F\", \"00\", \"94\", \"FF\", \"00\", \"69\", \"1E\", \"B2\", \"FF\", \"22\", \"FF\", \"DC\", \"F8\", \"FF\", \"DA\", \"80\", \"00\", \"AD\", \"F0\", \"FF\", \"CD\", \"4B\", \"FF\", \"F0\", \"E6\", \"FF\", \"7C\", \"FF\", \"AD\", \"F0\", \"E0\", \"FA\", \"90\", \"D3\", \"FF\", \"FF\", \"20\", \"87\", \"77\", \"B0\", \"FF\", \"00\", \"32\", \"FA\", \"FF\", \"80\", \"66\", \"00\", \"BA\", \"93\", \"3C\", \"7B\", \"00\", \"48\", \"C7\", \"19\", \"F5\", \"FF\", \"FF\", \"FF\", \"00\", \"FD\", \"80\", \"6B\", \"FF\", \"FF\", \"DA\", \"EE\", \"98\", \"AF\", \"DB\", \"FF\", \"FF\", \"CD\", \"FF\", \"DD\", \"B0\", \"80\", \"FF\", \"BC\", \"41\", \"8B\", \"FA\", \"F4\", \"2E\", \"FF\", \"A0\", \"C0\", \"87\", \"6A\", \"70\", \"FF\", \"00\", \"46\", \"D2\", \"00\", \"D8\", \"FF\", \"40\", \"EE\", \"F5\", \"FF\", \"F5\", \"FF\", \"9A\");\r\n// greenの16進数の配列\r\nconst gValue = new Array(\"F8\", \"EB\", \"FF\", \"FF\", \"FF\", \"F5\", \"E4\", \"00\", \"EB\", \"00\", \"2B\", \"2A\", \"B8\", \"9E\", \"FF\", \"69\", \"7F\", \"95\", \"F8\", \"14\", \"FF\", \"00\", \"8B\", \"86\", \"A9\", \"64\", \"B7\", \"00\", \"6B\", \"8C\", \"32\", \"00\", \"96\", \"BC\", \"3D\", \"4F\", \"CE\", \"00\", \"14\", \"BF\", \"69\", \"90\", \"22\", \"FA\", \"8B\", \"00\", \"DC\", \"F8\", \"D7\", \"A5\", \"80\", \"80\", \"FF\", \"FF\", \"69\", \"5C\", \"00\", \"FF\", \"E6\", \"E6\", \"F0\", \"FC\", \"FA\", \"D8\", \"80\", \"FF\", \"FA\", \"EE\", \"D3\", \"B6\", \"A0\", \"B2\", \"CE\", \"88\", \"C4\", \"FF\", \"FF\", \"CD\", \"F0\", \"00\", \"00\", \"CD\", \"00\", \"55\", \"70\", \"B3\", \"68\", \"FA\", \"D1\", \"15\", \"19\", \"FF\", \"E4\", \"E4\", \"DE\", \"00\", \"F5\", \"80\", \"8E\", \"A5\", \"45\", \"70\", \"E8\", \"FB\", \"EE\", \"70\", \"EF\", \"DA\", \"85\", \"C0\", \"A0\", \"E0\", \"00\", \"00\", \"8F\", \"69\", \"45\", \"80\", \"A4\", \"8B\", \"F5\", \"52\", \"C0\", \"CE\", \"5A\", \"80\", \"FA\", \"FF\", \"82\", \"B4\", \"80\", \"BF\", \"63\", \"E0\", \"82\", \"DE\", \"FF\", \"F5\", \"FF\", \"CD\");\r\n// blueの16進数の配列\r\nconst bValue = new Array(\"FF\", \"D7\", \"FF\", \"D4\", \"FF\", \"DC\", \"C4\", \"00\", \"CD\", \"FF\", \"E2\", \"2A\", \"87\", \"A0\", \"00\", \"1E\", \"50\", \"ED\", \"DC\", \"3C\", \"FF\", \"8B\", \"8B\", \"0B\", \"A9\", \"00\", \"6B\", \"8B\", \"2F\", \"00\", \"CC\", \"00\", \"7A\", \"8F\", \"8B\", \"4F\", \"D1\", \"D3\", \"93\", \"FF\", \"69\", \"FF\", \"22\", \"F0\", \"22\", \"FF\", \"DC\", \"FF\", \"00\", \"20\", \"80\", \"00\", \"2F\", \"F0\", \"B4\", \"5C\", \"82\", \"F0\", \"8C\", \"FA\", \"F5\", \"00\", \"CD\", \"E6\", \"80\", \"FF\", \"D2\", \"90\", \"D3\", \"C1\", \"7A\", \"AA\", \"FA\", \"99\", \"DE\", \"E0\", \"00\", \"32\", \"E6\", \"FF\", \"00\", \"AA\", \"CD\", \"D3\", \"DB\", \"71\", \"EE\", \"9A\", \"CC\", \"85\", \"70\", \"FA\", \"E1\", \"B5\", \"AD\", \"80\", \"E6\", \"00\", \"23\", \"00\", \"00\", \"D6\", \"AA\", \"98\", \"EE\", \"93\", \"D5\", \"B9\", \"3F\", \"CB\", \"DD\", \"E6\", \"80\", \"00\", \"8F\", \"E1\", \"13\", \"72\", \"60\", \"57\", \"EE\", \"2D\", \"C0\", \"EB\", \"CD\", \"90\", \"FA\", \"7F\", \"B4\", \"8C\", \"80\", \"D8\", \"47\", \"D0\", \"EE\", \"B3\", \"FF\", \"F5\", \"00\", \"32\");\r\n/**\r\n * 色名から16進コードを生成します。\r\n * @param colorName\r\n */\r\nfunction createHexCodeFromColorName(colorName) {\r\n    if (!colorDic) {\r\n        colorDic = {};\r\n        for (let i = 0; i < colorNameArray.length; i++) {\r\n            colorDic[colorNameArray[i]] = i;\r\n        }\r\n    }\r\n    if (colorName in colorDic) {\r\n        const i = colorDic[colorName];\r\n        return rValue[i] + gValue[i] + bValue[i];\r\n    }\r\n    else {\r\n        return colorName;\r\n    }\r\n}\r\nexports.createHexCodeFromColorName = createHexCodeFromColorName;\r\n/**\r\n * 色名を16進表現に変換します。\r\n * @param colorName\r\n */\r\nfunction createHexFromColorName(colorName) {\r\n    if (!colorDic) {\r\n        colorDic = {};\r\n        for (let i = 0; i < colorNameArray.length; i++) {\r\n            colorDic[colorNameArray[i]] = i;\r\n        }\r\n    }\r\n    if (colorName in colorDic) {\r\n        const i = colorDic[colorName];\r\n        // return r_value[i] + g_value[i] + b_value[i];\r\n        return { r: parseInt(rValue[i], 16), g: parseInt(gValue[i], 16), b: parseInt(bValue[i], 16) };\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.createHexFromColorName = createHexFromColorName;\r\n/**\r\n * 色名をRGBコードに変換します。\r\n * @param colorName\r\n */\r\nfunction createRGBCodeFromColorName(colorName) {\r\n    colorName = createHexCodeFromColorName(colorName);\r\n    if (colorName.substr(0, 3) === \"rgb\") {\r\n        return colorName;\r\n    }\r\n    else {\r\n        if (colorNameArray.length === 6) {\r\n            const r = colorName.substr(0, 2);\r\n            const g = colorName.substr(2, 2);\r\n            const b = colorName.substr(4, 2);\r\n            return `rgb(${parseInt(r, 16)}, ${parseInt(g, 16)}, ${parseInt(b, 16)})`;\r\n        }\r\n        else {\r\n            return `rgb(${80}, ${80}, ${80})`;\r\n        }\r\n    }\r\n}\r\nexports.createRGBCodeFromColorName = createRGBCodeFromColorName;\r\n/**\r\n * 色名をRGB表現に変換します。\r\n * @param str\r\n */\r\nfunction createRGBFromColorName(str) {\r\n    const v = createHexFromColorName(str);\r\n    const def = { r: 80, g: 80, b: 80 };\r\n    if (v != null) {\r\n        return v;\r\n    }\r\n    else {\r\n        if (str.substr(0, 3) === \"rgb\") {\r\n            str = str.replace(\"rgb(\", \"\");\r\n            str = str.replace(\")\", \"\");\r\n            const values = str.split(\",\");\r\n            if (values.length === 3) {\r\n                return { b: parseInt(values[2], undefined), g: parseInt(values[1], undefined),\r\n                    r: parseInt(values[0], undefined) };\r\n            }\r\n            else {\r\n                return def;\r\n            }\r\n        }\r\n        else if (str.length === 6) {\r\n            const r = str.substr(0, 2);\r\n            const g = str.substr(2, 2);\r\n            const b = str.substr(4, 2);\r\n            return { g: parseInt(g, undefined), b: parseInt(b, undefined), r: parseInt(r, undefined) };\r\n        }\r\n        else {\r\n            return def;\r\n        }\r\n    }\r\n}\r\nexports.createRGBFromColorName = createRGBFromColorName;\r\n//}\r\n//}\r\n//# sourceMappingURL=color.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/color.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/common_functions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/common_functions.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//namespace GraphTableSVG {\r\n//import { Rectangle } from \"./vline\";\r\n//import * as CSS from \"../svghtml/css\"\r\n//import {GGraph} from \"../object/g_graph\"\r\n//import {GTable} from \"../object/g_table\"\r\n//import {GObject} from \"../object/g_object\"\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//import {VBAObjectType} from \"../object/table/vba\"\r\n//export namespace CommonFunctions {\r\n/**\r\n * 入力要素がdocument.bodyの孫であるときに限りTrueを返します。\r\n * @param node 判定する要素\r\n */\r\nfunction IsDescendantOfBody(node) {\r\n    const parent = node.parentNode;\r\n    if (parent == null) {\r\n        return false;\r\n    }\r\n    else if (parent == document.body) {\r\n        return true;\r\n    }\r\n    else {\r\n        return IsDescendantOfBody(parent);\r\n    }\r\n}\r\nexports.IsDescendantOfBody = IsDescendantOfBody;\r\n/**\r\n * 指定された文字数になるまで指定された文字を左に加えます\r\n * @param text 文字を追加する文字列\r\n * @param length 計算後のtextの文字数\r\n * @param leftChar 左に追加する文字\r\n */\r\nfunction paddingLeft(text, length, leftChar) {\r\n    while (text.length < length) {\r\n        text = leftChar + text;\r\n    }\r\n    return text;\r\n}\r\nexports.paddingLeft = paddingLeft;\r\n//export function setCellCSS(){\r\n//}\r\n/**\r\n * 単位付きの値を値部分と単位部分に分割します。\r\n * @param text 単位付きの値\r\n */\r\nfunction parseUnit(text) {\r\n    let str1 = \"\", str2 = \"\";\r\n    for (let i = 0; i < text.length; i++) {\r\n        if (isNaN(text[i]) && text[i] != \".\") {\r\n            str2 += text[i];\r\n        }\r\n        else {\r\n            str1 += text[i];\r\n        }\r\n    }\r\n    return [Number(str1), str2];\r\n}\r\nexports.parseUnit = parseUnit;\r\n/**\r\n * 入力値をピクセル単位の値に変換します。\r\n * @param value\r\n */\r\nfunction toPX(value) {\r\n    const [val, unit] = parseUnit(value);\r\n    if (unit == \"px\") {\r\n        return val;\r\n    }\r\n    else if (unit == \"em\") {\r\n        return val * 16;\r\n    }\r\n    else if (unit == \"pt\") {\r\n        return (val / 72) * 96;\r\n    }\r\n    else {\r\n        return val;\r\n    }\r\n}\r\nexports.toPX = toPX;\r\n/**\r\n * 二次ベジエ曲線上の座標を計算します。\r\n * @param param0 [x,y] ベジエ曲線の開始座標\r\n * @param param1 [x,y] ベジエ曲線の制御点\r\n * @param param2 [x,y] ベジエ曲線の終了座標\r\n * @param t 曲線上の位置 0が曲線の開始座標で1が曲線の終了座標、0.5が曲線の中間点を表します\r\n * @returns 指定された座標\r\n */\r\nfunction bezierLocation([px1, py1], [px2, py2], [px3, py3], t) {\r\n    const x = px1 * (1 - t) * (1 - t) + 2 * px2 * t * (1 - t) + px3 * t * t;\r\n    const y = py1 * (1 - t) * (1 - t) + 2 * py2 * t * (1 - t) + py3 * t * t;\r\n    return [x, y];\r\n}\r\nexports.bezierLocation = bezierLocation;\r\n//}\r\n//}\r\n//# sourceMappingURL=common_functions.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/common_functions.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/default_class_names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/default_class_names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.defaultTextClass = \"___text-default\";\r\nexports.defaultCellClass = \"___cell-default\";\r\nexports.defaultSurfaceClass = \"___surface-default\";\r\nexports.defaultPathSurfaceClass = \"___path-surface-default\";\r\nexports.defaultEdgePathClass = \"___default-edge-path\";\r\nexports.defaultTextboxPathClass = \"___default-textbox-path\";\r\nexports.defaultCircleLogicTreeCircleSVGGroup = \"___default-logic-tree-circle-svgGroup\";\r\nexports.defaultCellBackgroungClass = \"___cell-background-default\";\r\nexports.defaultCellBorderClass = \"___cell-border-default\";\r\nexports.defaultRectButtonSurfaceClass = \"___rect-button-surface-default\";\r\nexports.defaultRectButtonClass = \"___rect-button-surface-default\";\r\nexports.defaultEdgeClass = \"__default-edge\";\r\nexports.defaultVertexClass = \"__default-vertex\";\r\nexports.defaultConsoleColumnTitleCellClass = \"___column_title_cell\";\r\nexports.defaultConsoleColumnTitleCellTextClass = \"___column_title_text_cell\";\r\nexports.defaultConsoleColumnTitleCellUndefinedTextClass = \"___column_title_undefined_text_cell\";\r\nexports.defaultConsoleColumnTitleCellBackgroundClass = \"___column_title_background_cell\";\r\n//# sourceMappingURL=default_class_names.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/default_class_names.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/enums.js":
/*!***********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/enums.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar VertexOrder;\r\n(function (VertexOrder) {\r\n    VertexOrder.Preorder = \"preorder\";\r\n    VertexOrder.Postorder = \"postorder\";\r\n})(VertexOrder = exports.VertexOrder || (exports.VertexOrder = {}));\r\nvar ShapeObjectType;\r\n(function (ShapeObjectType) {\r\n    ShapeObjectType.Callout = \"g-callout\";\r\n    ShapeObjectType.ArrowCallout = \"g-arrow-callout\";\r\n    ShapeObjectType.Ellipse = \"g-ellipse\";\r\n    ShapeObjectType.Circle = \"g-circle\";\r\n    ShapeObjectType.Rect = \"g-rect\";\r\n    ShapeObjectType.PathTextBox = \"g-path-textbox\";\r\n    ShapeObjectType.RectButton = \"g-rect-button\";\r\n    ShapeObjectType.Graph = \"g-graph\";\r\n    ShapeObjectType.Table = \"g-table\";\r\n    ShapeObjectType.Object = \"g-object\";\r\n    ShapeObjectType.Edge = \"g-edge\";\r\n    const typeDic = {\r\n        \"g-callout\": true,\r\n        \"g-arrow-callout\": true,\r\n        \"g-ellipse\": true,\r\n        \"g-circle\": true,\r\n        \"g-rect\": true,\r\n        \"g-edge\": true,\r\n        \"g-graph\": true,\r\n        \"g-table\": true,\r\n        \"g-object\": true,\r\n        \"g-path-textbox\": true,\r\n        \"g-rect-button\": true\r\n    };\r\n    const customTypeDic = {\r\n        \"row\": true,\r\n        \"cell\": true,\r\n        \"t\": true\r\n    };\r\n    function toShapeObjectType(value) {\r\n        if (value in typeDic) {\r\n            return value;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    ShapeObjectType.toShapeObjectType = toShapeObjectType;\r\n    function toShapeObjectTypeOrCustomTag(value) {\r\n        const value1 = toShapeObjectType(value);\r\n        if (value1 != null) {\r\n            return value1;\r\n        }\r\n        else {\r\n            if (value in customTypeDic) {\r\n                return value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    ShapeObjectType.toShapeObjectTypeOrCustomTag = toShapeObjectTypeOrCustomTag;\r\n})(ShapeObjectType = exports.ShapeObjectType || (exports.ShapeObjectType = {}));\r\nvar PathTextAlighnment;\r\n(function (PathTextAlighnment) {\r\n    PathTextAlighnment.regularInterval = \"regularInterval\";\r\n    PathTextAlighnment.begin = \"begin\";\r\n    PathTextAlighnment.end = \"end\";\r\n    PathTextAlighnment.center = \"center\";\r\n    const typeDic = {\r\n        \"none\": \"none\",\r\n        \"begin\": \"begin\",\r\n        \"end\": \"end\",\r\n        \"center\": \"center\",\r\n        \"regularInterval\": \"regularInterval\",\r\n    };\r\n    function toPathTextAlighnment(value) {\r\n        if (value in typeDic) {\r\n            return typeDic[value];\r\n        }\r\n        else {\r\n            return \"none\";\r\n        }\r\n    }\r\n    PathTextAlighnment.toPathTextAlighnment = toPathTextAlighnment;\r\n})(PathTextAlighnment = exports.PathTextAlighnment || (exports.PathTextAlighnment = {}));\r\nvar msoDashStyle;\r\n(function (msoDashStyle) {\r\n    //export const styleName : string = \"--mso-dash-style\"\r\n    msoDashStyle.msoLineDash = \"msoLineDash\";\r\n    msoDashStyle.msoLineDashDot = \"msoLineDashDot\";\r\n    msoDashStyle.msoLineDashDotDot = \"msoLineDashDotDot\";\r\n    //export const msoLineDashStyleMixed: msoDashStyle = \"msoLineDashStyleMixed\"\r\n    msoDashStyle.msoLineLongDash = \"msoLineLongDash\";\r\n    msoDashStyle.msoLineLongDashDot = \"msoLineLongDashDot\";\r\n    msoDashStyle.msoLineRoundDot = \"msoLineRoundDot\";\r\n    msoDashStyle.msoLineSolid = \"msoLineSolid\";\r\n    msoDashStyle.msoLineSquareDot = \"msoLineSquareDot\";\r\n    msoDashStyle.dashArrayDic = {\r\n        \"msoLineDash\": [4, 3],\r\n        \"msoLineDashDot\": [4, 3, 1, 3],\r\n        \"msoLineDashDotDot\": [3, 1, 1, 1, 1, 1],\r\n        //\"msoLineDashStyleMixed\" : \"6,3\",\r\n        \"msoLineLongDash\": [9, 3],\r\n        \"msoLineLongDashDot\": [9, 3, 1, 3],\r\n        \"msoLineRoundDot\": [0.25, 2],\r\n        \"msoLineSolid\": [],\r\n        \"msoLineSquareDot\": [1, 1]\r\n    };\r\n    msoDashStyle.lineCapDic = {\r\n        \"msoLineDash\": \"butt\",\r\n        \"msoLineDashDot\": \"butt\",\r\n        \"msoLineDashDotDot\": \"butt\",\r\n        //\"msoLineDashStyleMixed\" : \"butt\",\r\n        \"msoLineLongDash\": \"butt\",\r\n        \"msoLineLongDashDot\": \"butt\",\r\n        \"msoLineRoundDot\": \"round\",\r\n        \"msoLineSolid\": \"butt\",\r\n        \"msoLineSquareDot\": \"butt\"\r\n    };\r\n    const typeDic = {\r\n        \"msoLineDash\": msoDashStyle.msoLineDash,\r\n        \"msoLineDashDot\": msoDashStyle.msoLineDashDot,\r\n        \"msoLineDashDotDot\": msoDashStyle.msoLineDashDotDot,\r\n        //\"msoLineDashStyleMixed\" : msoDashStyle.msoLineDashStyleMixed,\r\n        \"msoLineLongDash\": msoDashStyle.msoLineLongDash,\r\n        \"msoLineLongDashDot\": msoDashStyle.msoLineLongDashDot,\r\n        \"msoLineRoundDot\": msoDashStyle.msoLineRoundDot,\r\n        \"msoLineSquareDot\": msoDashStyle.msoLineSquareDot,\r\n        \"msoLineSolid\": msoDashStyle.msoLineSolid\r\n    };\r\n    function toMSODashStyle(value) {\r\n        if (value in typeDic) {\r\n            return typeDic[value];\r\n        }\r\n        else {\r\n            return msoDashStyle.msoLineSolid;\r\n        }\r\n    }\r\n    msoDashStyle.toMSODashStyle = toMSODashStyle;\r\n    /*\r\n    function setStyle(svgLine: SVGLineElement | SVGPathElement | SVGElement, type: string): void {\r\n        if (toMSODashStyle(type) != null) {\r\n            const width = <number>svgLine.getPropertyStyleNumberValue(\"stroke-width\", 2);\r\n            svgLine.setPropertyStyleValue(\"stroke-dasharray\", computeDashArray(toMSODashStyle(type), width));\r\n            svgLine.setPropertyStyleValue(\"stroke-linecap\", lineCapDic[type]);\r\n            svgLine.setPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName, type);\r\n        } else {\r\n\r\n        }\r\n    }\r\n    */\r\n    /*\r\n    export function getLineType(svgLine: SVGLineElement | SVGPathElement | SVGElement): msoDashStyle {\r\n        const typeName = svgLine.getPropertyStyleValue(StyleNames.msoDashStyleName);\r\n        if (typeName != null) {\r\n            const type = toMSODashStyle(typeName);\r\n            if (type != null) {\r\n                return type;\r\n            }\r\n        }\r\n        const dashArray = svgLine.getPropertyStyleValue(\"stroke-dasharray\");\r\n        if (dashArray != null) {\r\n            return msoDashStyle.msoLineDash;\r\n        } else {\r\n            return msoDashStyle.msoLineSolid;\r\n        }\r\n    }\r\n    */\r\n})(msoDashStyle = exports.msoDashStyle || (exports.msoDashStyle = {}));\r\nvar Direction;\r\n(function (Direction) {\r\n    function toDirection(value) {\r\n        if (value == \"up\") {\r\n            return \"up\";\r\n        }\r\n        else if (value == \"left\") {\r\n            return \"left\";\r\n        }\r\n        else if (value == \"right\") {\r\n            return \"right\";\r\n        }\r\n        else {\r\n            return \"down\";\r\n        }\r\n    }\r\n    Direction.toDirection = toDirection;\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nvar AutoSizeShapeToFitText;\r\n(function (AutoSizeShapeToFitText) {\r\n    AutoSizeShapeToFitText.Auto = \"auto\";\r\n    AutoSizeShapeToFitText.SemiAuto = \"semi-auto\";\r\n    AutoSizeShapeToFitText.None = \"none\";\r\n})(AutoSizeShapeToFitText = exports.AutoSizeShapeToFitText || (exports.AutoSizeShapeToFitText = {}));\r\nvar ConnectorPosition;\r\n(function (ConnectorPosition) {\r\n    ConnectorPosition.Top = \"top\";\r\n    ConnectorPosition.TopLeft = \"topleft\";\r\n    ConnectorPosition.Left = \"left\";\r\n    ConnectorPosition.BottomLeft = \"bottomleft\";\r\n    ConnectorPosition.Bottom = \"bottom\";\r\n    ConnectorPosition.BottomRight = \"bottomright\";\r\n    ConnectorPosition.Right = \"right\";\r\n    ConnectorPosition.TopRight = \"topright\";\r\n    ConnectorPosition.Auto = \"auto\";\r\n    function ToConnectorPosition(str) {\r\n        if (str == null) {\r\n            return ConnectorPosition.Auto;\r\n        }\r\n        else {\r\n            return str;\r\n            /*\r\n            switch (str) {\r\n                case \"top\": return ConnectorPosition.Top;\r\n                case \"topleft\": return ConnectorPosition.TopLeft;\r\n                case \"left\": return ConnectorPosition.Left;\r\n                case \"bottomleft\": return ConnectorPosition.BottomLeft;\r\n                case \"bottom\": return ConnectorPosition.Bottom;\r\n                case \"bottomright\": return ConnectorPosition.BottomRight;\r\n                case \"right\": return ConnectorPosition.Right;\r\n                case \"topright\": return ConnectorPosition.TopRight;\r\n                case \"auto\": return ConnectorPosition.Auto;\r\n                default: return ConnectorPosition.Auto;\r\n            }\r\n            */\r\n        }\r\n    }\r\n    ConnectorPosition.ToConnectorPosition = ToConnectorPosition;\r\n    function ToVBAConnectorPosition(shapeType, str) {\r\n        if (shapeType == \"circle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"topleft\": return 2;\r\n                case \"left\": return 3;\r\n                case \"bottomleft\": return 4;\r\n                case \"bottom\": return 5;\r\n                case \"bottomright\": return 6;\r\n                case \"right\": return 7;\r\n                case \"topright\": return 8;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else if (shapeType == \"rectangle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"left\": return 2;\r\n                case \"bottom\": return 3;\r\n                case \"right\": return 4;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    ConnectorPosition.ToVBAConnectorPosition = ToVBAConnectorPosition;\r\n    function ToVBAConnectorPosition2(shapeType, str) {\r\n        if (shapeType == \"msoShapeOval\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"topleft\": return 2;\r\n                case \"left\": return 3;\r\n                case \"bottomleft\": return 4;\r\n                case \"bottom\": return 5;\r\n                case \"bottomright\": return 6;\r\n                case \"right\": return 7;\r\n                case \"topright\": return 8;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else if (shapeType == \"msoShapeRectangle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"left\": return 2;\r\n                case \"bottom\": return 3;\r\n                case \"right\": return 4;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    ConnectorPosition.ToVBAConnectorPosition2 = ToVBAConnectorPosition2;\r\n})(ConnectorPosition = exports.ConnectorPosition || (exports.ConnectorPosition = {}));\r\nvar VerticalAnchor;\r\n(function (VerticalAnchor) {\r\n    /**\r\n     * 上を表します。\r\n     */\r\n    VerticalAnchor.Top = \"top\";\r\n    /**\r\n     * 真ん中を表します。\r\n     */\r\n    VerticalAnchor.Middle = \"middle\";\r\n    /**\r\n     * 底を表します。\r\n     */\r\n    VerticalAnchor.Bottom = \"bottom\";\r\n    function toVerticalAnchor(value) {\r\n        if (value == \"top\") {\r\n            return \"top\";\r\n        }\r\n        else if (value == \"bottom\") {\r\n            return \"bottom\";\r\n        }\r\n        else {\r\n            return \"middle\";\r\n        }\r\n    }\r\n    VerticalAnchor.toVerticalAnchor = toVerticalAnchor;\r\n})(VerticalAnchor = exports.VerticalAnchor || (exports.VerticalAnchor = {}));\r\nvar HorizontalAnchor;\r\n(function (HorizontalAnchor) {\r\n    /**\r\n     * 左を表します。\r\n     */\r\n    HorizontalAnchor.Left = \"left\";\r\n    /**\r\n     * 中央を表します。\r\n     */\r\n    HorizontalAnchor.Center = \"center\";\r\n    /**\r\n    * 右を表します。\r\n    */\r\n    HorizontalAnchor.Right = \"right\";\r\n    function toHorizontalAnchor(value) {\r\n        if (value == \"left\") {\r\n            return \"left\";\r\n        }\r\n        else if (value == \"right\") {\r\n            return \"right\";\r\n        }\r\n        else {\r\n            return \"center\";\r\n        }\r\n    }\r\n    HorizontalAnchor.toHorizontalAnchor = toHorizontalAnchor;\r\n})(HorizontalAnchor = exports.HorizontalAnchor || (exports.HorizontalAnchor = {}));\r\nfunction parsePXString(item) {\r\n    if (item == null) {\r\n        return 0;\r\n    }\r\n    else {\r\n        if (item.length == 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return parseInt(item);\r\n        }\r\n    }\r\n}\r\nexports.parsePXString = parsePXString;\r\n//}\r\n//# sourceMappingURL=enums.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/enums.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Color = __webpack_require__(/*! ./color */ \"./node_modules/graph-table-svg/dist/common/color.js\");\r\nexports.Color = Color;\r\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nexports.CommonFunctions = CommonFunctions;\r\nconst AttributeNames = __webpack_require__(/*! ./attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nexports.AttributeNames = AttributeNames;\r\nconst DefaultClassNames = __webpack_require__(/*! ./default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nexports.DefaultClassNames = DefaultClassNames;\r\nconst StyleNames = __webpack_require__(/*! ./style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nexports.StyleNames = StyleNames;\r\nconst Enums = __webpack_require__(/*! ./enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nexports.Enums = Enums;\r\nconst VBAFunctions = __webpack_require__(/*! ./vba_functions */ \"./node_modules/graph-table-svg/dist/common/vba_functions.js\");\r\nexports.VBAFunctions = VBAFunctions;\r\nconst VLine = __webpack_require__(/*! ./vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nexports.VLine = VLine;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/style_names.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/style_names.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.autoSizeShapeToFitText = \"--autosize-shape-to-fit-text\";\r\nexports.beginConnectorType = \"--begin-connector-type\";\r\nexports.endConnectorType = \"--end-connector-type\";\r\n//export const defaultLineClass: string = \"--default-line-class\";\r\nexports.markerStart = \"--marker-start\";\r\nexports.markerEnd = \"--marker-end\";\r\n//export const defaultVertexClass: string = \"--default-vertex-class\";\r\n//export const defaultEdgeClass: string = \"--default-edge-class\";\r\nexports.vertexXInterval = \"--vertex-x-interval\";\r\nexports.vertexYInterval = \"--vertex-y-interval\";\r\nexports.graphDirection = \"--direction\";\r\nexports.defaultRadius = \"--default-radius\";\r\nexports.defaultWidth = \"--default-width\";\r\nexports.defaultHeight = \"--default-height\";\r\n//export const defaultTextClass: string = \"--default-text-class\";\r\n//export const defaultPathClass: string = \"--default-path-class\";\r\n//export const defaulSurfaceClass: string = \"--default-surface-class\";\r\nexports.defaultSurfaceType = \"--default-surface-type\";\r\n//export const defaultCellClass: string = \"--default-cell-class\";\r\n//export const defaultBorderClass: string = \"--default-border-class\";\r\nexports.paddingTop = \"--padding-top\";\r\nexports.paddingLeft = \"--padding-left\";\r\nexports.paddingRight = \"--padding-right\";\r\nexports.paddingBottom = \"--padding-bottom\";\r\nexports.marginTop = \"--margin-top\";\r\nexports.marginLeft = \"--margin-left\";\r\nexports.marginRight = \"--margin-right\";\r\nexports.marginBottom = \"--margin-bottom\";\r\nexports.VerticalAnchor = \"--vertical-anchor\";\r\nexports.HorizontalAnchor = \"--horizontal-anchor\";\r\nexports.PathTextAlignment = \"--path-text-alignment\";\r\nexports.msoDashStyleName = \"--stroke-style\";\r\nexports.relocateName = \"--relocate\";\r\nexports.prohibitionOutOfRange = \"--prohibition-out-of-range\";\r\n//# sourceMappingURL=style_names.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/style_names.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/vba_functions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/vba_functions.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst Color = __webpack_require__(/*! ./color */ \"./node_modules/graph-table-svg/dist/common/color.js\");\r\nconst CommonFunctions = __webpack_require__(/*! ./common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nfunction parseInteger(value) {\r\n    if (value == \"\") {\r\n        return 1;\r\n    }\r\n    else {\r\n        return parseInt(value);\r\n    }\r\n}\r\nexports.parseInteger = parseInteger;\r\nfunction visible(value) {\r\n    if (value == \"hidden\") {\r\n        return 1.0;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.visible = visible;\r\nclass VBATranslateFunctions {\r\n    static grouping80(codes) {\r\n        let r = [];\r\n        const result = [];\r\n        codes.forEach(function (x, i, arr) {\r\n            if (r.length + x.length >= 80) {\r\n                result.push(VBATranslateFunctions.joinLines(r));\r\n                r = [];\r\n            }\r\n            x.forEach((v) => r.push(v));\r\n        });\r\n        if (r.length > 0) {\r\n            result.push(VBATranslateFunctions.joinLines(r));\r\n            r = [];\r\n        }\r\n        return result;\r\n    }\r\n    static splitCode(codes, subArg, callArg, id) {\r\n        const functions = [];\r\n        const p = VBATranslateFunctions.grouping80(codes);\r\n        p.forEach(function (x, i, arr) {\r\n            functions.push(`Call SubFunction${id}_${i}(${callArg})`);\r\n            const begin = `Sub SubFunction${id}_${i}(${subArg})`;\r\n            const end = `End Sub`;\r\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\r\n        });\r\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\r\n    }\r\n    static ToFontBold(bold) {\r\n        if (bold == \"bold\") {\r\n            return \"msotrue\";\r\n        }\r\n        else {\r\n            return \"msofalse\";\r\n        }\r\n    }\r\n    static ToVerticalAnchor(value) {\r\n        switch (value) {\r\n            case \"top\": return \"msoAnchorTop\";\r\n            case \"middle\": return \"msoAnchorMiddle\";\r\n            case \"bottom\": return \"msoAnchorBottom\";\r\n            default: return \"msoAnchorTop\";\r\n        }\r\n    }\r\n    static ToHorizontalAnchor(value) {\r\n        switch (value) {\r\n            case \"left\": return \"ppAlignLeft\";\r\n            case \"center\": return \"ppAlignCenter\";\r\n            case \"right\": return \"ppAlignRight\";\r\n            default: return \"ppAlignLeft\";\r\n        }\r\n    }\r\n    static createStringFunction(item) {\r\n        return item.length == 0 ? `\"\"` : `\"` + item + `\"`;\r\n    }\r\n    static createArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += items[i];\r\n            if (i + 1 != items.length) {\r\n                s += `, `;\r\n            }\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static createStringArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += `\"${items[i]}\"`;\r\n            if (i + 1 != items.length) {\r\n                s += `, `;\r\n            }\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static createJagArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += VBATranslateFunctions.createArrayFunction(items[i]);\r\n            if (i + 1 != items.length)\r\n                s += `, `;\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static joinLines(lines) {\r\n        let s = ``;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            s += lines[i];\r\n            if (i + 1 != lines.length)\r\n                s += `\\n`;\r\n        }\r\n        return s;\r\n    }\r\n    static colorToVBA(color) {\r\n        color = Color.createRGBCodeFromColorName(color);\r\n        if (color.indexOf(\"rgb\") != -1) {\r\n            return color.replace(\"rgb\", \"Array\");\r\n        }\r\n        else {\r\n            return \"Array(0, 0, 0)\";\r\n        }\r\n    }\r\n    static ToVBAFont(font) {\r\n        font = font.replace(/\"/g, \"\");\r\n        font = font.replace(/'/g, \"\");\r\n        return font;\r\n    }\r\n    static TranslateSVGTextElement(sub, item, range) {\r\n        const text = item.textContent == null ? \"\" : item.textContent;\r\n        sub.push([`${range}.text = \"${item.textContent}\"`]);\r\n        if (item.children.length > 0) {\r\n            let pos = 1;\r\n            for (let i = 0; i < item.children.length; i++) {\r\n                const child = item.children.item(i);\r\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\r\n                    const css = getComputedStyle(child);\r\n                    const childColor = Color.createRGBFromColorName(css.fill == null ? \"black\" : css.fill);\r\n                    const fontName = this.getFont(css);\r\n                    const fontSize = CommonFunctions.toPX(css.fontSize == null ? \"14pt\" : css.fontSize);\r\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n                    const len = child.textContent.length;\r\n                    let f = child.getAttribute(\"data-script\");\r\n                    if (f == null) {\r\n                        f = \"\";\r\n                    }\r\n                    sub.push([`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\r\n                    pos += len;\r\n                }\r\n            }\r\n        }\r\n        else if (item.textContent != null && item.textContent.length > 0) {\r\n            const css = getComputedStyle(item);\r\n            if (css.fontSize == null)\r\n                throw Error(\"error\");\r\n            if (css.fill == null)\r\n                throw Error(\"error\");\r\n            const color = Color.createRGBFromColorName(css.fill);\r\n            const fontName = this.getFont(css);\r\n            const fontSize = CommonFunctions.toPX(css.fontSize);\r\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n            sub.push([`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\r\n        }\r\n    }\r\n    static getFont(css) {\r\n        if (css.fontFamily == null)\r\n            throw Error(\"error\");\r\n        const arr = css.fontFamily.split(\",\");\r\n        if (arr.length > 0) {\r\n            let name = arr[0];\r\n            name = name.replace(/\\\"/g, \"\");\r\n            name = name.replace(/\\'/g, \"\");\r\n            return name;\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    static TranslateSVGTextElement2(item, range) {\r\n        const lines = [];\r\n        const text = item.textContent == null ? \"\" : item.textContent;\r\n        lines.push(`${range}.text = \"${item.textContent}\"`);\r\n        if (item.children.length > 0) {\r\n            let pos = 1;\r\n            for (let i = 0; i < item.children.length; i++) {\r\n                const child = item.children.item(i);\r\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\r\n                    const css = getComputedStyle(child);\r\n                    if (css.fontSize == null)\r\n                        throw Error(\"error\");\r\n                    if (css.fill == null)\r\n                        throw Error(\"error\");\r\n                    const childColor = Color.createRGBFromColorName(css.fill);\r\n                    const fontName = this.getFont(css);\r\n                    const fontSize = CommonFunctions.toPX(css.fontSize);\r\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n                    const len = child.textContent.length;\r\n                    let f = child.getAttribute(\"data-script\");\r\n                    if (f == null) {\r\n                        f = \"\";\r\n                    }\r\n                    lines.push(`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\r\n                    pos += len;\r\n                }\r\n            }\r\n        }\r\n        else if (item.textContent != null && item.textContent.length > 0) {\r\n            const css = getComputedStyle(item);\r\n            if (css.fontSize == null)\r\n                throw Error(\"error\");\r\n            if (css.fill == null)\r\n                throw Error(\"error\");\r\n            const color = Color.createRGBFromColorName(css.fill);\r\n            const fontName = this.getFont(css);\r\n            const fontSize = CommonFunctions.toPX(css.fontSize);\r\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n            lines.push(`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\r\n        }\r\n        return lines;\r\n    }\r\n}\r\nexports.VBATranslateFunctions = VBATranslateFunctions;\r\n//# sourceMappingURL=vba_functions.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/vba_functions.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/common/vline.js":
/*!***********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/common/vline.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\n/**\r\n * 傾きや切片を計算できる線です。\r\n */\r\nclass VLine {\r\n    constructor(x1, y1, x2, y2) {\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n    }\r\n    get smallPoint() {\r\n        if (this.x1 < this.x2) {\r\n            return [this.x1, this.y1];\r\n        }\r\n        else {\r\n            return [this.x2, this.y2];\r\n        }\r\n    }\r\n    get largePoint() {\r\n        if (this.x1 < this.x2) {\r\n            return [this.x2, this.y2];\r\n        }\r\n        else {\r\n            return [this.x1, this.y1];\r\n        }\r\n    }\r\n    contains(x, y) {\r\n        const lineY = this.getY(x);\r\n        if (lineY == null) {\r\n            return x < this.x1;\r\n        }\r\n        else {\r\n            return y < lineY;\r\n        }\r\n    }\r\n    getY(x) {\r\n        const intercept = this.intercept;\r\n        if (intercept == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.slope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (this.slope * x) + intercept;\r\n            }\r\n        }\r\n    }\r\n    get slope() {\r\n        const [x1, y1] = this.smallPoint;\r\n        const [x2, y2] = this.largePoint;\r\n        if (x2 - x1 == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return (y2 - y1) / (x2 - x1);\r\n        }\r\n    }\r\n    get intercept() {\r\n        const [x1, y1] = this.smallPoint;\r\n        const [x2, y2] = this.largePoint;\r\n        if (this.slope == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return y1 - x1 * this.slope;\r\n        }\r\n    }\r\n    get inverseSlope() {\r\n        if (this.slope == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.slope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return -1 / this.slope;\r\n            }\r\n        }\r\n    }\r\n    inverseIntercept(x, y) {\r\n        if (this.slope == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.inverseSlope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return y - (this.inverseSlope * x);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.VLine = VLine;\r\nclass Padding {\r\n    constructor(top = 0, left = 0, right = 0, bottom = 0) {\r\n        this.top = top;\r\n        this.left = left;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n    }\r\n}\r\nexports.Padding = Padding;\r\nclass Size {\r\n    constructor(width = 0, height = 0) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n}\r\nexports.Size = Size;\r\n/**\r\n * 四角形を表します。\r\n */\r\nclass Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    /**\r\n    右端のX座標を返します。\r\n    */\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    /**\r\n    底のY座標を返します。\r\n    */\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n    /**\r\n     * X座標とY座標に値を加えます。\r\n     * @param x\r\n     * @param y\r\n     */\r\n    addOffset(x, y) {\r\n        this.x += x;\r\n        this.y += y;\r\n    }\r\n    /**\r\n     * 引数の四角形を内包する最小の四角形を返します。\r\n     * @param rects\r\n     */\r\n    static merge(rects) {\r\n        if (rects.length > 0) {\r\n            let x1 = rects[0].x;\r\n            let y1 = rects[0].y;\r\n            let x2 = rects[0].right;\r\n            let y2 = rects[0].bottom;\r\n            rects.forEach((v) => {\r\n                if (x1 > v.x)\r\n                    x1 = v.x;\r\n                if (y1 > v.y)\r\n                    y1 = v.y;\r\n                if (x2 < v.right)\r\n                    x2 = v.right;\r\n                if (y2 < v.bottom)\r\n                    y2 = v.bottom;\r\n            });\r\n            const rect = new Rectangle();\r\n            rect.x = x1;\r\n            rect.y = y1;\r\n            rect.width = x2 - x1;\r\n            rect.height = y2 - y1;\r\n            return rect;\r\n        }\r\n        else {\r\n            return new Rectangle(0, 0, 0, 0);\r\n        }\r\n    }\r\n}\r\nexports.Rectangle = Rectangle;\r\n//}\r\n//# sourceMappingURL=vline.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/common/vline.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/css.js":
/*!*******************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/css.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\n//export namespace CSS {\r\n/*\r\ninterface IPoint2D {\r\n    x: number;\r\n    y: number;\r\n  }\r\n  */\r\nfunction buildClassNameFromSurfaceClassCSS(rule) {\r\n    const _rule = toRuleMap(rule);\r\n    return getOrCreateClassName(_rule);\r\n}\r\nexports.buildClassNameFromSurfaceClassCSS = buildClassNameFromSurfaceClassCSS;\r\nconst CSSName = \"___GraphTableCSS\";\r\nlet createdGraphTableCSS = false;\r\nconst replaceMapper = new Map();\r\nfunction setupReplaceMapper() {\r\n    replaceMapper.set(\"fontSize\", \"font-size\");\r\n    replaceMapper.set(\"fontFamily\", \"font-family\");\r\n    replaceMapper.set(\"autoSizeShapeToFitText\", StyleNames.autoSizeShapeToFitText);\r\n    replaceMapper.set(\"verticalAnchor\", StyleNames.VerticalAnchor);\r\n    replaceMapper.set(\"horizontalAnchor\", StyleNames.HorizontalAnchor);\r\n    replaceMapper.set(\"beginConnectorType\", StyleNames.beginConnectorType);\r\n    replaceMapper.set(\"endConnectorType\", StyleNames.endConnectorType);\r\n    replaceMapper.set(\"pathTextAlignment\", StyleNames.PathTextAlignment);\r\n    replaceMapper.set(\"strokeWidth\", \"stroke-width\");\r\n}\r\nfunction setGraphTableCSS() {\r\n    if (createdGraphTableCSS)\r\n        return;\r\n    const item = document.head.getElementsByClassName(CSSName);\r\n    if (item.length > 0) {\r\n        document.head.removeChild(item[0]);\r\n    }\r\n    var blankStyle = document.createElement('style');\r\n    blankStyle.innerHTML = createCSS();\r\n    blankStyle.type = \"text/css\";\r\n    blankStyle.setAttribute(\"class\", CSSName);\r\n    blankStyle.title = CSSName;\r\n    const head = document.getElementsByTagName('head');\r\n    const fstItem = head.item(0).firstChild;\r\n    if (fstItem == null) {\r\n        head.item(0).appendChild(blankStyle);\r\n    }\r\n    else {\r\n        head.item(0).insertBefore(blankStyle, fstItem);\r\n    }\r\n    createdGraphTableCSS = true;\r\n}\r\nexports.setGraphTableCSS = setGraphTableCSS;\r\nfunction getGraphTableCSS() {\r\n    const item = document.getElementById(CSSName);\r\n    if (item instanceof HTMLStyleElement) {\r\n        return item;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.getGraphTableCSS = getGraphTableCSS;\r\nfunction getGraphTableStyleSheet() {\r\n    if (!createdGraphTableCSS)\r\n        setGraphTableCSS();\r\n    for (let i = 0; i < document.styleSheets.length; i++) {\r\n        const css = document.styleSheets.item(i);\r\n        if (css.title == CSSName && css instanceof CSSStyleSheet) {\r\n            return css;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.getGraphTableStyleSheet = getGraphTableStyleSheet;\r\nfunction getRuleContentString(rule) {\r\n    const arr = new Array();\r\n    rule.forEach((value, key) => {\r\n        arr.push(key);\r\n    });\r\n    arr.sort();\r\n    const content = arr.map((key) => {\r\n        return `${key}: ${rule.get(key)};`;\r\n    }).join(\"\\n\");\r\n    return content;\r\n}\r\nexports.getRuleContentString = getRuleContentString;\r\nfunction toRuleMap(rule) {\r\n    if (replaceMapper.size == 0)\r\n        setupReplaceMapper();\r\n    const _rule = new Map();\r\n    Object.keys(rule).forEach((v) => {\r\n        if (replaceMapper.has(v)) {\r\n            _rule.set(replaceMapper.get(v), rule[v]);\r\n        }\r\n        else {\r\n            _rule.set(v, rule[v]);\r\n        }\r\n        /*\r\n        if(v == \"fontSize\"){\r\n            _rule.set(\"font-size\", value);\r\n        }else if(v == \"fontFamily\"){\r\n            _rule.set(\"font-family\", value);\r\n        }else{\r\n            _rule.set(v, (<any>rule)[v]);\r\n        }\r\n        */\r\n    });\r\n    return _rule;\r\n}\r\nexports.toRuleMap = toRuleMap;\r\nconst ruleInverseMap = new Map();\r\nlet createdCSSRuleCount = 0;\r\nconst generatedCSSRuleName = \"--g-class-\";\r\nfunction getOrCreateClassName(rule) {\r\n    if (rule instanceof Map) {\r\n        const ruleContentString = getRuleContentString(rule);\r\n        if (ruleInverseMap.has(ruleContentString)) {\r\n            return ruleInverseMap.get(ruleContentString);\r\n        }\r\n        else {\r\n            const css = getGraphTableStyleSheet();\r\n            const className = `${generatedCSSRuleName}${createdCSSRuleCount++}`;\r\n            const cssRule = `.${className}{${ruleContentString}}`;\r\n            css.insertRule(cssRule, css.cssRules.length);\r\n            ruleInverseMap.set(ruleContentString, className);\r\n            return className;\r\n        }\r\n    }\r\n    else {\r\n        const _rule = toRuleMap(rule);\r\n        return getOrCreateClassName(_rule);\r\n    }\r\n}\r\nexports.getOrCreateClassName = getOrCreateClassName;\r\nfunction createCSS() {\r\n    const r = `\r\n            .${AttributeNames.cellEmphasisCellClass}{\r\n            fill : yellow !important;\r\n            }\r\n            .${AttributeNames.cellEmphasisBorderClass}{\r\n            stroke : red !important;\r\n            }\r\n            .${DefaultClassNames.defaultCellClass}{\r\n                ${StyleNames.paddingTop} : 5px;\r\n                ${StyleNames.paddingLeft} : 5px;\r\n                ${StyleNames.paddingRight} : 5px;\r\n                ${StyleNames.paddingBottom} : 5px;\r\n                ${StyleNames.VerticalAnchor} : ${enums_1.VerticalAnchor.Middle};\r\n                ${StyleNames.HorizontalAnchor} : ${enums_1.HorizontalAnchor.Center};\r\n            }\r\n            .${DefaultClassNames.defaultTextClass}{\r\n                fill : black;\r\n                font-size: 18px;\r\n                font-family: \"monospace\";\r\n            }\r\n            .${DefaultClassNames.defaultCellBackgroungClass}{\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultCellBorderClass}{\r\n                stroke : black;\r\n            }\r\n            .${DefaultClassNames.defaultVertexClass}{\r\n\r\n            }\r\n            .${DefaultClassNames.defaultEdgeClass}{\r\n                ${StyleNames.PathTextAlignment}: center;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : white;\r\n            }\r\n            .${DefaultClassNames.defaultPathSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : transparent;\r\n            }\r\n            .${DefaultClassNames.defaultCircleLogicTreeCircleSVGGroup}{\r\n                ${StyleNames.autoSizeShapeToFitText}: false;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultEdgePathClass}{\r\n                stroke: black;\r\n                fill: none;\r\n                stroke-width: 1px;\r\n            }\r\n            .${DefaultClassNames.defaultTextboxPathClass}{\r\n                stroke: black;\r\n                fill: white;\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultRectButtonSurfaceClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n            .${DefaultClassNames.defaultRectButtonSurfaceClass}[disabled]{\r\n                fill: #aaaaaa; \r\n            }\r\n            .${DefaultClassNames.defaultRectButtonSurfaceClass}:not([disabled]):hover{\r\n                fill:#A4C6FF; \r\n            }\r\n            .${DefaultClassNames.defaultRectButtonSurfaceClass}:not([disabled]):active{\r\n                fill:#8EB8FF; \r\n            }\r\n\r\n            .___column_title_cellaa{\r\n                --default-text-class : table-text;\r\n                --default-background-class : background;    \r\n                --horizontal-anchor: center;\r\n                --vertical-anchor: middle;\r\n                --padding-top: 0px;\r\n                --padding-left: 0px;\r\n                --padding-right: 0px;\r\n                --padding-bottom: 0px;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellTextClass} {\r\n                fill : black;\r\n                font-size: 18px;\r\n                font-weight: bold;\r\n            }\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass} {\r\n                fill : pink;\r\n                font-size: 18px;\r\n                font-style: italic;\r\n            }\r\n\r\n            .${DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n\r\n\r\n            g[data-type=\"g-rect-button\"] > rect {\r\n                stroke-width: 1px;\r\n                transition-duration: 0.2s;\r\n            }\r\n\r\n            g[data-type=\"g-rect-button\"] > rect[disabled]{\r\n                stroke-width: 1px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > rect:not([disabled]):hover {\r\n                stroke-width: 3px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > rect:not([disabled]):active {\r\n                stroke-width: 1px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > text {\r\n                pointer-events: none;\r\n            }\r\n    \r\n            `;\r\n    return r;\r\n}\r\nexports.createCSS = createCSS;\r\nfunction createCSSString(obj) {\r\n    if (typeof obj == \"string\") {\r\n        return obj;\r\n    }\r\n    else if (typeof obj == \"object\") {\r\n        const styleContent = getRuleContentString(toRuleMap(obj));\r\n        return styleContent;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.createCSSString = createCSSString;\r\nfunction createCSSClass(obj) {\r\n    if (typeof obj == \"string\") {\r\n        return obj;\r\n    }\r\n    else if (typeof obj == \"object\") {\r\n        const styleClass = getOrCreateClassName(obj);\r\n        return styleClass;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.createCSSClass = createCSSClass;\r\nfunction setCSSClass(e, style) {\r\n    if (style !== undefined) {\r\n        //SVG.resetStyle(e.style);\r\n        if (style == null) {\r\n            e.removeAttribute(\"class\");\r\n        }\r\n        else {\r\n            const styleClass = createCSSClass(style);\r\n            if (styleClass !== undefined) {\r\n                e.setAttribute(\"class\", styleClass);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.setCSSClass = setCSSClass;\r\nfunction setCSSStyle(e, style) {\r\n    if (style !== undefined) {\r\n        //SVG.resetStyle(e.style);\r\n        const styleClass = createCSSString(style);\r\n        if (styleClass !== undefined) {\r\n            e.setAttribute(\"style\", styleClass);\r\n        }\r\n    }\r\n}\r\nexports.setCSSStyle = setCSSStyle;\r\n//}\r\n//# sourceMappingURL=css.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/css.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/draggable_object.js":
/*!********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/draggable_object.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\nvar DraggableObjectFunctions;\r\n(function (DraggableObjectFunctions) {\r\n    let drag = null;\r\n    function draggable(element, g) {\r\n        element.addEventListener('mousedown', function (e) {\r\n            e.preventDefault();\r\n            //const rect = getContainerRect(g);\r\n            const parent = SVG.getLeastContainer(g);\r\n            if (parent != null) {\r\n                const rect = SVG.getAbsolutePosition(g);\r\n                drag = {\r\n                    offsetX: e.clientX - rect.x,\r\n                    offsetY: e.clientY - rect.y,\r\n                    target: element,\r\n                    g: g,\r\n                    gParentG: parent\r\n                };\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n    DraggableObjectFunctions.draggable = draggable;\r\n    /*\r\n    function getContainerRect(e: SVGElement) {\r\n        const container = SVG.getLeastContainer(e)!;\r\n        const containerRect = container.getBoundingClientRect();\r\n        return containerRect;\r\n    }\r\n    */\r\n    function appendDragFunctionsToDocument() {\r\n        document.onmouseup = function () {\r\n            drag = null;\r\n        };\r\n        document.onmousemove = function (e) {\r\n            if (drag != null) {\r\n                if (drag.target != null && drag.target instanceof SVGElement) {\r\n                    const g = drag.g;\r\n                    const containerRect = SVG.getAbsolutePosition(drag.gParentG);\r\n                    const refx = (e.clientX - containerRect.x) - drag.offsetX;\r\n                    const refy = (e.clientY - containerRect.y) - drag.offsetY;\r\n                    SVGGExtension.setX(g, refx);\r\n                    SVGGExtension.setY(g, refy);\r\n                    //drag.target.x.baseVal.value = e.clientX - drag.offsetx;\r\n                    //drag.target.y.baseVal.value = e.clientY - drag.offsety;\r\n                }\r\n            }\r\n        };\r\n    }\r\n    DraggableObjectFunctions.appendDragFunctionsToDocument = appendDragFunctionsToDocument;\r\n})(DraggableObjectFunctions = exports.DraggableObjectFunctions || (exports.DraggableObjectFunctions = {}));\r\n//# sourceMappingURL=draggable_object.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/draggable_object.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/enum_extension.js":
/*!******************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/enum_extension.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nfunction getLineType(svgLine) {\r\n    const typeName = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\r\n    if (typeName != null) {\r\n        const type = enums_1.msoDashStyle.toMSODashStyle(typeName);\r\n        if (type != null) {\r\n            return type;\r\n        }\r\n    }\r\n    const dashArray = ElementExtension.getPropertyStyleValue(svgLine, \"stroke-dasharray\");\r\n    if (dashArray != null) {\r\n        return enums_1.msoDashStyle.msoLineDash;\r\n    }\r\n    else {\r\n        return enums_1.msoDashStyle.msoLineSolid;\r\n    }\r\n}\r\nexports.getLineType = getLineType;\r\nfunction computeDashArray(type, width) {\r\n    const r = [];\r\n    for (let i = 0; i < enums_1.msoDashStyle.dashArrayDic[type].length; i++) {\r\n        r.push(enums_1.msoDashStyle.dashArrayDic[type][i] * width);\r\n    }\r\n    return r.join(\",\");\r\n}\r\nfunction setCpmoutedDashArray(svgLine) {\r\n    const type = ElementExtension.getPropertyStyleValue(svgLine, StyleNames.msoDashStyleName);\r\n    if (type == null) {\r\n    }\r\n    else if (enums_1.msoDashStyle.toMSODashStyle(type) != null) {\r\n        const width = ElementExtension.getPropertyStyleNumberValue(svgLine, \"stroke-width\", 2);\r\n        ElementExtension.setPropertyStyleValue(svgLine, \"stroke-dasharray\", computeDashArray(enums_1.msoDashStyle.toMSODashStyle(type), width));\r\n        ElementExtension.setPropertyStyleValue(svgLine, \"stroke-linecap\", enums_1.msoDashStyle.lineCapDic[type]);\r\n    }\r\n}\r\nexports.setCpmoutedDashArray = setCpmoutedDashArray;\r\n//# sourceMappingURL=enum_extension.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/enum_extension.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/gui.js":
/*!*******************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/gui.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nfunction setSVGBoxSize(box, item1, item2) {\r\n    if (item1 instanceof vline_1.Rectangle) {\r\n        if (item2 instanceof vline_1.Padding) {\r\n            const w = item1.right + item2.left + item2.right;\r\n            const h = item1.bottom + item2.top + item2.bottom;\r\n            setSVGBoxSize(box, w, h);\r\n        }\r\n        else {\r\n            throw new Error();\r\n        }\r\n    }\r\n    else {\r\n        if (item2 instanceof vline_1.Padding) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            const width = `${item1}px`;\r\n            const height = `${item2}px`;\r\n            if (box.style.width != width || box.style.height != height) {\r\n                box.style.width = width;\r\n                box.style.height = height;\r\n                box.setAttribute(\"width\", width);\r\n                box.setAttribute(\"height\", height);\r\n                box.setAttribute(`viewBox`, `0 0 ${item1} ${item2}`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.setSVGBoxSize = setSVGBoxSize;\r\n/**\r\n * URLのパラメータを表す連想配列を生成します。\r\n */\r\nfunction getURLParameters() {\r\n    const arg = {};\r\n    const pair = location.search.substring(1).split('&');\r\n    for (let i = 0; pair[i]; i++) {\r\n        const kv = pair[i].split('=');\r\n        arg[kv[0]] = kv[1];\r\n    }\r\n    return arg;\r\n}\r\nexports.getURLParameters = getURLParameters;\r\n/**\r\n * URLのパラメータをパースしてHTML内の適切な要素に代入します。\r\n */\r\nfunction setURLParametersToHTMLElements() {\r\n    const parameters = getURLParameters();\r\n    Object.keys(parameters).forEach((key) => {\r\n        const val = parameters[key]; // this は obj\r\n        const element = document.getElementById(key);\r\n        if (element != null) {\r\n            if (element instanceof HTMLTextAreaElement) {\r\n                element.value = val;\r\n            }\r\n        }\r\n    }, parameters);\r\n}\r\nexports.setURLParametersToHTMLElements = setURLParametersToHTMLElements;\r\n/**\r\n * HTMLTextAreaElementのテキストを取得します。\r\n * @param elementID HTMLTextAreaElementのID\r\n */\r\nfunction getInputText(elementID) {\r\n    const textbox = document.getElementById(elementID);\r\n    return textbox.value;\r\n}\r\nexports.getInputText = getInputText;\r\n/**\r\n * HTMLTextAreaElementを取得します。\r\n * @param id HTMLTextAreaElementのID\r\n */\r\nfunction getNonNullElementById(id) {\r\n    const tmp = document.getElementById(id);\r\n    if (tmp == null) {\r\n        throw Error(\"Null Error\");\r\n    }\r\n    else {\r\n        return tmp;\r\n    }\r\n}\r\nexports.getNonNullElementById = getNonNullElementById;\r\nfunction getClientRectangle() {\r\n    const x = window.pageXOffset;\r\n    const y = window.pageYOffset;\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    return new vline_1.Rectangle(x, y, width, height);\r\n}\r\nexports.getClientRectangle = getClientRectangle;\r\n//}\r\n//}\r\n//# sourceMappingURL=gui.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/gui.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/gui_observer.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/gui_observer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst GUI = __webpack_require__(/*! ./gui */ \"./node_modules/graph-table-svg/dist/html/gui.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\n/**\r\n *\r\n * @param svgBox\r\n * @param sizeFunc\r\n * @param padding\r\n */\r\nfunction observeSVGBox(svgBox, sizeFunc, padding = new vline_1.Padding(5, 5, 5, 5)) {\r\n    let _observer;\r\n    let observeFunction = (x) => {\r\n        let b = false;\r\n        for (let i = 0; i < x.length; i++) {\r\n            const item = x[i];\r\n            //console.log(item.target);\r\n            if (svgBox != item.target) {\r\n                b = true;\r\n            }\r\n        }\r\n        if (b)\r\n            GUI.setSVGBoxSize(svgBox, sizeFunc(), padding);\r\n    };\r\n    _observer = new MutationObserver(observeFunction);\r\n    const option = {\r\n        subtree: true, attributes: true\r\n    };\r\n    _observer.observe(svgBox, option);\r\n}\r\nexports.observeSVGBox = observeSVGBox;\r\nlet dic = [];\r\nlet createdObserveSVGSVGTimer = false;\r\nfunction resizeSVGSVG(svgBox, padding) {\r\n    //GraphTableSVG.GUI.setSVGBoxSize(svgBox, new Rectangle(0,0,1000,1000), padding);\r\n    const rect = SVG.getRegion2(svgBox);\r\n    if (rect.width == 0)\r\n        rect.width = 1;\r\n    if (rect.height == 0)\r\n        rect.height = 1;\r\n    GUI.setSVGBoxSize(svgBox, rect, padding);\r\n}\r\nfunction observeSVGSVG(svgBox, padding = new vline_1.Padding(0, 0, 0, 0)) {\r\n    if (isObserved(svgBox)) {\r\n        return;\r\n    }\r\n    let _observer;\r\n    let observeFunction = (x) => {\r\n        const gShrink = ElementExtension.gtGetAttributeBooleanWithUndefined(svgBox, \"g-shrink\");\r\n        let b = false;\r\n        for (let i = 0; i < x.length; i++) {\r\n            const item = x[i];\r\n            if (svgBox != item.target) {\r\n                b = true;\r\n            }\r\n        }\r\n        if (gShrink === true && b) {\r\n            resizeSVGSVG(svgBox, padding);\r\n        }\r\n    };\r\n    _observer = new MutationObserver(observeFunction);\r\n    const option = {\r\n        subtree: true, attributes: true\r\n    };\r\n    _observer.observe(svgBox, option);\r\n    dic.push({ svgsvg: svgBox, visible: false, padding: padding });\r\n    if (!createdObserveSVGSVGTimer) {\r\n        createdObserveSVGSVGTimer = true;\r\n        setTimeout(observeSVGSVGTimer, timerInterval);\r\n    }\r\n}\r\nexports.observeSVGSVG = observeSVGSVG;\r\nfunction isObserved(svgBox) {\r\n    for (let i = 0; i < dic.length; i++) {\r\n        if (dic[i].svgsvg === svgBox) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.isObserved = isObserved;\r\nfunction observeSVGSVGTimer() {\r\n    dic.forEach((v, i) => {\r\n        const nowVisible = !SVG.isSVGSVGHidden(v.svgsvg);\r\n        //const nowVisible = (!SVG.isSVGSVGHidden(v.svgsvg) ) && isInsideElement(v.svgsvg);\r\n        if (v.visible) {\r\n            if (!nowVisible) {\r\n                v.visible = false;\r\n            }\r\n        }\r\n        else {\r\n            if (nowVisible) {\r\n                //const startTime = performance.now();\r\n                dispatchResizeEvent(v.svgsvg);\r\n                //const endTime = performance.now();\r\n                //const time = endTime - startTime;\r\n                //console.log(\"dispatch \" + v.svgsvg.id + \" : \" + time + \"ms\");\r\n                const b = ElementExtension.gtGetAttributeBooleanWithUndefined(v.svgsvg, \"g-shrink\");\r\n                if (b !== undefined && b === true)\r\n                    resizeSVGSVG(v.svgsvg, v.padding);\r\n                v.visible = true;\r\n            }\r\n        }\r\n    });\r\n    setTimeout(observeSVGSVGTimer, timerInterval);\r\n}\r\nfunction dispatchResizeEvent(e) {\r\n    const children = HTMLFunctions.getChildren(e);\r\n    children.forEach((v) => {\r\n        dispatchResizeEvent(v);\r\n    });\r\n    if (e instanceof SVGGElement) {\r\n        var event = document.createEvent(\"HTMLEvents\");\r\n        event.initEvent(AttributeNames.resizeName, false, true);\r\n        e.dispatchEvent(event);\r\n    }\r\n}\r\nlet changeElementDic = [];\r\nlet timerInterval = 100;\r\nfunction observeChangeElement() {\r\n    var result = document.evaluate(\"//iframe[@g-src]\", document, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);\r\n    for (var i = 0; i < result.snapshotLength; i++) {\r\n        var node = result.snapshotItem(i);\r\n        changeElementDic.push(node);\r\n    }\r\n    if (changeElementDic.length > 0)\r\n        setTimeout(observeChangeElementTimer, timerInterval);\r\n}\r\nexports.observeChangeElement = observeChangeElement;\r\nfunction observeChangeElementTimer() {\r\n    for (let i = 0; i < changeElementDic.length; i++) {\r\n        const element = changeElementDic[i];\r\n        if (HTMLFunctions.isInsideElement(element)) {\r\n            const url = element.getAttribute(\"g-src\");\r\n            element.setAttribute(\"src\", url);\r\n            element.removeAttribute(\"g-src\");\r\n            changeElementDic.splice(i, 1);\r\n            i = -1;\r\n        }\r\n    }\r\n    if (changeElementDic.length > 0)\r\n        setTimeout(observeChangeElementTimer, timerInterval);\r\n}\r\n//}\r\n//}\r\n//# sourceMappingURL=gui_observer.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/gui_observer.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/html_functions.js":
/*!******************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/html_functions.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst GUI = __webpack_require__(/*! ./gui */ \"./node_modules/graph-table-svg/dist/html/gui.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\n//export namespace HTMLFunctions {\r\nvar NodeOrder;\r\n(function (NodeOrder) {\r\n    NodeOrder[NodeOrder[\"Preorder\"] = 0] = \"Preorder\";\r\n    NodeOrder[NodeOrder[\"Postorder\"] = 1] = \"Postorder\";\r\n})(NodeOrder = exports.NodeOrder || (exports.NodeOrder = {}));\r\nfunction getTNodes(e) {\r\n    const tNodes = getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"t\");\r\n    if (tNodes.length > 0) {\r\n        tNodes.forEach((v, i) => {\r\n            v.removeAttribute(AttributeNames.customElement);\r\n            if (i > 0 && !v.hasAttribute(\"newline\"))\r\n                v.setAttribute(\"newline\", \"true\");\r\n        });\r\n        return tNodes;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.getTNodes = getTNodes;\r\nfunction getAncestorAttribute(e, attr) {\r\n    if (e.hasAttribute(attr)) {\r\n        return e.getAttribute(attr);\r\n    }\r\n    else {\r\n        if (e.parentElement == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return getAncestorAttribute(e.parentElement, attr);\r\n        }\r\n    }\r\n}\r\nexports.getAncestorAttribute = getAncestorAttribute;\r\n/*\r\nfunction isShow2(e: HTMLElement | SVGElement, isParentWindow : boolean = false): boolean {\r\n    \r\n    const p = isParentWindow ? window.parent.getComputedStyle(e) : window.getComputedStyle(e);\r\n    const disp = p.display;\r\n    const vis = p.visibility;\r\n    if (disp == \"none\" || vis == \"hidden\") {\r\n        return false;\r\n    } else {\r\n        const parent = e.parentElement;\r\n        if (parent == null) {\r\n            if(isParentWindow){\r\n                return true;\r\n            }else{\r\n                if(window == window.parent){\r\n                    return true;\r\n                }else{\r\n                    return isShow2(<HTMLElement>window.frameElement, true);\r\n                }\r\n            }\r\n        } else {\r\n            return isShow2(parent, isParentWindow);\r\n        }\r\n    }\r\n\r\n}\r\n*/\r\nfunction isShow(e) {\r\n    const p = e.getBoundingClientRect();\r\n    return !(p.top == 0 && p.left == 0 && p.width == 0 && p.height == 0);\r\n    //return isShow2(e);\r\n}\r\nexports.isShow = isShow;\r\nfunction getDescendantsByPreorder(e) {\r\n    const r = [];\r\n    r.push(e);\r\n    for (let i = 0; i < e.children.length; i++) {\r\n        const p = e.children.item(i);\r\n        if (p instanceof Element) {\r\n            getDescendantsByPreorder(p).forEach((v) => r.push(v));\r\n        }\r\n    }\r\n    return r;\r\n}\r\nexports.getDescendantsByPreorder = getDescendantsByPreorder;\r\nfunction getDescendantsByPostorder(e) {\r\n    const r = [];\r\n    for (let i = 0; i < e.children.length; i++) {\r\n        const p = e.children.item(i);\r\n        if (p instanceof Element) {\r\n            getDescendantsByPostorder(p).forEach((v) => r.push(v));\r\n        }\r\n    }\r\n    r.push(e);\r\n    return r;\r\n}\r\nexports.getDescendantsByPostorder = getDescendantsByPostorder;\r\nfunction getDescendants(e, order = NodeOrder.Preorder) {\r\n    if (order == NodeOrder.Preorder) {\r\n        return getDescendantsByPreorder(e);\r\n    }\r\n    else {\r\n        return getDescendantsByPostorder(e);\r\n    }\r\n}\r\nexports.getDescendants = getDescendants;\r\nfunction getChildren(e) {\r\n    const r = [];\r\n    for (let i = 0; i < e.children.length; i++) {\r\n        const p = e.children.item(i);\r\n        if (p instanceof Element) {\r\n            r.push(p);\r\n        }\r\n    }\r\n    return r;\r\n}\r\nexports.getChildren = getChildren;\r\nfunction getChildByNodeName(e, name) {\r\n    const p = getChildren(e).filter((v) => v.nodeName == name);\r\n    if (p.length > 0) {\r\n        return p[0];\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.getChildByNodeName = getChildByNodeName;\r\nfunction isInsideElement(element) {\r\n    const win = GUI.getClientRectangle();\r\n    const ele = element.getBoundingClientRect();\r\n    const b1 = ele.left <= win.width && ele.top <= win.height;\r\n    const b2 = ele.right <= win.width && ele.top <= win.height;\r\n    const b3 = ele.left <= win.width && ele.bottom <= win.height;\r\n    const b4 = ele.right <= win.width && ele.bottom <= win.height;\r\n    return b1 || b2 || b3 || b4;\r\n}\r\nexports.isInsideElement = isInsideElement;\r\n//}\r\n//# sourceMappingURL=html_functions.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/html_functions.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/html/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/html/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst GUIObserver = __webpack_require__(/*! ./gui_observer */ \"./node_modules/graph-table-svg/dist/html/gui_observer.js\");\r\nexports.GUIObserver = GUIObserver;\r\n//import * as SVG from \"../interface/svg\"\r\nconst CSS = __webpack_require__(/*! ./css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nexports.CSS = CSS;\r\nconst HTMLFunctions = __webpack_require__(/*! ./html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nexports.HTMLFunctions = HTMLFunctions;\r\nconst DraggableObject = __webpack_require__(/*! ./draggable_object */ \"./node_modules/graph-table-svg/dist/html/draggable_object.js\");\r\nexports.DraggableObject = DraggableObject;\r\nconst GUI = __webpack_require__(/*! ./gui */ \"./node_modules/graph-table-svg/dist/html/gui.js\");\r\nexports.GUI = GUI;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/html/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst HTML = __webpack_require__(/*! ./html/index */ \"./node_modules/graph-table-svg/dist/html/index.js\");\r\nexports.HTML = HTML;\r\nconst Common = __webpack_require__(/*! ./common/index */ \"./node_modules/graph-table-svg/dist/common/index.js\");\r\nexports.Common = Common;\r\nconst Objects = __webpack_require__(/*! ./objects/index */ \"./node_modules/graph-table-svg/dist/objects/index.js\");\r\nexports.Objects = Objects;\r\nconst Options = __webpack_require__(/*! ./options/index */ \"./node_modules/graph-table-svg/dist/options/index.js\");\r\nexports.Options = Options;\r\nconst Logics = __webpack_require__(/*! ./logics/index */ \"./node_modules/graph-table-svg/dist/logics/index.js\");\r\nexports.Logics = Logics;\r\nconst Console = __webpack_require__(/*! ./options/console */ \"./node_modules/graph-table-svg/dist/options/console.js\");\r\nexports.Console = Console;\r\nconst Debug = __webpack_require__(/*! ./options/debug */ \"./node_modules/graph-table-svg/dist/options/debug.js\");\r\nexports.Debug = Debug;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/element_extension.js":
/*!***************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/element_extension.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nfunction getPropertyStyleValue(item, name) {\r\n    const p = item.style.getPropertyValue(name).trim();\r\n    if (p.length == 0) {\r\n        const r = item.getAttribute(\"class\");\r\n        if (r == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            const css = getComputedStyle(item);\r\n            //let css = GraphTableSVG.SVG.getStyleSheet(r);\r\n            //if (css == null) css = getComputedStyle(item);\r\n            const p2 = css.getPropertyValue(name).trim();\r\n            if (p2.length == 0) {\r\n                return null;\r\n            }\r\n            else {\r\n                return p2;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return p;\r\n    }\r\n}\r\nexports.getPropertyStyleValue = getPropertyStyleValue;\r\nfunction gtGetStyleBooleanWithUndefined(item, name) {\r\n    const value = getPropertyStyleValue(item, name);\r\n    if (value != null) {\r\n        return value == \"true\";\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.gtGetStyleBooleanWithUndefined = gtGetStyleBooleanWithUndefined;\r\nfunction getPropertyStyleValueWithDefault(item, name, defaultValue) {\r\n    const p = getPropertyStyleValue(item, name);\r\n    if (p == null) {\r\n        return defaultValue;\r\n    }\r\n    else {\r\n        return p;\r\n    }\r\n}\r\nexports.getPropertyStyleValueWithDefault = getPropertyStyleValueWithDefault;\r\nfunction getPropertyStyleNumberValue(item, name, defaultValue) {\r\n    const p = getPropertyStyleValue(item, name);\r\n    if (p != null) {\r\n        return CommonFunctions.toPX(p);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\r\nexports.getPropertyStyleNumberValue = getPropertyStyleNumberValue;\r\nfunction getActiveStyle(item) {\r\n    //const p: Element = this;\r\n    const r = item.getAttribute(\"class\");\r\n    if (r == null) {\r\n        return item.style;\r\n    }\r\n    else {\r\n        return getComputedStyle(item);\r\n    }\r\n}\r\nexports.getActiveStyle = getActiveStyle;\r\nfunction setPropertyStyleValue(item, name, value) {\r\n    item.style.setProperty(name, value);\r\n}\r\nexports.setPropertyStyleValue = setPropertyStyleValue;\r\nfunction gtGetAttributeNumber(item, name, defaultValue) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\r\nexports.gtGetAttributeNumber = gtGetAttributeNumber;\r\nfunction gtGetAttributeNumberWithoutNull(item, name, defaultValue) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\r\nexports.gtGetAttributeNumberWithoutNull = gtGetAttributeNumberWithoutNull;\r\nfunction gtGetAttributeNumberWithUndefined(item, name) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.gtGetAttributeNumberWithUndefined = gtGetAttributeNumberWithUndefined;\r\nfunction gtGetAttributeStringWithUndefined(item, name) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.gtGetAttributeStringWithUndefined = gtGetAttributeStringWithUndefined;\r\nfunction gtGetAttributeBooleanWithUndefined(item, name) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value == \"true\";\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexports.gtGetAttributeBooleanWithUndefined = gtGetAttributeBooleanWithUndefined;\r\nfunction gtGetAttribute(item, name, defaultValue) {\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\r\nexports.gtGetAttribute = gtGetAttribute;\r\nfunction gtGetAttributes(item) {\r\n    //const p: Element = this;\r\n    const r = [];\r\n    for (let i = 0; i < item.attributes.length; i++) {\r\n        const subitem = item.attributes.item(i);\r\n        if (subitem != null) {\r\n            r.push({ name: subitem.name, value: subitem.value });\r\n        }\r\n    }\r\n    return r;\r\n}\r\nexports.gtGetAttributes = gtGetAttributes;\r\nfunction getIsLoaded(item) {\r\n    const item2 = item;\r\n    if (item2.__isLoaded === undefined) {\r\n        return undefined;\r\n    }\r\n    else {\r\n        return item2.__isLoaded;\r\n    }\r\n}\r\nexports.getIsLoaded = getIsLoaded;\r\nfunction setIsLoaded(item, b) {\r\n    const item2 = item;\r\n    item2.__isLoaded = b;\r\n}\r\nexports.setIsLoaded = setIsLoaded;\r\nfunction hasStyleAttribute(item, name) {\r\n    const p = getPropertyStyleValue(item, name);\r\n    return p !== null;\r\n}\r\nexports.hasStyleAttribute = hasStyleAttribute;\r\n//# sourceMappingURL=element_extension.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/element_extension.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/extensions.js":
/*!********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/extensions.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nfunction tryGetPropertyValue(item, name) {\r\n    //const p: CSSStyleDeclaration = this;\r\n    const r = item.getPropertyValue(name).trim();\r\n    if (r.length == 0) {\r\n        return null;\r\n    }\r\n    else {\r\n        return r;\r\n    }\r\n}\r\nexports.tryGetPropertyValue = tryGetPropertyValue;\r\n/**\r\n * SVGTextElementのテキストを設定します。\r\n * @param text 設定するテキスト\r\n * @param isLatexMode TrueのときLatex表記を使用します。\r\n */\r\nfunction setTextContent(item, text, isLatexMode = false) {\r\n    SVGTextBox.setTextToTextPath(item, text, isLatexMode);\r\n}\r\nexports.setTextContent = setTextContent;\r\n/**\r\n * SVGLineElementを強調するかどうかを設定します。\r\n * @param b Trueなら強調。Falseなら強調しません。\r\n */\r\nfunction setEmphasis(item, value) {\r\n    CSS.setGraphTableCSS();\r\n    if (getEmphasis(item) && !value) {\r\n        const tmp = item.getAttribute(AttributeNames.cellTemporaryBorderClass);\r\n        if (tmp != null) {\r\n            item.setAttribute(\"class\", tmp);\r\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\r\n        }\r\n        else {\r\n            item.removeAttribute(\"class\");\r\n            item.removeAttribute(AttributeNames.cellTemporaryBorderClass);\r\n        }\r\n    }\r\n    else if (!getEmphasis(item) && value) {\r\n        const lineClass = item.getAttribute(\"class\");\r\n        item.setAttribute(\"class\", AttributeNames.cellTemporaryBorderClass);\r\n        if (lineClass != null) {\r\n            item.setAttribute(AttributeNames.cellTemporaryBorderClass, lineClass);\r\n        }\r\n    }\r\n}\r\nexports.setEmphasis = setEmphasis;\r\nfunction getEmphasis(item) {\r\n    const emp = item.getAttribute(\"class\");\r\n    if (emp != null) {\r\n        return emp == AttributeNames.cellEmphasisBorderClass;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nexports.getEmphasis = getEmphasis;\r\n/**\r\n * SVGPathElementの位置を設定します。\r\n * @param points\r\n */\r\nfunction setPathLocations(item, points) {\r\n    let s = \"\";\r\n    for (let i = 0; i < points.length; i++) {\r\n        s += `${i == 0 ? \"M\" : \"L\"} ${points[i][0]} ${points[i][1]} `;\r\n    }\r\n    //points.forEach((x, y) => s += `M ${x} ${y} `);\r\n    item.setAttribute(\"d\", s);\r\n}\r\nexports.setPathLocations = setPathLocations;\r\n/**\r\n * SVGPathElementの位置を取得します。\r\n */\r\nfunction getPathLocations(item) {\r\n    const info = item.getAttribute(\"d\");\r\n    if (info == null)\r\n        return [];\r\n    const r = [];\r\n    let pos = [0, 0];\r\n    let pathType = \"\";\r\n    info.split(\" \").forEach((v, i) => {\r\n        if (i % 3 == 0) {\r\n            pathType = v;\r\n        }\r\n        else if (i % 3 == 1) {\r\n            pos[0] = parseInt(v);\r\n        }\r\n        else {\r\n            pos[1] = parseInt(v);\r\n            r.push(pos);\r\n            pos = [0, 0];\r\n        }\r\n    });\r\n    return r;\r\n}\r\nexports.getPathLocations = getPathLocations;\r\n//# sourceMappingURL=extensions.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/extensions.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/svg.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\n//import * as CSS from \"./css\";\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ./svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\n//export namespace SVG {\r\nlet idCounter = 0;\r\nfunction getNewID() {\r\n    return idCounter++;\r\n}\r\nexports.getNewID = getNewID;\r\n/**\r\n * SVGLineElementを生成します。\r\n * @param x 開始位置のX座標\r\n * @param y 開始位置のY座標\r\n * @param x2 終了位置のX座標\r\n * @param y2 終了位置のY座標\r\n * @param className SVGLineElementのクラス属性名\r\n * @returns 生成されたSVGLineElement\r\n */\r\nfunction createLine(x, y, x2, y2, className) {\r\n    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');\r\n    line1.x1.baseVal.value = x;\r\n    line1.x2.baseVal.value = x2;\r\n    line1.y1.baseVal.value = y;\r\n    line1.y2.baseVal.value = y2;\r\n    //line1.style.color = \"black\";\r\n    line1.setAttribute(\"class\", className);\r\n    /*\r\n    if (className != null) {\r\n    } else {\r\n        line1.style.stroke = \"black\";\r\n    }\r\n    */\r\n    //line1.style.visibility = \"hidden\";\r\n    //line1.style.strokeWidth = `${5}`\r\n    //line1.setAttribute('stroke', 'black');\r\n    return line1;\r\n}\r\nexports.createLine = createLine;\r\n/**\r\n * SVGTextElementを生成します。\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGTextElement\r\n */\r\nfunction createText(className) {\r\n    const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n    _svgText.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\r\n    //_svgText.style.textAnchor = \"middle\";\r\n    _svgText.setAttribute(\"class\", className);\r\n    /*\r\n    if (className == null) {\r\n        \r\n    } else {\r\n    }\r\n    */\r\n    return _svgText;\r\n}\r\nexports.createText = createText;\r\n/**\r\n * SVGRectElementを生成します。\r\n * @param parent 生成したSVG要素を子に追加する要素\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGRectElement\r\n */\r\nfunction createRectangle(parent, className = null) {\r\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n    parent.appendChild(rect);\r\n    rect.width.baseVal.value = 30;\r\n    rect.height.baseVal.value = 30;\r\n    if (className == null) {\r\n        rect.style.fill = \"white\";\r\n        rect.style.stroke = \"black\";\r\n        rect.style.strokeWidth = \"1pt\";\r\n    }\r\n    else {\r\n        rect.setAttribute(\"class\", className);\r\n        //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\r\n        //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\r\n        const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\r\n        if (width != null) {\r\n            rect.width.baseVal.value = width;\r\n        }\r\n        const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\r\n        if (height != null) {\r\n            rect.height.baseVal.value = height;\r\n        }\r\n    }\r\n    return rect;\r\n}\r\nexports.createRectangle = createRectangle;\r\n/**\r\n * SVGRectElementを生成します。\r\n * @param parent 生成したSVG要素を子に追加する要素\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGRectElement\r\n */\r\nfunction createCellRectangle(parent, className = null) {\r\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n    parent.appendChild(rect);\r\n    if (className != null) {\r\n        rect.setAttribute(\"class\", className);\r\n    }\r\n    return rect;\r\n}\r\nexports.createCellRectangle = createCellRectangle;\r\n/**\r\n * SVGGElementを生成します。\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGGElement\r\n */\r\nfunction createGroup(parent) {\r\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n    g.setAttribute(AttributeNames.objectIDName, (idCounter++).toString());\r\n    /*\r\n    if (className != null) {\r\n        g.setAttribute(\"class\", className);\r\n    }\r\n    */\r\n    if (parent != null)\r\n        parent.appendChild(g);\r\n    return g;\r\n}\r\nexports.createGroup = createGroup;\r\n/**\r\n * Styleの設定を消去します。\r\n * @param style 消去するStyle\r\n */\r\nfunction resetStyle(style) {\r\n    style.stroke = null;\r\n    style.strokeWidth = null;\r\n    style.fill = null;\r\n    style.fontSize = null;\r\n    style.fontWeight = null;\r\n    style.fontFamily = null;\r\n    /*\r\n    style.removeProperty(AttributeNames.Style.paddingTop);\r\n    style.removeProperty(AttributeNames.Style.paddingLeft);\r\n    style.removeProperty(AttributeNames.Style.paddingRight);\r\n    style.removeProperty(AttributeNames.Style.paddingBottom);\r\n    */\r\n}\r\nexports.resetStyle = resetStyle;\r\n/**\r\n * SVGCircleElementを生成します。\r\n * @param parent 生成したSVG要素を子に追加する要素\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGCircleElement\r\n */\r\nfunction createCircle(parent, className = null) {\r\n    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n    parent.appendChild(circle);\r\n    circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\r\n    if (className == null) {\r\n        circle.style.stroke = \"black\";\r\n        circle.style.strokeWidth = \"1pt\";\r\n        circle.style.fill = \"white\";\r\n    }\r\n    else {\r\n        circle.setAttribute(\"class\", className);\r\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\r\n        if (radius != null) {\r\n            circle.r.baseVal.value = radius;\r\n        }\r\n        //const dashStyle = circle.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\r\n        //if (dashStyle != null) msoDashStyle.setStyle(circle, dashStyle);\r\n    }\r\n    //circle.style.fill = \"#ffffff\";\r\n    circle.cx.baseVal.value = 0;\r\n    circle.cy.baseVal.value = 0;\r\n    //circle.r.baseVal.value = r;\r\n    return circle;\r\n}\r\nexports.createCircle = createCircle;\r\n/**\r\n * Edgeの矢じりとして使うSVGMarkerElementを作成します。\r\n * @param className 生成するSVG要素のクラス属性名\r\n * @returns 生成されたSVGMarkerElement\r\n */\r\nfunction createMarker(option = {}) {\r\n    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\r\n    //const poly = <SVGPolygonElement>document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\r\n    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n    poly.setAttribute(\"d\", \"M 0 0 L 10 5 L 0 10 z\");\r\n    //poly.setAttribute(\"points\", \"0,0 0,10 10,5\");\r\n    if (option.color != undefined) {\r\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", option.color);\r\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", option.color);\r\n    }\r\n    else {\r\n        ElementExtension.setPropertyStyleValue(poly, \"stroke\", \"black\");\r\n        ElementExtension.setPropertyStyleValue(marker, \"fill\", \"black\");\r\n    }\r\n    ElementExtension.setPropertyStyleValue(poly, \"stroke-width\", \"1px\");\r\n    //poly.setAttribute(\"data-skip\", \"1\");\r\n    marker.setAttribute(\"markerUnits\", \"userSpaceOnUse\");\r\n    marker.setAttribute(\"markerHeight\", \"15\");\r\n    marker.setAttribute(\"markerWidth\", \"15\");\r\n    marker.setAttribute(\"refX\", \"10\");\r\n    marker.setAttribute(\"refY\", \"5\");\r\n    //marker.setAttribute(\"data-skip\", \"1\");\r\n    //marker.refX.baseVal.value = 10;\r\n    //marker.refY.baseVal.value = 5;\r\n    marker.setAttribute(\"preserveAspectRatio\", \"none\");\r\n    marker.setAttribute(\"orient\", \"auto\");\r\n    marker.setAttribute(\"viewBox\", \"0 0 10 10\");\r\n    //marker.setAttribute(\"stroke-width\", \"1px\");\r\n    marker.appendChild(poly);\r\n    if (option.className != null) {\r\n        //marker.setAttribute(\"class\", option.className);\r\n        //poly.setAttribute(\"class\", className);\r\n    }\r\n    else {\r\n    }\r\n    return [marker, poly];\r\n}\r\nexports.createMarker = createMarker;\r\n/**\r\n * SVGTextElementを子に持つSVGTextPathElementを作成します。\r\n * @param className 生成するSVGTextPathElementのクラス属性名\r\n * @returns 生成されたSVGTextElementとSVGTextPathElement\r\n */\r\nfunction createTextPath(className = null) {\r\n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n    ;\r\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\r\n    text.appendChild(path);\r\n    if (className == null) {\r\n        path.style.fill = \"black\";\r\n        path.style.fontSize = \"14px\";\r\n        path.style.fontWeight = \"bold\";\r\n        path.style.fontFamily = 'Times New Roman';\r\n    }\r\n    else {\r\n        path.setAttribute(\"class\", className);\r\n    }\r\n    return [text, path];\r\n}\r\nexports.createTextPath = createTextPath;\r\n/**\r\n* SVGTextElementを子に持つSVGTextPathElementを作成します。\r\n* @param className 生成するSVGTextPathElementのクラス属性名\r\n* @returns 生成されたSVGTextElementとSVGTextPathElement\r\n*/\r\nfunction createTextPath2(className) {\r\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\r\n    if (className !== undefined) {\r\n        path.setAttribute(\"class\", className);\r\n    }\r\n    /*\r\n    if(typeof(className) == \"string\"){\r\n    }else{\r\n        const newClassName = CSS.getOrAddRule(className);\r\n        path.setAttribute(\"class\", newClassName);\r\n    }\r\n    */\r\n    /*\r\n    if (className == null) {\r\n        path.style.fill = \"black\";\r\n        path.style.fontSize = \"14px\";\r\n        path.style.fontWeight = \"bold\";\r\n        path.style.fontFamily = 'Times New Roman';\r\n    } else {\r\n    }\r\n    */\r\n    return path;\r\n}\r\nexports.createTextPath2 = createTextPath2;\r\n/*\r\nexport function setDefaultValue(item: SVGCircleElement | SVGRectElement, style: CSSStyleDeclaration | null = null) {\r\n    const className = item.getAttribute(\"class\");\r\n    if (style != null) {\r\n        if (item instanceof SVGCircleElement) {\r\n            const s = style.getPropertyValue(defaultRadiusName).trim();\r\n            if (s.length > 0) {\r\n                item.r.baseVal.value = Number(s);\r\n            }\r\n        } else {\r\n            const s1 = style.getPropertyValue(defaultWidthName).trim();\r\n            if (s1.length > 0) {\r\n                item.width.baseVal.value = Number(s1);\r\n            }\r\n\r\n            const s2 = style.getPropertyValue(defaultHeightName).trim();\r\n            if (s2.length > 0) {\r\n                item.height.baseVal.value = Number(s2);\r\n            }\r\n        }\r\n    } else {\r\n        \r\n        if (className != null) {\r\n            const cssStyle = getStyleSheet(className);\r\n\r\n            if (cssStyle != null) {\r\n                setDefaultValue(item, cssStyle)\r\n            } else {\r\n                const computedStyle = getComputedStyle(item);\r\n                setDefaultValue(item, computedStyle);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    \r\n}\r\n*/\r\n/**\r\n * SVG要素にクラス属性をセットします。\r\n * @param svg 適用されるSVG要素\r\n * @param className クラス属性名\r\n */\r\nfunction setClass(svg, className = null) {\r\n    if (className == null) {\r\n        svg.removeAttribute(\"class\");\r\n    }\r\n    else {\r\n        resetStyle(svg.style);\r\n        svg.setAttribute(\"class\", className);\r\n    }\r\n}\r\nexports.setClass = setClass;\r\n/**\r\n * 未使用。\r\n * @param name\r\n */\r\nfunction getStyleSheet(name) {\r\n    const name2 = \".\" + name;\r\n    for (let i = 0; i < document.styleSheets.length; i++) {\r\n        const sheet = document.styleSheets.item(i);\r\n        const rules = sheet.cssRules || sheet.rules;\r\n        if (rules != null) {\r\n            for (let j = 0; j < rules.length; j++) {\r\n                const rule = rules.item(j);\r\n                if (rule.selectorText == name2) {\r\n                    return rule.style;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.getStyleSheet = getStyleSheet;\r\n/*\r\nexport function setStyleForPNG(svg: SVGElement) {\r\n    const style = getComputedStyle(svg);\r\n    svg.style.fill = style.fill;\r\n    svg.style.stroke = style.stroke;\r\n    svg.style.strokeWidth = style.stroke;\r\n}\r\n*/\r\n/*\r\nexport function getRegion(e: SVGElement): Rectangle {\r\n    if (e instanceof SVGSVGElement) {\r\n        const elements = <SVGElement[]>HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\r\n        const rectangles = elements.map((v) => getRegion(v));\r\n\r\n        const eRegion = getRelativeBoundingClientRect(e);\r\n        const region = Rectangle.merge(rectangles);\r\n\r\n        return region;\r\n\r\n    }\r\n    else if (e instanceof SVGGElement) {\r\n        const elements = <SVGElement[]>HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\r\n        const rectangles = elements.map((v) => getRegion(v));\r\n\r\n        //const eRegion = getRelativeBoundingClientRect(e);\r\n        const px = e.getX();\r\n        const py = e.getY();\r\n\r\n        const region = Rectangle.merge(rectangles);\r\n\r\n        //const region2 = new Rectangle(region.x + eRegion.x, region.y + eRegion.y, region.width, region.height);\r\n        const region2 = new Rectangle(region.x + px, region.y + py, region.width, region.height);\r\n                        \r\n        return region2;\r\n    } else {\r\n        const rect = getRelativeBoundingClientRect2(e);\r\n        const region = rect\r\n        return region;\r\n    }\r\n}\r\n*/\r\nfunction getRegion2(e) {\r\n    if (e instanceof SVGSVGElement) {\r\n        const elements = HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\r\n        const rectangles = elements.map((v) => getRegion2(v));\r\n        const parentRect = e.getBoundingClientRect();\r\n        const rect = vline_1.Rectangle.merge(rectangles);\r\n        let r = new vline_1.Rectangle();\r\n        r.x = 0;\r\n        r.y = 0;\r\n        r.width = rect.width + (rect.x - parentRect.left);\r\n        r.height = rect.height + (rect.y - parentRect.top);\r\n        return r;\r\n    }\r\n    else if (e instanceof SVGGElement) {\r\n        /*\r\n        const elements = <SVGElement[]>HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\r\n        const rectangles = elements.map((v) => getRegion2(v));\r\n        const region = Rectangle.merge(rectangles);\r\n                        \r\n        return region;\r\n        */\r\n        const rect = e.getBoundingClientRect();\r\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\r\n        return r;\r\n    }\r\n    else {\r\n        const rect = e.getBoundingClientRect();\r\n        let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\r\n        return r;\r\n    }\r\n}\r\nexports.getRegion2 = getRegion2;\r\nlet ura = null;\r\n/*\r\nfunction getRelativeBoundingClientRect(e: SVGElement): Rectangle {\r\n    let r = new Rectangle();\r\n    const svgsvgHidden = isSVGSVGHidden(e);\r\n    const svgHidden = isSVGHidden(e);\r\n    if(svgHidden){\r\n        return r;\r\n    }else if(svgsvgHidden){\r\n        if (ura == null) {\r\n            ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        }\r\n        document.body.appendChild(ura);\r\n        ura.innerHTML = e.outerHTML;\r\n        const fst = ura.firstChild;\r\n        if (fst instanceof SVGElement) {\r\n            \r\n            const rect = fst.getBoundingClientRect();\r\n            const parentRect = ura.getBoundingClientRect();\r\n            r.x = rect.left - parentRect.left;\r\n            r.y = rect.top - parentRect.top;\r\n            r.width = rect.width;\r\n            r.height = rect.height;\r\n\r\n \r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n\r\n            return r;\r\n        } else if (fst != null) {\r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n            return r;\r\n        } else {\r\n            ura.remove();\r\n            return r;\r\n        }\r\n    }else{\r\n        const rect = e.getBoundingClientRect();\r\n        const parentRect = e.parentElement!.getBoundingClientRect();\r\n        r.x = rect.left - parentRect.left;\r\n        r.y = rect.top - parentRect.top;\r\n        r.width = rect.width;\r\n        r.height = rect.height;\r\n\r\n        return r;\r\n    }\r\n\r\n}\r\n \r\nfunction getHiddenRelativeBoundingClientRect(e: SVGElement): Rectangle {\r\n    let r = new Rectangle();\r\n    if (ura == null) {\r\n        ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n    }\r\n    document.body.appendChild(ura);\r\n    ura.innerHTML = e.outerHTML;\r\n    const fst = ura.firstChild;\r\n    if (fst instanceof SVGElement) {\r\n        \r\n        const rect = fst.getBoundingClientRect();\r\n        const parentRect = ura.getBoundingClientRect();\r\n        r.x = rect.left - parentRect.left;\r\n        r.y = rect.top - parentRect.top;\r\n        r.width = rect.width;\r\n        r.height = rect.height;\r\n\r\n\r\n        ura.removeChild(fst);\r\n        ura.remove();\r\n\r\n        return r;\r\n    } else if (fst != null) {\r\n        ura.removeChild(fst);\r\n        ura.remove();\r\n        return r;\r\n    } else {\r\n        ura.remove();\r\n        return r;\r\n    }\r\n}\r\n \r\nfunction getRelativeBoundingClientRect2(e: SVGElement): Rectangle {\r\n    let r = new Rectangle();\r\n    const svgsvgHidden = isSVGSVGHidden(e);\r\n    const svgHidden = isSVGHidden(e);\r\n    if(svgHidden){\r\n        return r;\r\n    }else if(svgsvgHidden){\r\n        return getHiddenRelativeBoundingClientRect(e);\r\n    }else{\r\n        return getHiddenRelativeBoundingClientRect(e);\r\n    }\r\n}\r\nfunction getSVGSVGBoundingClientRect(e: SVGElement): Rectangle {\r\n    const parent = getSVGSVG(e);\r\n    let r = new Rectangle();\r\n    const rect = e.getBoundingClientRect();\r\n    const parentRect = parent.getBoundingClientRect();\r\n    r.x = rect.left - parentRect.left;\r\n    r.y = rect.top - parentRect.top;\r\n    r.width = rect.width;\r\n    r.height = rect.height;\r\n    return r;\r\n}\r\n*/\r\nfunction getSVGSVG(e) {\r\n    if (e instanceof SVGSVGElement) {\r\n        return e;\r\n    }\r\n    else {\r\n        const parent = e.parentElement;\r\n        if (parent instanceof SVGElement) {\r\n            return getSVGSVG(parent);\r\n        }\r\n        else {\r\n            throw Error(\"svgsvg\");\r\n        }\r\n    }\r\n}\r\nexports.getSVGSVG = getSVGSVG;\r\nfunction getLeastContainer(e) {\r\n    const parent = e.parentElement;\r\n    if (parent instanceof SVGSVGElement || parent instanceof SVGGElement) {\r\n        return parent;\r\n    }\r\n    else if (parent == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        if (parent instanceof SVGElement) {\r\n            return getLeastContainer(parent);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\nexports.getLeastContainer = getLeastContainer;\r\nfunction getAbsolutePosition(g) {\r\n    if (g instanceof SVGSVGElement) {\r\n        const rect = g.getBoundingClientRect();\r\n        return { x: rect.left, y: rect.top };\r\n    }\r\n    else {\r\n        const parent = getLeastContainer(g);\r\n        if (parent instanceof SVGSVGElement) {\r\n            const rect = parent.getBoundingClientRect();\r\n            const x = rect.left + SVGGExtension.getX(g);\r\n            const y = rect.top + SVGGExtension.getY(g);\r\n            return { x: x, y: y };\r\n        }\r\n        else if (parent instanceof SVGGElement) {\r\n            const rect = getAbsolutePosition(parent);\r\n            const x = rect.x + SVGGExtension.getX(g);\r\n            const y = rect.y + SVGGExtension.getY(g);\r\n            return { x: x, y: y };\r\n        }\r\n        else {\r\n            throw Error(\"error\");\r\n        }\r\n    }\r\n}\r\nexports.getAbsolutePosition = getAbsolutePosition;\r\nfunction isSVGSVGHidden(e) {\r\n    const svgsvg = getSVGSVG(e);\r\n    return !HTMLFunctions.isShow(svgsvg);\r\n}\r\nexports.isSVGSVGHidden = isSVGSVGHidden;\r\nfunction isSVGHidden(e) {\r\n    if (e instanceof SVGSVGElement) {\r\n        return false;\r\n    }\r\n    else {\r\n        const p = getComputedStyle(e);\r\n        const disp = p.display;\r\n        const vis = p.visibility;\r\n        if (disp == \"none\" || vis == \"hidden\") {\r\n            return true;\r\n        }\r\n        else {\r\n            const parent = e.parentElement;\r\n            if (parent instanceof SVGElement) {\r\n                return isSVGHidden(parent);\r\n            }\r\n            else {\r\n                throw Error(\"svg\");\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.isSVGHidden = isSVGHidden;\r\n//}\r\n//# sourceMappingURL=svg.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/svg.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/svg_element_extension.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/svg_element_extension.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nfunction getPaddingLeft(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingLeft, 5);\r\n}\r\nexports.getPaddingLeft = getPaddingLeft;\r\nfunction getPaddingTop(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingTop, 5);\r\n}\r\nexports.getPaddingTop = getPaddingTop;\r\nfunction getPaddingRight(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingRight, 5);\r\n}\r\nexports.getPaddingRight = getPaddingRight;\r\nfunction getPaddingBottom(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.paddingBottom, 5);\r\n}\r\nexports.getPaddingBottom = getPaddingBottom;\r\nfunction setPaddingLeft(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingLeft, value.toString());\r\n}\r\nexports.setPaddingLeft = setPaddingLeft;\r\nfunction setPaddingTop(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingTop, value.toString());\r\n}\r\nexports.setPaddingTop = setPaddingTop;\r\nfunction setPaddingRight(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingRight, value.toString());\r\n}\r\nexports.setPaddingRight = setPaddingRight;\r\nfunction setPaddingBottom(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.paddingBottom, value.toString());\r\n}\r\nexports.setPaddingBottom = setPaddingBottom;\r\n//# sourceMappingURL=svg_element_extension.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/svg_element_extension.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * X座標を取得します。\r\n */\r\nfunction getX(item) {\r\n    if (item.transform.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    return item.transform.baseVal.getItem(0).matrix.e;\r\n}\r\nexports.getX = getX;\r\n/**\r\n * X座標を設定します。\r\n */\r\nfunction setX(item, value) {\r\n    if (item.transform.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    const a = item.transform.baseVal.getItem(0).matrix.a;\r\n    const b = item.transform.baseVal.getItem(0).matrix.b;\r\n    const c = item.transform.baseVal.getItem(0).matrix.c;\r\n    const d = item.transform.baseVal.getItem(0).matrix.d;\r\n    const e = value;\r\n    const f = item.transform.baseVal.getItem(0).matrix.f;\r\n    item.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\r\n}\r\nexports.setX = setX;\r\n/**\r\n * Y座標を取得します。\r\n */\r\nfunction getY(item) {\r\n    if (item.transform.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    return item.transform.baseVal.getItem(0).matrix.f;\r\n}\r\nexports.getY = getY;\r\n/**\r\n * Y座標を設定します。\r\n */\r\nfunction setY(item, value) {\r\n    if (item.transform.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    const a = item.transform.baseVal.getItem(0).matrix.a;\r\n    const b = item.transform.baseVal.getItem(0).matrix.b;\r\n    const c = item.transform.baseVal.getItem(0).matrix.c;\r\n    const d = item.transform.baseVal.getItem(0).matrix.d;\r\n    const e = item.transform.baseVal.getItem(0).matrix.e;\r\n    const f = value;\r\n    item.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\r\n}\r\nexports.setY = setY;\r\n//# sourceMappingURL=svg_g_extension.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js":
/*!****************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//import { CommonFunctions } from \"../common/common_functions\";\r\n//import { HTMLFunctions } from \"./html_functions\";\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ./svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\n//import * as AttributeNames from \"../common/attribute_names\"\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\n/**\r\n * X座標を取得します。\r\n */\r\nfunction getX(item) {\r\n    if (item.x.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('x', \"0\");\r\n    }\r\n    return item.x.baseVal.getItem(0).value;\r\n}\r\nexports.getX = getX;\r\n/**\r\n * X座標を設定します。\r\n */\r\nfunction setX(item, value) {\r\n    if (item.x.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('x', \"0\");\r\n    }\r\n    //p.setAttribute('x', value.toString());\r\n    item.x.baseVal.getItem(0).value = value;\r\n}\r\nexports.setX = setX;\r\n/**\r\n * Y座標を取得します。\r\n */\r\nfunction getY(item) {\r\n    if (item.y.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('y', \"0\");\r\n    }\r\n    return item.y.baseVal.getItem(0).value;\r\n}\r\nexports.getY = getY;\r\n/**\r\n * Y座標を設定します。\r\n */\r\nfunction setY(item, value) {\r\n    if (item.y.baseVal.numberOfItems == 0) {\r\n        item.setAttribute('y', \"0\");\r\n    }\r\n    item.y.baseVal.getItem(0).value = value;\r\n}\r\nexports.setY = setY;\r\n/**\r\n* SVGTextElementのテキストを設定します。\r\n* @param text 設定するテキスト\r\n* @param isLatexMode TrueのときLatex表記を使用します。\r\n*/\r\nfunction setTextContent(item, text, isLatexMode = false) {\r\n    SVGTextBox.setTextToSVGText(item, text, isLatexMode);\r\n}\r\nexports.setTextContent = setTextContent;\r\n//setTextContent(text: string): void;\r\nfunction getMarginLeft(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginLeft, 5);\r\n}\r\nexports.getMarginLeft = getMarginLeft;\r\nfunction setMarginLeft(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginLeft, value.toString());\r\n}\r\nexports.setMarginLeft = setMarginLeft;\r\nfunction getMarginTop(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginTop, 5);\r\n}\r\nexports.getMarginTop = getMarginTop;\r\nfunction setMarginTop(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginTop, value.toString());\r\n}\r\nexports.setMarginTop = setMarginTop;\r\nfunction getMarginRight(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginRight, 5);\r\n}\r\nexports.getMarginRight = getMarginRight;\r\nfunction setMarginRight(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginRight, value.toString());\r\n}\r\nexports.setMarginRight = setMarginRight;\r\nfunction getMarginBottom(item) {\r\n    return ElementExtension.getPropertyStyleNumberValue(item, StyleNames.marginBottom, 5);\r\n}\r\nexports.getMarginBottom = getMarginBottom;\r\nfunction setMarginBottom(item, value) {\r\n    ElementExtension.setPropertyStyleValue(item, StyleNames.marginBottom, value.toString());\r\n}\r\nexports.setMarginBottom = setMarginBottom;\r\nfunction gtSetXY(text, rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\r\n    let x = rect.x;\r\n    let y = rect.y;\r\n    text.setAttribute('x', x.toString());\r\n    text.setAttribute('y', y.toString());\r\n    const b2 = SVGTextBox.getSize(text, true);\r\n    const dy = b2.y - y;\r\n    const dx = b2.x - x;\r\n    y -= dy;\r\n    x -= dx;\r\n    if (vAnchor == enums_1.VerticalAnchor.Middle) {\r\n        y += (rect.height - b2.height) / 2;\r\n    }\r\n    else if (vAnchor == enums_1.VerticalAnchor.Bottom) {\r\n        y += rect.height - b2.height;\r\n    }\r\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\r\n        x += (rect.width - b2.width) / 2;\r\n    }\r\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\r\n        x += rect.width - b2.width;\r\n    }\r\n    text.setAttribute('y', y.toString());\r\n    text.setAttribute('x', x.toString());\r\n}\r\nexports.gtSetXY = gtSetXY;\r\n//# sourceMappingURL=svg_text_extension.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js":
/*!*********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst ElementExtension = __webpack_require__(/*! ./element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst CharInfoMap = new Map();\r\nfunction getEmulatedWidthOfText(text, fontSize, fontFamily) {\r\n    if (typeof text == \"string\") {\r\n        let width = 0;\r\n        for (let i = 0; i < text.length; i++) {\r\n            const w = getEmulatedWidthOfText(text.charCodeAt(i), fontSize, fontFamily);\r\n            width += w;\r\n        }\r\n        return width;\r\n    }\r\n    else {\r\n        const info = { char: text, fontSize: fontSize, fontFamily: fontFamily };\r\n        if (CharInfoMap.has(info)) {\r\n            return CharInfoMap.get(info);\r\n        }\r\n        else {\r\n            var div = document.createElement('div');\r\n            div.style.position = 'absolute';\r\n            div.style.height = 'auto';\r\n            div.style.width = 'auto';\r\n            div.style.whiteSpace = 'nowrap';\r\n            div.style.fontFamily = fontFamily;\r\n            div.style.fontSize = fontSize.toString() + \"px\"; // large enough for good resolution\r\n            div.innerHTML = String.fromCharCode(text);\r\n            document.body.appendChild(div);\r\n            var clientWidth = div.clientWidth;\r\n            CharInfoMap.set(info, clientWidth);\r\n            document.body.removeChild(div);\r\n            return clientWidth;\r\n        }\r\n    }\r\n}\r\nfunction getTextEmulatedWidth(text) {\r\n    if (text instanceof SVGTSpanElement) {\r\n        const style = getComputedStyle(text);\r\n        const fontSize = CommonFunctions.toPX(style.fontSize);\r\n        const fontFamily = style.fontFamily;\r\n        return getEmulatedWidthOfText(text.textContent, fontSize, fontFamily);\r\n    }\r\n    else {\r\n        const tspans = HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\r\n        let len = 0;\r\n        tspans.forEach((v) => { len += getTextEmulatedWidth(v); });\r\n        return len;\r\n    }\r\n}\r\nexports.getTextEmulatedWidth = getTextEmulatedWidth;\r\nfunction getRepresentativeFontSize(text) {\r\n    if (text instanceof SVGTSpanElement) {\r\n        const style = getComputedStyle(text);\r\n        const fontSize = CommonFunctions.toPX(style.fontSize);\r\n        return fontSize;\r\n    }\r\n    else {\r\n        const tspans = HTMLFunctions.getChildren(text).filter((v) => v.nodeName == \"tspan\");\r\n        if (tspans.length > 0) {\r\n            return getRepresentativeFontSize(tspans[0]);\r\n        }\r\n        else {\r\n            const style = getComputedStyle(text);\r\n            const fontSize = CommonFunctions.toPX(style.fontSize);\r\n            return fontSize;\r\n        }\r\n    }\r\n}\r\nexports.getRepresentativeFontSize = getRepresentativeFontSize;\r\n/**\r\n * 入力テキストをLatex表記でパースした結果をSVGTSpanElement配列で返します。\r\n * @param text Latex表記のテキスト\r\n * @param className 生成したSVGTSpanElementのクラス属性名\r\n * @param fontsize 生成したSVGTSpanElementのフォントサイズ\r\n * @param dxOfFirstElement 生成した最初のSVGTSpanElementのdx\r\n * @param dyOfFirstElement 生成した最初のSVGTSpanElementのdy\r\n * @returns 入力テキストをLatex表記でパースした結果をSVGTSpanElement配列\r\n */\r\nfunction createTextSpans(text, className = null, fontsize = 12, dxOfFirstElement = null, dyOfFirstElement = null) {\r\n    let r = [];\r\n    text += \"_\";\r\n    //const p: SVGTextElement = this;\r\n    //p.textContent = \"\";\r\n    //const h = parseInt(p.getPropertyStyleValueWithDefault(\"font-size\", \"12\"));\r\n    let isFst = true;\r\n    let mode = \"\";\r\n    let tmp = \"\";\r\n    const char_dy = (1 * fontsize) / 3;\r\n    let lastMode = \"none\";\r\n    const smallFontSize = (2 * fontsize) / 3;\r\n    for (let i = 0; i < text.length; i++) {\r\n        const c = text[i];\r\n        if (c == \"_\" || c == \"{\" || c == \"^\" || c == \"}\") {\r\n            mode += c;\r\n            if (mode == \"_{}\") {\r\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                tspan.textContent = tmp;\r\n                tspan.setAttribute(\"dy\", `${char_dy}`);\r\n                tspan.setAttribute(\"data-script\", \"subscript\");\r\n                tspan.style.fontSize = `${smallFontSize}pt`;\r\n                r.push(tspan);\r\n                lastMode = \"down\";\r\n                mode = \"\";\r\n                tmp = \"\";\r\n            }\r\n            else if (mode == \"^{}\") {\r\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                tspan.textContent = tmp;\r\n                tspan.setAttribute(\"dy\", `-${char_dy}`);\r\n                tspan.style.fontSize = `${smallFontSize}pt`;\r\n                tspan.setAttribute(\"data-script\", \"superscript\");\r\n                r.push(tspan);\r\n                lastMode = \"up\";\r\n                mode = \"\";\r\n                tmp = \"\";\r\n            }\r\n            else if (mode == \"_\" || mode == \"^\") {\r\n                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                tspan.textContent = tmp;\r\n                const normaldy = lastMode == \"up\" ? char_dy : lastMode == \"down\" ? -char_dy : 0;\r\n                if (isFst) {\r\n                    if (dxOfFirstElement != null)\r\n                        tspan.setAttribute(\"dx\", `${dxOfFirstElement}`);\r\n                    if (dyOfFirstElement != null)\r\n                        tspan.setAttribute(\"dy\", `${dyOfFirstElement}`);\r\n                }\r\n                else {\r\n                    tspan.setAttribute(\"dy\", `${normaldy}`);\r\n                }\r\n                r.push(tspan);\r\n                lastMode = \"none\";\r\n                tmp = \"\";\r\n                isFst = false;\r\n            }\r\n        }\r\n        else {\r\n            tmp += c;\r\n        }\r\n    }\r\n    return r;\r\n}\r\n/*\r\nexport function getLength(svgText : SVGTextElement) : number{\r\n    const children = svgText.children;\r\n    let m = 0;\r\n    for(let i=0;i<children.length;i++){\r\n        const child = children.item(i);\r\n        if(child instanceof SVGTSpanElement){\r\n            m += child.getComputedTextLength();\r\n        }\r\n    }\r\n    return             svgText.getComputedTextLength            ;\r\n}\r\n*/\r\n/**\r\n * SVGTextElementにテキストをセットします。\r\n * @param svgText テキストをセットされるSVG要素\r\n * @param text SVG要素に適用するテキスト\r\n * @param isLatexMode Latex表記を使用するかどうか\r\n */\r\nfunction setTextToSVGText(svgText, text, isLatexMode) {\r\n    svgText.textContent = \"\";\r\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"12\");\r\n    const fs = parseInt(fontSize);\r\n    let dx = 0;\r\n    text.split(\"\\n\").forEach((lineText) => {\r\n        let dy = fs;\r\n        let width = 0;\r\n        if (isLatexMode) {\r\n            createTextSpans(lineText, null, fs, dx, dy).forEach((v) => {\r\n                svgText.appendChild(v);\r\n                const tLen = v.getComputedTextLength();\r\n                dx = 0;\r\n                dy = 0;\r\n                width += tLen;\r\n            });\r\n            dy += fs;\r\n        }\r\n        else {\r\n            svgText.appendChild(createSingleTextSpan(lineText, null));\r\n        }\r\n        dx = -width;\r\n    });\r\n}\r\nexports.setTextToSVGText = setTextToSVGText;\r\n/**\r\n* SVGTextPathElementにテキストをセットします。\r\n* @param path テキストをセットされるパス\r\n* @param text パスに適用するテキスト\r\n* @param isLatexMode Latex表記を使用するかどうか\r\n*/\r\nfunction setTextToTextPath(path, text, isLatexMode) {\r\n    path.textContent = \"\";\r\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(path, \"font-size\", \"12\");\r\n    if (isLatexMode) {\r\n        createTextSpans(text, null, parseInt(fontSize)).forEach((v) => path.appendChild(v));\r\n    }\r\n    else {\r\n        path.appendChild(createSingleTextSpan(text, null));\r\n    }\r\n}\r\nexports.setTextToTextPath = setTextToTextPath;\r\n/**\r\n * 入力テキストからSVGTSpanElementを生成します。\r\n * @param text SVGTSpanElementのテキスト\r\n * @param className SVGTSpanElementのクラス属性名\r\n * @returns 生成されるSVGTSpanElement\r\n */\r\nfunction createSingleTextSpan(text, className = null) {\r\n    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n    tspan.textContent = text;\r\n    if (className != null) {\r\n        tspan.setAttribute(\"class\", className);\r\n    }\r\n    return tspan;\r\n}\r\nfunction copy(e, target) {\r\n    for (let i = 0; i < e.attributes.length; i++) {\r\n        const attr = e.attributes.item(i);\r\n        if (attr != null) {\r\n            const name = attr.name;\r\n            const value = attr.value;\r\n            target.setAttribute(name, value);\r\n        }\r\n    }\r\n}\r\nfunction getLines(svgText) {\r\n    const spans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n    let r = [];\r\n    if (spans.length == 0) {\r\n        return [];\r\n    }\r\n    else {\r\n        r.push([]);\r\n        let y = 0;\r\n        spans.forEach((v, i) => {\r\n            if (v.getAttribute(\"newline\") == \"true\") {\r\n                r.push([v]);\r\n                y++;\r\n            }\r\n            else {\r\n                r[y].push(v);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n}\r\nfunction alignTextByHorizontalAnchor(svgText, hAnchor) {\r\n    const lineSpans = getLines(svgText);\r\n    let dx = 0;\r\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\r\n        const tl = getComputedTextLengthsOfTSpans(svgText, true);\r\n        let p = 0;\r\n        let maxWidth = 0;\r\n        const widths = lineSpans.map((v) => {\r\n            let width = 0;\r\n            v.forEach((w) => {\r\n                width += tl[p++].width;\r\n            });\r\n            return width;\r\n        });\r\n        p = 0;\r\n        widths.forEach((v) => {\r\n            if (v > maxWidth)\r\n                maxWidth = v;\r\n        });\r\n        dx = 0;\r\n        if (widths.length > 0) {\r\n            for (let y = 0; y < lineSpans.length; y++) {\r\n                const offset = (maxWidth - widths[y]) / 2;\r\n                let width = offset;\r\n                for (let x = 0; x < lineSpans[y].length; x++) {\r\n                    const v = lineSpans[y][x];\r\n                    //const tLen = v.getComputedTextLength();\r\n                    const tLen = tl[p++].width;\r\n                    if (x == 0 && y != 0) {\r\n                        v.setAttribute(\"dx\", (dx + offset).toString());\r\n                    }\r\n                    width += tLen;\r\n                }\r\n                dx = -width;\r\n            }\r\n        }\r\n    }\r\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\r\n    }\r\n}\r\nfunction alignTextAsText(svgText, showChecked) {\r\n    const lineSpans = getLines(svgText);\r\n    const fontSize = ElementExtension.getPropertyStyleValueWithDefault(svgText, \"font-size\", \"24\");\r\n    const fs = parseInt(fontSize);\r\n    let dx = 0;\r\n    let dy = fs;\r\n    let c = 0;\r\n    const lengths = getComputedTextLengthsOfTSpans(svgText, showChecked);\r\n    for (let y = 0; y < lineSpans.length; y++) {\r\n        let width = 0;\r\n        let heightMax = fs;\r\n        let fstObj = null;\r\n        for (let x = 0; x < lineSpans[y].length; x++) {\r\n            const v = lineSpans[y][x];\r\n            //const tLen = v.getComputedTextLength();\r\n            const size = lengths[c++];\r\n            if (size.height > heightMax)\r\n                heightMax = size.height;\r\n            if (x == 0)\r\n                v.setAttribute(\"dx\", dx.toString());\r\n            if (x == 0)\r\n                fstObj = v;\r\n            width += size.width;\r\n        }\r\n        if (y != 0 && fstObj != null)\r\n            fstObj.setAttribute(\"dy\", heightMax.toString());\r\n        dx -= width;\r\n        //dy += fs;\r\n    }\r\n}\r\n/**\r\n * SVGTextElement\r\n * @param svgText\r\n * @param hAnchor\r\n */\r\nfunction sortText(svgText, hAnchor, showChecked) {\r\n    alignTextAsText(svgText, showChecked);\r\n    alignTextByHorizontalAnchor(svgText, hAnchor);\r\n}\r\nexports.sortText = sortText;\r\nfunction constructSVGTextByHTMLElements(svgText, text, isLatexMode) {\r\n    svgText.textContent = \"\";\r\n    const spans = text.map((v, i) => {\r\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n        tspan.innerHTML = v.innerHTML;\r\n        copy(v, tspan);\r\n        return tspan;\r\n    });\r\n    let dy = 0;\r\n    spans.forEach((v, i) => {\r\n        svgText.appendChild(v);\r\n    });\r\n}\r\nexports.constructSVGTextByHTMLElements = constructSVGTextByHTMLElements;\r\nlet ura = null;\r\nfunction getSize(svgText, showChecked = false) {\r\n    let r = new vline_1.Rectangle();\r\n    /*\r\n    try{\r\n        const rect = svgText.getBBox();\r\n        r.x = rect.x;\r\n        r.y = rect.y;\r\n        r.width = rect.width;\r\n        r.height = rect.height;\r\n        return r;\r\n    }catch(e){\r\n        return new Rectangle();\r\n    }\r\n    */\r\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\r\n    if (b) {\r\n        const rect = svgText.getBBox();\r\n        r.x = rect.x;\r\n        r.y = rect.y;\r\n        r.width = rect.width;\r\n        r.height = rect.height;\r\n        return r;\r\n    }\r\n    else {\r\n        return new vline_1.Rectangle();\r\n        /*\r\n        if(ura == null){\r\n            ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        }\r\n        document.body.appendChild(ura);\r\n        ura.innerHTML = svgText.outerHTML;\r\n        const fst = ura.firstChild;\r\n        if(fst instanceof SVGTextElement){\r\n\r\n            const rect = fst.getBBox();\r\n            r.x = rect.x;\r\n            r.y = rect.y;\r\n            r.width = rect.width;\r\n            r.height = rect.height;\r\n \r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n            return r;\r\n        }else if(fst != null){\r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n            return r;\r\n        }else{\r\n            ura.remove();\r\n            return r;\r\n        }\r\n        */\r\n    }\r\n}\r\nexports.getSize = getSize;\r\nfunction getComputedTextLengthsOfTSpans(svgText, showChecked) {\r\n    const b = showChecked ? true : HTMLFunctions.isShow(svgText);\r\n    if (b) {\r\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n        const r = tspans.map((v) => {\r\n            const w = v.getComputedTextLength();\r\n            //const h = v.getBoundingClientRect().height;\r\n            const fontSize = ElementExtension.getPropertyStyleValueWithDefault(v, \"font-size\", \"24\");\r\n            const fs = CommonFunctions.toPX(fontSize);\r\n            return new vline_1.Size(w, fs);\r\n        });\r\n        return r;\r\n    }\r\n    else {\r\n        const tspans = HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n        const r = tspans.map((v) => {\r\n            return new vline_1.Size(0, 0);\r\n        });\r\n        return r;\r\n        //return [];\r\n        /*\r\n        if(ura == null){\r\n            ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        }\r\n        document.body.appendChild(ura);\r\n        ura.innerHTML = svgText.outerHTML;\r\n        const fst = ura.firstChild;\r\n        if(fst instanceof SVGTextElement){\r\n\r\n            const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\r\n            const r = tspans.map((v)=> {\r\n                const w = v.getComputedTextLength();\r\n            const fontSize = svgText.getPropertyStyleValueWithDefault(\"font-size\", \"24\");\r\n            const fs = CommonFunctions.toPX(fontSize);\r\n                return new Size(w, fs);\r\n            })\r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n            return r;\r\n        }else if(fst != null){\r\n            ura.removeChild(fst);\r\n            ura.remove();\r\n            return [];\r\n        }else{\r\n            ura.remove();\r\n            return [];\r\n        }\r\n        */\r\n    }\r\n}\r\nexports.getComputedTextLengthsOfTSpans = getComputedTextLengthsOfTSpans;\r\n/*\r\nexport function getComputedTSpanLength(svgText:SVGTSpanElement) : number {\r\nif(HTMLFunctions.isShow(svgText)){\r\n    return svgText.getComputedTextLength();\r\n}else{\r\n    if(ura == null){\r\n        ura = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n    }\r\n    document.body.appendChild(ura);\r\n    ura.innerHTML = svgText.outerHTML;\r\n    const fst = ura.firstChild;\r\n    if(fst instanceof SVGTextElement){\r\n\r\n        const tspans = <SVGTSpanElement[]>HTMLFunctions.getChildren(fst).filter((v)=>v.nodeName==\"tspan\");\r\n        const r = tspans.map((v)=>v.getComputedTextLength());\r\n        ura.removeChild(fst);\r\n        ura.remove();\r\n        return r;\r\n    }else if(fst != null){\r\n        ura.removeChild(fst);\r\n        ura.remove();\r\n        return [];\r\n    }else{\r\n        ura.remove();\r\n        return [];\r\n    }\r\n}\r\n}\r\n*/\r\n//}\r\n//# sourceMappingURL=svg_textbox.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/gobject_functions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/gobject_functions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./node_modules/graph-table-svg/dist/logics/logic_text.js\");\r\nfunction createTextElementFromLogicCell(item, svgText) {\r\n    if (item.tTexts != null) {\r\n        SVGTextBox.constructSVGTextByHTMLElements(svgText, item.tTexts, true);\r\n    }\r\n    else if (item.text instanceof logic_text_1.LogicText) {\r\n        item.text.setTextElement(svgText);\r\n    }\r\n}\r\nexports.createTextElementFromLogicCell = createTextElementFromLogicCell;\r\n//# sourceMappingURL=gobject_functions.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/gobject_functions.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./node_modules/graph-table-svg/dist/logics/logic_text.js\");\r\nexports.LogicTSpan = logic_text_1.LogicTSpan;\r\nexports.LogicText = logic_text_1.LogicText;\r\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./node_modules/graph-table-svg/dist/logics/logic_cell.js\");\r\nexports.LogicCell = logic_cell_1.LogicCell;\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\nexports.LogicTable = logic_table_1.LogicTable;\r\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\nexports.LogicGraph = logic_tree_1.LogicGraph;\r\nexports.LogicGraphEdge = logic_tree_1.LogicGraphEdge;\r\nexports.LogicGraphNode = logic_tree_1.LogicGraphNode;\r\nexports.LogicTree = logic_tree_1.LogicTree;\r\nexports.BinaryLogicTree = logic_tree_1.BinaryLogicTree;\r\nexports.Test = logic_tree_1.Test;\r\nconst logic_table_line_1 = __webpack_require__(/*! ./logic_table_line */ \"./node_modules/graph-table-svg/dist/logics/logic_table_line.js\");\r\nexports.getIndexArrayTableLine = logic_table_line_1.getIndexArrayTableLine;\r\nexports.buildLogicTable = logic_table_line_1.buildLogicTable;\r\nexports.toLogicCellLine = logic_table_line_1.toLogicCellLine;\r\nconst logic_builder_1 = __webpack_require__(/*! ./logic_builder */ \"./node_modules/graph-table-svg/dist/logics/logic_builder.js\");\r\nexports.buildLogicObjectFromJSON = logic_builder_1.buildLogicObjectFromJSON;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_builder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_builder.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\nfunction buildLogicObjectFromJSON(data) {\r\n    const obj = JSON.parse(data);\r\n    const type = obj[\"objectType\"];\r\n    if (type == \"LogicTree\") {\r\n        const w = new logic_tree_1.LogicTree();\r\n        w.buildFromObject(obj);\r\n        return w;\r\n    }\r\n    else if (type == \"LogicTable\") {\r\n        const w = new logic_table_1.LogicTable();\r\n        w.buildFromObject(obj);\r\n        return w;\r\n    }\r\n    else {\r\n        const w = new logic_tree_1.LogicGraph();\r\n        //w.buildFromObject(obj);\r\n        return w;\r\n    }\r\n}\r\nexports.buildLogicObjectFromJSON = buildLogicObjectFromJSON;\r\n//# sourceMappingURL=logic_builder.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_builder.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_cell.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_cell.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst attribute_names_1 = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst logic_text_1 = __webpack_require__(/*! ./logic_text */ \"./node_modules/graph-table-svg/dist/logics/logic_text.js\");\r\nclass LogicCell {\r\n    //public isLatexMode: boolean = false;\r\n    constructor() {\r\n        this.text = new logic_text_1.LogicText();\r\n        //public textClass?: string | GOptions.textClassCSS;\r\n        //public textStyle?: string | GOptions.textClassCSS;\r\n        this.cellClass = attribute_names_1.defaultCellClass;\r\n        //public svgText: SVGTextElement | null = null;\r\n        this.connectedColumnCount = 1;\r\n        this.connectedRowCount = 1;\r\n        this.tTexts = null;\r\n    }\r\n    buildFromObject(obj) {\r\n        this.text.buildFromObject(obj[\"text\"]);\r\n        this.cellClass = obj[\"cellClass\"];\r\n        this.cellStyle = obj[\"cellStyle\"];\r\n        this.backgroundClass = obj[\"backgroundClass\"];\r\n        this.topBorderClass = obj[\"topBorderClass\"];\r\n        this.leftBorderClass = obj[\"leftBorderClass\"];\r\n        this.rightBorderClass = obj[\"rightBorderClass\"];\r\n        this.bottomBorderClass = obj[\"bottomBorderClass\"];\r\n        this.connectedColumnCount = obj[\"connectedColumnCount\"];\r\n        this.connectedRowCount = obj[\"connectedRowCount\"];\r\n    }\r\n    copy(cell) {\r\n        this.text = cell.text;\r\n        this.cellClass = cell.cellClass;\r\n        this.cellStyle = cell.cellStyle;\r\n        this.backgroundClass = cell.backgroundClass;\r\n        if (cell.topBorderClass !== undefined)\r\n            this.topBorderClass = cell.topBorderClass;\r\n        if (cell.leftBorderClass !== undefined)\r\n            this.leftBorderClass = cell.topBorderClass;\r\n        if (cell.rightBorderClass !== undefined)\r\n            this.rightBorderClass = cell.rightBorderClass;\r\n        if (cell.bottomBorderClass !== undefined) {\r\n            this.bottomBorderClass = cell.bottomBorderClass;\r\n        }\r\n        this.connectedRowCount = cell.connectedRowCount;\r\n        this.connectedColumnCount = cell.connectedColumnCount;\r\n        this.item = cell.item;\r\n    }\r\n    set(text = undefined, isLatexMode = false, cellClass = undefined, backgroundClass = undefined, topBorderClass = undefined, leftBorderClass = undefined, rightBorderClass = undefined, bottomBorderClass = undefined) {\r\n        if (text !== undefined)\r\n            this.text = text;\r\n        if (cellClass !== undefined)\r\n            this.cellClass = cellClass;\r\n        //if (textClass !== undefined) this.textClass = textClass;\r\n        if (backgroundClass !== undefined)\r\n            this.backgroundClass = backgroundClass;\r\n        if (topBorderClass !== undefined)\r\n            this.topBorderClass = topBorderClass;\r\n        if (leftBorderClass !== undefined)\r\n            this.leftBorderClass = leftBorderClass;\r\n        if (rightBorderClass !== undefined)\r\n            this.rightBorderClass = rightBorderClass;\r\n        if (bottomBorderClass !== undefined)\r\n            this.bottomBorderClass = bottomBorderClass;\r\n        //this.isLatexMode = isLatexMode;\r\n    }\r\n}\r\nexports.LogicCell = LogicCell;\r\n//# sourceMappingURL=logic_cell.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_cell.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_table.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_table.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\nexport class HTMLLogicCell{\r\n    public text: string | null = null;\r\n    public cellClass: string | null = null;\r\n    public connectedColumnCount: number = 1;\r\n    public connectedRowCount: number = 1;\r\n    public item: any;\r\n}\r\n*/\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\n//import * as Console from \"../../options/console\"\r\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./node_modules/graph-table-svg/dist/logics/logic_cell.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\n//import { Cell } from \"../object/table_helpers/cell\"\r\n//import * as GOptions from \"../object/g_options\"\r\n/**\r\n * 表を表現するクラスです。\r\n */\r\nclass LogicTable {\r\n    constructor(option = {}) {\r\n        this.tableClassName = null;\r\n        this.x = null;\r\n        this.y = null;\r\n        this.objectType = \"LogicTable\";\r\n        if (option.columnCount == undefined)\r\n            option.columnCount = 3;\r\n        if (option.rowCount == undefined)\r\n            option.rowCount = 3;\r\n        if (option.x == undefined)\r\n            option.x = 0;\r\n        if (option.y == undefined)\r\n            option.y = 0;\r\n        [this.x, this.y] = [option.x, option.y];\r\n        //if(option.tableClassName == undefined) option.tableClassName = null;\r\n        this.tableClassName = option.tableClassName == undefined ? null : option.tableClassName;\r\n        this.cells = new Array(option.rowCount);\r\n        for (let y = 0; y < option.rowCount; y++) {\r\n            this.cells[y] = new Array(option.columnCount);\r\n            for (let x = 0; x < option.columnCount; x++) {\r\n                this.cells[y][x] = new logic_cell_1.LogicCell();\r\n            }\r\n        }\r\n        this.rowHeights = new Array(option.rowCount);\r\n        for (let y = 0; y < option.rowCount; y++) {\r\n            this.rowHeights[y] = null;\r\n        }\r\n        this.columnWidths = new Array(option.columnCount);\r\n        for (let x = 0; x < option.columnCount; x++) {\r\n            this.columnWidths[x] = null;\r\n        }\r\n    }\r\n    get rowCount() {\r\n        return this.rowHeights.length;\r\n    }\r\n    get columnCount() {\r\n        return this.columnWidths.length;\r\n    }\r\n    buildFromObject(obj) {\r\n        this.x = obj[\"x\"];\r\n        this.y = obj[\"y\"];\r\n        this.tableClassName = obj[\"tableClassName\"];\r\n        this.rowHeights = obj[\"rowHeights\"];\r\n        this.columnWidths = obj[\"columnWidths\"];\r\n        const cells = obj[\"cells\"];\r\n        const rowCount = cells.length;\r\n        const columnCount = rowCount == 0 ? 0 : cells[0].length;\r\n        for (let y = 0; y < rowCount; y++) {\r\n            this.cells[y] = new Array(columnCount);\r\n            for (let x = 0; x < columnCount; x++) {\r\n                this.cells[y][x] = new logic_cell_1.LogicCell();\r\n                this.cells[y][x].buildFromObject(cells[y][x]);\r\n            }\r\n        }\r\n    }\r\n    get cellArray() {\r\n        const r = new Array();\r\n        for (let y = 0; y < this.rowHeights.length; y++) {\r\n            for (let x = 0; x < this.columnWidths.length; x++) {\r\n                r.push(this.cells[y][x]);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    getColumn(i) {\r\n        const r = new Array();\r\n        for (let y = 0; y < this.rowHeights.length; y++) {\r\n            r.push(this.cells[y][i]);\r\n        }\r\n        return r;\r\n    }\r\n    getRow(i) {\r\n        const r = new Array();\r\n        for (let x = 0; x < this.columnWidths.length; x++) {\r\n            r.push(this.cells[i][x]);\r\n        }\r\n        return r;\r\n    }\r\n    /*\r\n    public checkTable(): boolean {\r\n\r\n    }\r\n    */\r\n    static parse(str, delimiter) {\r\n        const lines = str.split(\"\\n\");\r\n        const r = new Array(lines.length);\r\n        for (let y = 0; y < lines.length; y++) {\r\n            const line = lines[y].split(delimiter);\r\n            r[y] = new Array(line.length);\r\n            for (let x = 0; x < line.length; x++) {\r\n                r[y][x] = line[x];\r\n            }\r\n            if (y > 0) {\r\n                if (r[y].length != r[y - 1].length) {\r\n                    alert(\"Parse Error\");\r\n                    throw Error(\"Parse Error\");\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    static create(str, tableClassName = null) {\r\n        const table = new LogicTable({ columnCount: str[0].length, rowCount: str.length, tableClassName: tableClassName == null ? undefined : tableClassName });\r\n        for (let y = 0; y < str.length; y++) {\r\n            for (let x = 0; x < str[y].length; x++) {\r\n                const p = str[y][x].split(\"%%%\");\r\n                table.cells[y][x].text.textContent = p[0];\r\n                if (p.length == 3) {\r\n                    table.cells[y][x].connectedColumnCount = Number(p[1]);\r\n                    table.cells[y][x].connectedRowCount = Number(p[2]);\r\n                }\r\n            }\r\n        }\r\n        return table;\r\n    }\r\n    static constructLogicTable(e) {\r\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\r\n        const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\r\n        if (rows.length == 0)\r\n            return null;\r\n        const cells = new Array(rows.length);\r\n        let columnSize = 0;\r\n        rows.forEach((v, i) => {\r\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\r\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\r\n            cells[i] = cellArray;\r\n            if (columnSize < cellArray.length)\r\n                columnSize = cellArray.length;\r\n        });\r\n        const logicTable = new LogicTable({ rowCount: rows.length, columnCount: columnSize });\r\n        ;\r\n        //output.table = new LogicTable({ rowCount: rows.length, columnCount: columnSize });\r\n        if (widthsStr != null) {\r\n            const widths = JSON.parse(widthsStr);\r\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\r\n        }\r\n        for (let y = 0; y < cells.length; y++) {\r\n            const h = ElementExtension.getPropertyStyleNumberValue(rows[y], \"--height\", null);\r\n            logicTable.rowHeights[y] = h;\r\n            for (let x = 0; x < cells[y].length; x++) {\r\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\r\n                if (cells[y][x].hasAttribute(\"w\")) {\r\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\r\n                    logicTable.cells[y][x].connectedColumnCount = w;\r\n                }\r\n                if (cells[y][x].hasAttribute(\"h\")) {\r\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\r\n                    logicTable.cells[y][x].connectedRowCount = h;\r\n                }\r\n                const tNodes = HTMLFunctions.getTNodes(cells[y][x]);\r\n                if (tNodes != null)\r\n                    logicTable.cells[y][x].tTexts = tNodes;\r\n            }\r\n        }\r\n        return logicTable;\r\n    }\r\n    static constructHTMLLogicTable(e) {\r\n        const rows = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(AttributeNames.customElement) == \"row\").map((v) => v);\r\n        const widthsStr = ElementExtension.getPropertyStyleValue(e, \"--widths\");\r\n        if (rows.length == 0)\r\n            return null;\r\n        const cells = new Array(rows.length);\r\n        let columnSize = 0;\r\n        rows.forEach((v, i) => {\r\n            const cellArray = HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(AttributeNames.customElement) == \"cell\");\r\n            cellArray.forEach((v) => v.removeAttribute(AttributeNames.customElement));\r\n            cells[i] = cellArray;\r\n            if (columnSize < cellArray.length)\r\n                columnSize = cellArray.length;\r\n        });\r\n        const logicTable = new LogicTable({ rowCount: rows.length, columnCount: columnSize });\r\n        ;\r\n        if (widthsStr != null) {\r\n            const widths = JSON.parse(widthsStr);\r\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\r\n        }\r\n        for (let y = 0; y < cells.length; y++) {\r\n            const h = ElementExtension.getPropertyStyleNumberValue(rows[y], \"--height\", null);\r\n            logicTable.rowHeights[y] = h;\r\n            for (let x = 0; x < cells[y].length; x++) {\r\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\r\n                if (cells[y][x].hasAttribute(\"w\")) {\r\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\r\n                    logicTable.cells[y][x].connectedColumnCount = w;\r\n                }\r\n                if (cells[y][x].hasAttribute(\"h\")) {\r\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\r\n                    logicTable.cells[y][x].connectedRowCount = h;\r\n                }\r\n                //const tNodes = openSVGFunctions.getTNodes(cells[y][x]);\r\n                logicTable.cells[y][x].text.textContent = cells[y][x].innerHTML;\r\n            }\r\n        }\r\n        return logicTable;\r\n    }\r\n}\r\nexports.LogicTable = LogicTable;\r\n//# sourceMappingURL=logic_table.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_table.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_table_line.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_table_line.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//import {LogicCell} from \"./logic_cell\"\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\nconst logic_cell_1 = __webpack_require__(/*! ./logic_cell */ \"./node_modules/graph-table-svg/dist/logics/logic_cell.js\");\r\n//export type LogicTableDetailLine = LogicCell[]; \r\nfunction setCell(cell, value, cellClass) {\r\n    if (value instanceof logic_cell_1.LogicCell) {\r\n        cell.copy(value);\r\n    }\r\n    else {\r\n        cell.text.textContent = value.toString();\r\n    }\r\n    if (cellClass !== undefined) {\r\n        cell.cellClass = cellClass;\r\n    }\r\n}\r\n/*\r\nexport type LogicTableLine = { name: string, values: (number | string | LogicCell)[], cellClass?: string | GOptions.GTextBoxCSS }\r\nfunction setRow(table: LogicTable, ithRow: number, line: LogicTableLine) {\r\n    table.cells[ithRow][0].text.textContent = line.name;\r\n    line.values.forEach((v, i) => {\r\n        setCell(table.cells[ithRow][i + 1], v, line.cellClass);\r\n    })\r\n}\r\nfunction setColumn(table: LogicTable, ithColumn: number, line: LogicTableLine) {\r\n    table.cells[0][ithColumn].text.textContent = line.name;\r\n    line.values.forEach((v, i) => {\r\n        setCell(table.cells[i + 1][ithColumn], v, line.cellClass);\r\n    })\r\n}\r\nexport function createLogicTable(lines: LogicTableLine[] | LogicTableLine,\r\n    option?: { isRowLines?: boolean }): LogicTable {\r\n    if (option == undefined) option = {};\r\n    if (option.isRowLines == undefined) option.isRowLines = true;\r\n    //if (option.withIndex == undefined) option.withIndex = false;\r\n\r\n    if (lines instanceof Array) {\r\n\r\n\r\n        let maximalLineLength = 0;\r\n        lines.forEach((v) => {\r\n            if (maximalLineLength < v.values.length) {\r\n                maximalLineLength = v.values.length\r\n            }\r\n        }\r\n        )\r\n        const rowCount = option.isRowLines ? lines.length : maximalLineLength + 1;\r\n        const columnCount = option.isRowLines ? maximalLineLength + 1 : lines.length;\r\n        const table: LogicTable = new LogicTable({ rowCount: rowCount, columnCount: columnCount });\r\n\r\n        if (option.isRowLines) {\r\n            lines.forEach((v, i) => {\r\n                setRow(table, i, v);\r\n            })\r\n        } else {\r\n            lines.forEach((v, i) => {\r\n                setColumn(table, i, v);\r\n            })\r\n\r\n        }\r\n        return table;\r\n    } else {\r\n        return createLogicTable([lines], option);\r\n    }\r\n}\r\n*/\r\nfunction getIndexArray(length, zeroBased = true) {\r\n    return Array.from(Array(length).keys()).map((i) => zeroBased ? i : (i + 1));\r\n}\r\nexports.getIndexArray = getIndexArray;\r\nfunction getIndexArrayTableLine(length, zeroBased = true) {\r\n    const arr = getIndexArray(length, zeroBased);\r\n    const name = \"Index\";\r\n    const r = { name: name, values: arr };\r\n    return toLogicCellLine(r.name, r.values);\r\n}\r\nexports.getIndexArrayTableLine = getIndexArrayTableLine;\r\nfunction setRow2(table, ithRow, line) {\r\n    //table.cells[ithRow][0].text.textContent = line.name;\r\n    line.forEach((v, i) => {\r\n        setCell(table.cells[ithRow][i], v);\r\n    });\r\n}\r\nfunction setColumn2(table, ithColumn, line) {\r\n    line.forEach((v, i) => {\r\n        setCell(table.cells[i][ithColumn], v);\r\n    });\r\n}\r\nfunction toLogicCellLine(name, values, cellClass) {\r\n    const titleCell = new logic_cell_1.LogicCell();\r\n    titleCell.text.textContent = name;\r\n    if (cellClass !== undefined) {\r\n        titleCell.cellClass = cellClass;\r\n    }\r\n    const cells = values.map((v) => {\r\n        const cell = new logic_cell_1.LogicCell();\r\n        cell.text.textContent = v.toString();\r\n        if (cellClass !== undefined) {\r\n            cell.cellClass = cellClass;\r\n        }\r\n        return cell;\r\n    });\r\n    return [titleCell].concat(cells);\r\n}\r\nexports.toLogicCellLine = toLogicCellLine;\r\nfunction buildLogicTable(lines, option) {\r\n    if (option == undefined)\r\n        option = {};\r\n    if (option.isRowLines == undefined)\r\n        option.isRowLines = true;\r\n    //if (option.withIndex == undefined) option.withIndex = false;\r\n    let maximalLineLength = 0;\r\n    lines.forEach((v) => {\r\n        if (maximalLineLength < v.length) {\r\n            maximalLineLength = v.length;\r\n        }\r\n    });\r\n    const rowCount = option.isRowLines ? lines.length : maximalLineLength;\r\n    const columnCount = option.isRowLines ? maximalLineLength : lines.length;\r\n    const table = new logic_table_1.LogicTable({ rowCount: rowCount, columnCount: columnCount });\r\n    if (option.isRowLines) {\r\n        lines.forEach((v, i) => {\r\n            setRow2(table, i, v);\r\n        });\r\n    }\r\n    else {\r\n        lines.forEach((v, i) => {\r\n            setColumn2(table, i, v);\r\n        });\r\n    }\r\n    return table;\r\n}\r\nexports.buildLogicTable = buildLogicTable;\r\n//# sourceMappingURL=logic_table_line.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_table_line.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_text.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_text.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js\");\r\nclass LogicTSpan {\r\n    constructor() {\r\n        this.textContent = \"\";\r\n        this.isLatexMode = false;\r\n    }\r\n    createTSpan() {\r\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n        tspan.textContent = this.textContent;\r\n        CSS.setCSSClass(tspan, this.class);\r\n        CSS.setCSSStyle(tspan, this.style);\r\n        return tspan;\r\n    }\r\n    parse(obj) {\r\n        this.textContent = obj[\"textContent\"];\r\n        this.class = obj[\"class\"];\r\n        this.style = obj[\"style\"];\r\n        this.isLatexMode = obj[\"isLatexMode\"];\r\n    }\r\n}\r\nexports.LogicTSpan = LogicTSpan;\r\nclass LogicText {\r\n    constructor(_text = null, _class, _style) {\r\n        this.textContent = \"\";\r\n        this.isLatexMode = false;\r\n        if (_text == null) {\r\n            this.textContent = \"\";\r\n        }\r\n        else {\r\n            this.textContent = _text;\r\n        }\r\n        this.class = _class;\r\n        this.style = _style;\r\n    }\r\n    setTextElement(svgText) {\r\n        CSS.setCSSClass(svgText, this.class);\r\n        CSS.setCSSStyle(svgText, this.style);\r\n        if (typeof this.textContent == \"string\") {\r\n            SVGTextExtension.setTextContent(svgText, this.textContent, this.isLatexMode);\r\n        }\r\n        else {\r\n            svgText.textContent = \"\";\r\n            this.textContent.map((v) => v.createTSpan()).forEach((v) => {\r\n                svgText.appendChild(v);\r\n            });\r\n        }\r\n    }\r\n    buildFromObject(obj) {\r\n        if (Array.isArray(obj[\"textContent\"])) {\r\n            const arr = obj[\"textContent\"];\r\n            this.textContent = new Array(arr.length);\r\n            for (let i = 0; i < arr.length; i++) {\r\n                this.textContent[i] = new LogicTSpan();\r\n                this.textContent[i].parse(arr[i]);\r\n            }\r\n        }\r\n        else {\r\n            this.textContent = obj[\"textContent\"];\r\n        }\r\n        this.class = obj[\"class\"];\r\n        this.style = obj[\"style\"];\r\n        this.isLatexMode = obj[\"isLatexMode\"];\r\n    }\r\n}\r\nexports.LogicText = LogicText;\r\n//# sourceMappingURL=logic_text.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_text.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/logics/logic_tree.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/logics/logic_tree.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\nexport class BaseLogicTree {\r\n    public edgeLabel: string | null = null;\r\n    public nodeText: string | null = null;\r\n}\r\n*/\r\n//import * as Console from \"../../options/console\"\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\n/*\r\nexport type LogicTreeOption = {\r\n    x?: number,\r\n    y?: number,\r\n    isLatexMode?: boolean\r\n    relocateStyle?: string\r\n    direction?: Direction | null;\r\n}\r\n*/\r\nclass LogicGraphEdge {\r\n    constructor() {\r\n        this.text = null;\r\n        this.endNodeIndex = -1;\r\n    }\r\n}\r\nexports.LogicGraphEdge = LogicGraphEdge;\r\nclass LogicGraphNode {\r\n    constructor() {\r\n        this.text = null;\r\n        this.outputEdges = [];\r\n    }\r\n    addEdge(e) {\r\n        this.outputEdges.push(e);\r\n    }\r\n}\r\nexports.LogicGraphNode = LogicGraphNode;\r\nfunction Test(obj) {\r\n    console.log(obj);\r\n    console.log(\"test\");\r\n}\r\nexports.Test = Test;\r\nclass LogicGraph {\r\n    constructor() {\r\n        this.nodes = [];\r\n        this.edges = [];\r\n        this.graphOption = { relocateStyle: \"standard\", direction: \"down\" };\r\n    }\r\n    construct(iten) {\r\n    }\r\n    addNode() {\r\n        const node = new LogicGraphNode();\r\n        this.nodes.push(node);\r\n        return node;\r\n    }\r\n    createEdge() {\r\n        const edge = new LogicGraphEdge();\r\n        this.edges.push(edge);\r\n        return edge;\r\n    }\r\n    getIndex(node) {\r\n        return this.nodes.indexOf(node);\r\n    }\r\n}\r\nexports.LogicGraph = LogicGraph;\r\n/**\r\n * 木構造を表現するクラスです。\r\n */\r\nclass LogicTree {\r\n    constructor(option = {}) {\r\n        //public vertexText: string | null = null\r\n        //public parentEdgeText: string | null = null\r\n        //public vertexClass: string | null = null\r\n        //public parentEdgeClass: string | null = null\r\n        this.children = [];\r\n        this.vertexOption = {};\r\n        this.edgeOption = { class: { pathTextAlignment: enums_1.PathTextAlighnment.regularInterval } };\r\n        this.graphOption = { relocateStyle: \"standard\", direction: \"down\" };\r\n        this.drawingFunction = null;\r\n        this.item = null;\r\n        this.objectType = \"LogicTree\";\r\n        if (option.item != undefined)\r\n            this.item = option.item;\r\n        if (option.vertexOption !== undefined)\r\n            this.vertexOption = option.vertexOption;\r\n        if (option.edgeOption !== undefined)\r\n            this.edgeOption = option.edgeOption;\r\n        //if(option.vertexText != undefined) this.vertexText = option.vertexText;\r\n        //if(option.parentEdgeText != undefined) this.parentEdgeText = option.parentEdgeText;\r\n        if (option.children != undefined)\r\n            this.children = option.children;\r\n    }\r\n    buildFromObject(item) {\r\n        this.vertexOption = item[\"vertexOption\"];\r\n        this.edgeOption = item[\"edgeOption\"];\r\n        this.graphOption = item[\"graphOption\"];\r\n        const children = item[\"children\"];\r\n        //this.children = new Array(0);\r\n        this.children = children.map((v) => {\r\n            if (v == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                const w = new LogicTree();\r\n                w.buildFromObject(v);\r\n                return w;\r\n            }\r\n        });\r\n    }\r\n    getOrderedNodes(order = enums_1.VertexOrder.Preorder) {\r\n        const r = [];\r\n        const edges = this.children;\r\n        if (order == enums_1.VertexOrder.Preorder) {\r\n            r.push(this);\r\n            edges.forEach((v) => {\r\n                if (v != null) {\r\n                    v.getOrderedNodes(order).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else if (order == enums_1.VertexOrder.Postorder) {\r\n            edges.forEach((v) => {\r\n                if (v != null) {\r\n                    v.getOrderedNodes(order).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                }\r\n            });\r\n            r.push(this);\r\n        }\r\n        return r;\r\n    }\r\n    get textContent() {\r\n        if (typeof (this.edgeOption.text) == \"string\") {\r\n            return this.edgeOption.text;\r\n        }\r\n        else if (this.edgeOption.text === undefined) {\r\n            return \"\";\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    set textContent(value) {\r\n        this.edgeOption.text = value;\r\n    }\r\n}\r\nexports.LogicTree = LogicTree;\r\n/**\r\n * 二分木を表現するクラスです。\r\n */\r\nclass BinaryLogicTree extends LogicTree {\r\n    constructor(item = null, left = null, right = null, vertexOption, edgeOption) {\r\n        super({ item: item == null ? undefined : item, children: [left, right], vertexOption: vertexOption, edgeOption: edgeOption });\r\n        this.item = item;\r\n    }\r\n    get left() {\r\n        const left = this.children[0];\r\n        if (left == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return left;\r\n        }\r\n    }\r\n    set left(value) {\r\n        this.children[0] = value;\r\n    }\r\n    get right() {\r\n        const right = this.children[1];\r\n        if (right == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return right;\r\n        }\r\n    }\r\n    set right(value) {\r\n        this.children[1] = value;\r\n    }\r\n}\r\nexports.BinaryLogicTree = BinaryLogicTree;\r\n//# sourceMappingURL=logic_tree.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/logics/logic_tree.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"g_path_textbox.ts\"/>\r\n//namespace GraphTableSVG {\r\nconst g_path_textbox_1 = __webpack_require__(/*! ./g_path_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_path_textbox.js\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GArrowCallout extends g_path_textbox_1.GPathTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (option.height == undefined)\r\n            this.height = 100;\r\n        if (option.width == undefined)\r\n            this.width = 100;\r\n        this.arrowNeckWidth = option.arrowNeckWidth == undefined ? 10 : option.arrowNeckWidth;\r\n        this.arrowNeckHeight = option.arrowNeckHeight == undefined ? 10 : option.arrowNeckHeight;\r\n        this.arrowHeadWidth = option.arrowHeadWidth == undefined ? 20 : option.arrowHeadWidth;\r\n        this.arrowHeadHeight = option.arrowHeadHeight == undefined ? 20 : option.arrowHeadHeight;\r\n        this.svgGroup.setAttribute(\"data-direction\", option.direction == undefined ? \"down\" : option.direction);\r\n        this.updateAttributes.push(\"data-direction\");\r\n        if (this.type == enums_1.ShapeObjectType.ArrowCallout)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        output.arrowNeckWidth = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"arrow-neck-width\", 10);\r\n        output.arrowNeckHeight = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"arrow-neck-height\", 10);\r\n        output.arrowHeadWidth = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"arrow-head-width\", 20);\r\n        output.arrowHeadHeight = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"arrow-head-height\", 20);\r\n        const p = ElementExtension.gtGetAttribute(e, \"direction\", \"\");\r\n        output.direction = enums_1.Direction.toDirection(p);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"arrow-neck-width\");\r\n            e.removeAttribute(\"arrow-neck-height\");\r\n            e.removeAttribute(\"arrow-head-width\");\r\n            e.removeAttribute(\"arrow-head-height\");\r\n            e.removeAttribute(\"direction\");\r\n        }\r\n        return output;\r\n    }\r\n    /*\r\n    static openCustomElement(e: SVGElement): ShapeArrowCallout {\r\n        const parent = e.parentElement;\r\n        if (parent instanceof SVGSVGElement) {\r\n            const option = ShapeArrowCallout.constructAttributes(e, true);\r\n            const attrs = e.gtGetAttributes();\r\n            const r = new ShapeArrowCallout(parent, option);\r\n            e.remove();\r\n            attrs.forEach((v) => r.svgGroup.setAttribute(v.name, v.value));\r\n            return r;\r\n        } else {\r\n            throw Error(\"error!\");\r\n        }\r\n    }\r\n    */\r\n    get type() {\r\n        return enums_1.ShapeObjectType.ArrowCallout;\r\n    }\r\n    get arrowNeckWidth() {\r\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-width\", 0);\r\n    }\r\n    set arrowNeckWidth(value) {\r\n        if (this.arrowNeckWidth != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-neck-width\", value.toString());\r\n    }\r\n    get arrowNeckHeight() {\r\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-neck-height\", 0);\r\n    }\r\n    set arrowNeckHeight(value) {\r\n        if (this.arrowNeckHeight != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-neck-height\", value.toString());\r\n    }\r\n    get arrowHeadWidth() {\r\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-width\", 0);\r\n    }\r\n    set arrowHeadWidth(value) {\r\n        if (this.arrowHeadWidth != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-head-width\", value.toString());\r\n    }\r\n    get arrowHeadHeight() {\r\n        return ElementExtension.gtGetAttributeNumberWithoutNull(this.svgGroup, \"data-arrow-head-height\", 0);\r\n    }\r\n    set arrowHeadHeight(value) {\r\n        if (this.arrowHeadHeight != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-head-height\", value.toString());\r\n    }\r\n    get direction() {\r\n        const r = this.svgGroup.getAttribute(\"data-direction\");\r\n        return enums_1.Direction.toDirection(r);\r\n    }\r\n    set direction(value) {\r\n        if (this.direction != value) {\r\n            this.svgGroup.setAttribute(\"data-direction\", value.toString());\r\n        }\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        if (this.isAutoSizeShapeToFitText == enums_1.AutoSizeShapeToFitText.Auto) {\r\n            const textRect = SVGTextBox.getSize(this.svgText);\r\n            //const b = this.svgText.getBBox();\r\n            rect.width = textRect.width;\r\n            rect.height = textRect.height;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        else {\r\n            rect.width = this.boxWidth - this.marginPaddingLeft;\r\n            rect.height = this.boxHeight - this.marginPaddingTop;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        if (this.direction == \"up\")\r\n            rect.y += this.arrowNeckHeight + this.arrowHeadHeight;\r\n        if (this.direction == \"left\")\r\n            rect.x += this.arrowNeckHeight + this.arrowHeadHeight;\r\n        return rect;\r\n    }\r\n    /**\r\n     * 矢印部分を除いた図形の高さを表します。\r\n     */\r\n    get boxHeight() {\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            return this.height - this.arrowNeckHeight - this.arrowHeadWidth;\r\n        }\r\n        else {\r\n            return this.height;\r\n        }\r\n    }\r\n    get boxWidth() {\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            return this.width;\r\n        }\r\n        else {\r\n            return this.width - this.arrowNeckHeight - this.arrowHeadWidth;\r\n        }\r\n    }\r\n    updateToFitText() {\r\n        const textRect = SVGTextBox.getSize(this.svgText);\r\n        //const box = this.svgText.getBBox();\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\r\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\r\n        }\r\n        else {\r\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\r\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\r\n        }\r\n    }\r\n    update() {\r\n        super.update();\r\n        if (this.direction == \"up\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1 + this.arrowHeadHeight + this.arrowNeckHeight;\r\n            const bx2 = x2;\r\n            const by2 = y2;\r\n            let nx1 = -(this.arrowNeckWidth / 2);\r\n            let nx2 = (this.arrowNeckWidth / 2);\r\n            let ny = by1 - this.arrowNeckHeight;\r\n            let cx = 0;\r\n            let hx1 = -(this.arrowHeadWidth / 2);\r\n            let hx2 = (this.arrowHeadWidth / 2);\r\n            let hy = y1;\r\n            const mes = `H ${nx1} V ${ny} H ${hx1} L ${cx} ${hy} L ${hx2} ${ny} H ${nx2} V ${by1}`;\r\n            const top = `M ${bx1} ${by1} ${mes} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else if (this.direction == \"left\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1 + this.arrowHeadHeight + this.arrowNeckHeight;\r\n            const by1 = y1;\r\n            const bx2 = x2;\r\n            const by2 = y2;\r\n            let ny1 = 0 + (this.arrowNeckWidth / 2);\r\n            let ny2 = 0 - (this.arrowNeckWidth / 2);\r\n            let nx = bx1 - this.arrowNeckHeight;\r\n            let cy = 0;\r\n            let hy1 = 0 + (this.arrowHeadWidth / 2);\r\n            let hy2 = 0 - (this.arrowHeadWidth / 2);\r\n            let hx = x1;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx1} V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else if (this.direction == \"right\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1;\r\n            const bx2 = x2 - this.arrowHeadHeight - this.arrowNeckHeight;\r\n            const by2 = y2;\r\n            let ny1 = 0 - (this.arrowNeckWidth / 2);\r\n            let ny2 = 0 + (this.arrowNeckWidth / 2);\r\n            let nx = bx2 + this.arrowNeckHeight;\r\n            let cy = 0;\r\n            let hy1 = 0 - (this.arrowHeadWidth / 2);\r\n            let hy2 = 0 + (this.arrowHeadWidth / 2);\r\n            let hx = x2;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx2} V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1;\r\n            const bx2 = x2;\r\n            const by2 = y2 - this.arrowHeadHeight - this.arrowNeckHeight;\r\n            //const by = boxHeight + dy;\r\n            let nx1 = -(this.arrowNeckWidth / 2);\r\n            let nx2 = (this.arrowNeckWidth / 2);\r\n            let ny = by2 + this.arrowNeckHeight;\r\n            let cx = 0;\r\n            let hx1 = -(this.arrowHeadWidth / 2);\r\n            let hx2 = (this.arrowHeadWidth / 2);\r\n            let hy = y2;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${nx2} V ${ny} H ${hx2} L ${cx} ${hy} L ${hx1} ${ny} H ${nx1} V ${by2} H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n    }\r\n    get shape() {\r\n        switch (this.direction) {\r\n            case \"up\": return \"msoShapeUpArrowCallout\";\r\n            case \"left\": return \"msoShapeLeftArrowCallout\";\r\n            case \"right\": return \"msoShapeRightArrowCallout\";\r\n            case \"down\": return \"msoShapeDownArrowCallout\";\r\n        }\r\n        return \"msoShapeDownArrowCallout\";\r\n    }\r\n    /**\r\n     * VBAコードでのこの図形を表すShape図形のVBAAdjustmentsプロパティを表します。\r\n     * 第一要素は矢印の首の幅（）\r\n     * 第二要素は矢印の頭の幅\r\n     * @returns VBAAdjustments値の配列。\r\n     */\r\n    get VBAAdjustments() {\r\n        if (this.direction == \"up\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxHeightRatio = this.boxHeight / this.height;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\r\n        }\r\n        else if (this.direction == \"right\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxWidthRatio = this.boxWidth / this.width;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\r\n        }\r\n        else if (this.direction == \"left\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxWidthRatio = this.boxWidth / this.width;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\r\n        }\r\n        else {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxHeightRatio = this.boxHeight / this.height;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\r\n        }\r\n    }\r\n    /**\r\n             * 接続部分の座標を返します。\r\n             * @param type\r\n             * @param x\r\n             * @param y\r\n             */\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.x, this.y - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.x + wr, this.y];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.x, this.y + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.x - wr, this.y];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y + hr);\r\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GArrowCallout = GArrowCallout;\r\n//}\r\n//# sourceMappingURL=g_arrow_callout.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_callout.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_callout.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"g_path_textbox.ts\"/>\r\n//namespace GraphTableSVG {\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst g_path_textbox_1 = __webpack_require__(/*! ./g_path_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_path_textbox.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GCallout extends g_path_textbox_1.GPathTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        const defaultSX = this.fixedX == null ? this.cx - 100 : this.fixedX - 50;\r\n        const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\r\n        this.speakerX = option.speakerX == undefined ? defaultSX : option.speakerX;\r\n        this.speakerY = option.speakerY == undefined ? defaultSY : option.speakerY;\r\n        if (this.type == enums_1.ShapeObjectType.Callout)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        if (e.hasAttribute(\"speaker-x\"))\r\n            output.speakerX = ElementExtension.gtGetAttributeNumber(e, \"speaker-x\", 200);\r\n        if (e.hasAttribute(\"speaker-y\"))\r\n            output.speakerY = ElementExtension.gtGetAttributeNumber(e, \"speaker-y\", 200);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"speaker-x\");\r\n            e.removeAttribute(\"speaker-y\");\r\n        }\r\n        return output;\r\n    }\r\n    /*\r\n    static openCustomElement(e: SVGElement): GCallout {\r\n        const parent = e.parentElement;\r\n        if (parent instanceof SVGSVGElement) {\r\n            const option = GCallout.constructAttributes(e,true);\r\n            const attrs = e.gtGetAttributes();\r\n\r\n            const r = new GCallout(parent, option);\r\n            attrs.forEach((v)=>r.svgGroup.setAttribute(v.name, v.value));\r\n            e.remove();\r\n            return r;\r\n        } else {\r\n            throw Error(\"error!\");\r\n        }\r\n    }\r\n    */\r\n    get type() {\r\n        return \"g-callout\";\r\n    }\r\n    update() {\r\n        super.update();\r\n        const x1 = -(this.width / 2);\r\n        const y1 = -(this.height / 2);\r\n        const x2 = (this.width / 2);\r\n        const y2 = (this.height / 2);\r\n        const speakerDiffX = this.speakerX - this.cx;\r\n        const speakerDiffY = this.speakerY - this.cy;\r\n        let px1 = 0, px2 = 0, py1 = 0, py2 = 0;\r\n        let mes = \"\";\r\n        switch (this.speakerPosition) {\r\n            case \"upleft\":\r\n                px1 = (x1 / 3) * 2;\r\n                px2 = (x1 / 3) * 1;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"upright\":\r\n                px1 = (x2 / 3) * 1;\r\n                px2 = (x2 / 3) * 2;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"rightup\":\r\n                py1 = (y1 / 3) * 2;\r\n                py2 = (y1 / 3) * 1;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"rightdown\":\r\n                py1 = (y2 / 3) * 1;\r\n                py2 = (y2 / 3) * 2;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"leftup\":\r\n                py1 = (y1 / 3) * 1;\r\n                py2 = (y1 / 3) * 2;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\r\n                break;\r\n            case \"leftdown\":\r\n                py1 = (y2 / 3) * 2;\r\n                py2 = (y2 / 3) * 1;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\r\n                break;\r\n            case \"downleft\":\r\n                px1 = (x1 / 3) * 1;\r\n                px2 = (x1 / 3) * 2;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"downright\":\r\n                px1 = (x2 / 3) * 2;\r\n                px2 = (x2 / 3) * 1;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\r\n                break;\r\n            default:\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n        }\r\n        //this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x1 + this.width} V ${y1 + this.height} H ${x1} V ${y1} z`);\r\n    }\r\n    get speakerX() {\r\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-x\", 0);\r\n    }\r\n    set speakerX(value) {\r\n        if (this.speakerX != value)\r\n            this.svgGroup.setAttribute(\"data-speaker-x\", value.toString());\r\n    }\r\n    get speakerY() {\r\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-speaker-y\", 0);\r\n    }\r\n    set speakerY(value) {\r\n        if (this.speakerY != value)\r\n            this.svgGroup.setAttribute(\"data-speaker-y\", value.toString());\r\n    }\r\n    get speakerPosition() {\r\n        const speakerDiffX = this.speakerX - this.cx;\r\n        const speakerDiffY = this.speakerY - this.cy;\r\n        const x1 = -(this.width / 2);\r\n        const y1 = -(this.height / 2);\r\n        const x2 = (this.width / 2);\r\n        const y2 = (this.height / 2);\r\n        if (x1 <= speakerDiffX && speakerDiffX <= x2 && y1 <= speakerDiffY && speakerDiffY <= y2) {\r\n            return \"inner\";\r\n        }\r\n        if (this.speakerX > this.cx) {\r\n            if (this.speakerY > this.cy) {\r\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"rightdown\";\r\n                }\r\n                else {\r\n                    return \"downright\";\r\n                }\r\n            }\r\n            else {\r\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"upright\";\r\n                }\r\n                else {\r\n                    return \"rightup\";\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this.speakerY > this.cy) {\r\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"leftdown\";\r\n                }\r\n                else {\r\n                    return \"downleft\";\r\n                }\r\n            }\r\n            else {\r\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"upleft\";\r\n                }\r\n                else {\r\n                    return \"leftup\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get shape() {\r\n        return \"msoShapeRectangularCallout\";\r\n    }\r\n    get VBAAdjustments() {\r\n        const y1 = this.speakerY - this.cy;\r\n        const py = y1 / this.height;\r\n        const x1 = this.speakerX - this.cx;\r\n        const px = x1 / this.width;\r\n        return [px, py];\r\n    }\r\n}\r\nexports.GCallout = GCallout;\r\n//}\r\n//# sourceMappingURL=g_callout.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_callout.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_circle.js":
/*!***************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_circle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst g_ellipse_1 = __webpack_require__(/*! ./g_ellipse */ \"./node_modules/graph-table-svg/dist/objects/g_ellipse.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GCircle extends g_ellipse_1.GAbstractEllipseCircle {\r\n    get svgCircle() {\r\n        return this._svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (this.type == enums_1.ShapeObjectType.Circle)\r\n            this.firstFunctionAfterInitialized();\r\n        //this.update();\r\n    }\r\n    initializeOption(option) {\r\n        const _option = Object.assign({}, option);\r\n        if (this.svgSurface != null && this.svgSurface.className != null) {\r\n            const width = ElementExtension.getPropertyStyleNumberValue(this.svgSurface, StyleNames.defaultWidth, null);\r\n            const height = ElementExtension.getPropertyStyleNumberValue(this.svgSurface, StyleNames.defaultHeight, null);\r\n            if (width != null)\r\n                _option.width = width;\r\n            if (height != null)\r\n                _option.height = height;\r\n        }\r\n        if (_option.width === undefined && _option.height === undefined) {\r\n            _option.width = 25;\r\n        }\r\n        //if (_option.width === undefined) _option.width = 25;\r\n        //if (_option.height === undefined) _option.height = 25;\r\n        if (_option.cx === undefined)\r\n            _option.cx = 0;\r\n        if (_option.cy === undefined)\r\n            _option.cy = 0;\r\n        if (_option.surfaceClass === undefined)\r\n            _option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\r\n        return _option;\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\r\n        this._svgSurface = GCircle.createCircle(this.svgGroup, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgCircle, this.svgText);\r\n    }\r\n    static createCircle(parent, className, style) {\r\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        parent.appendChild(circle);\r\n        if (style !== undefined) {\r\n            if (typeof (style) == \"string\") {\r\n                circle.setAttribute(\"style\", style);\r\n            }\r\n            else {\r\n                circle.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\r\n            }\r\n        }\r\n        //if(style !== undefined) circle.setAttribute(\"style\", style);\r\n        circle.r.baseVal.value = AttributeNames.defaultCircleRadius;\r\n        //circle.setAttribute(\"class\", className);\r\n        if (typeof (className) == \"string\") {\r\n            circle.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            circle.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\r\n        }\r\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\r\n        if (radius != null) {\r\n            circle.r.baseVal.value = radius;\r\n        }\r\n        circle.cx.baseVal.value = 0;\r\n        circle.cy.baseVal.value = 0;\r\n        return circle;\r\n    }\r\n    get rx() {\r\n        return this.svgCircle.r.baseVal.value;\r\n    }\r\n    get ry() {\r\n        return this.svgCircle.r.baseVal.value;\r\n    }\r\n    set width(value) {\r\n        const _rx = value / 2;\r\n        if (this.width != value)\r\n            this.svgCircle.setAttribute(\"r\", _rx.toString());\r\n    }\r\n    set height(value) {\r\n        const _ry = value / 2;\r\n        if (this.height != value)\r\n            this.svgCircle.setAttribute(\"r\", _ry.toString());\r\n    }\r\n    get width() {\r\n        return this.svgCircle.r.baseVal.value * 2;\r\n    }\r\n    get height() {\r\n        return this.svgCircle.r.baseVal.value * 2;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Circle;\r\n    }\r\n    get shape() {\r\n        return \"msoShapeOval\";\r\n    }\r\n}\r\nexports.GCircle = GCircle;\r\n//# sourceMappingURL=g_circle.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_circle.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_edge.js":
/*!*************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_edge.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//namespace GraphTableSVG {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\n//import {GEdgeAttributes, GObjectAttributes} from \"../options/attributes_option\"\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./node_modules/graph-table-svg/dist/common/vba_functions.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./node_modules/graph-table-svg/dist/html/enum_extension.js\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst Extensions = __webpack_require__(/*! ../interfaces/extensions */ \"./node_modules/graph-table-svg/dist/interfaces/extensions.js\");\r\n/**\r\n * 辺をSVGで表現するためのクラスです。\r\n */\r\nclass GEdge extends g_textbox_1.GTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this.connectPositionChangedFunc = () => {\r\n            this.update();\r\n        };\r\n        this.VBAConnectorNumber = 1;\r\n        this._isSpecialTextBox = true;\r\n        this.updateAttributes.push(AttributeNames.beginNodeName);\r\n        this.updateAttributes.push(AttributeNames.endNodeName);\r\n        console.log(option);\r\n        const pathClass = this.svgSurface.getAttribute(\"class\");\r\n        if (pathClass == DefaultClassNames.defaultSurfaceClass) {\r\n            this.svgSurface.setAttribute(\"class\", DefaultClassNames.defaultPathSurfaceClass);\r\n        }\r\n        //this._svgGroup = SVG.createGroup(svgbox);\r\n        const _option = this.initializeOption(option);\r\n        this.svgText.textContent = \"\";\r\n        //const textClass = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultTextClass);\r\n        if (option.textClass === undefined)\r\n            option.textClass = DefaultClassNames.defaultTextClass;\r\n        let textClass;\r\n        if (typeof option.textClass == \"string\") {\r\n            textClass = option.textClass;\r\n        }\r\n        else if (typeof option.textClass == \"object\") {\r\n            textClass = CSS.getOrCreateClassName(option.textClass);\r\n        }\r\n        /*\r\n        if(typeof(className) == \"string\"){\r\n        }else{\r\n            const newClassName = CSS.getOrAddRule(className);\r\n            path.setAttribute(\"class\", newClassName);\r\n        }\r\n        */\r\n        this._svgTextPath = SVG.createTextPath2(textClass);\r\n        this.svgPath.id = `path-${this.objectID}`;\r\n        this.svgText.appendChild(this._svgTextPath);\r\n        this._svgTextPath.href.baseVal = `#${this.svgPath.id}`;\r\n        if (typeof _option.text == \"string\") {\r\n            Extensions.setTextContent(this.svgTextPath, _option.text);\r\n        }\r\n        else if (Array.isArray(_option.text)) {\r\n        }\r\n        else {\r\n        }\r\n        const edgeColor = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke\");\r\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\r\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\r\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\r\n        if (_option.startMarker !== undefined)\r\n            this.markerStart = GEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\r\n        if (_option.endMarker !== undefined)\r\n            this.markerEnd = GEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\r\n        this.pathPoints = [[_option.x1, _option.y1], [_option.x2, _option.y2]];\r\n        if (typeof _option.beginVertex == \"object\") {\r\n            if (_option.beginVertex instanceof g_vertex_1.GVertex)\r\n                this.beginVertex = _option.beginVertex;\r\n        }\r\n        if (typeof _option.endVertex == \"object\") {\r\n            if (_option.endVertex instanceof g_vertex_1.GVertex)\r\n                this.endVertex = _option.endVertex;\r\n        }\r\n        if (_option.x3 !== undefined && _option.y3 !== undefined) {\r\n            this.controlPoint = [[_option.x3, _option.y3]];\r\n        }\r\n        //if (_option.beginConnectorType !== undefined) this.beginConnectorType = _option.beginConnectorType;\r\n        //if (_option.endConnectorType !== undefined) this.endConnectorType = _option.endConnectorType;\r\n        //if (_option.pathTextAlignment !== undefined) this.pathTextAlignment = _option.pathTextAlignment;\r\n        //this.pathTextAlignment = PathTextAlighnment.begin;\r\n        //this.update();\r\n        //if (this.svgGroup.getPropertyStyleValue(AttributeNames.Style.PathTextAlignment) == null) {\r\n        //    this.pathTextAlignment = PathTextAlighnment.center;\r\n        // }\r\n        //this.update();\r\n        if (this.type == enums_1.ShapeObjectType.Edge)\r\n            this.firstFunctionAfterInitialized();\r\n        //this.setAppropriateText();\r\n    }\r\n    /*\r\n    protected createObjects(svgbox: SVGElement, option: GObjectAttributes = {}): void {\r\n\r\n    }\r\n    */\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        const _output = g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        _output.x1 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"x1\", 0);\r\n        _output.x2 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"x2\", 300);\r\n        _output.y1 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"y1\", 0);\r\n        _output.y2 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"y2\", 300);\r\n        if (e.hasAttribute(\"x3\")) {\r\n            _output.x3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"x3\", 0);\r\n        }\r\n        if (e.hasAttribute(\"y3\")) {\r\n            _output.y3 = ElementExtension.gtGetAttributeNumberWithoutNull(e, \"y3\", 0);\r\n        }\r\n        _output.beginVertex = ElementExtension.gtGetAttributeStringWithUndefined(e, \"begin-vertex\");\r\n        _output.endVertex = ElementExtension.gtGetAttributeStringWithUndefined(e, \"end-vertex\");\r\n        const bct = ElementExtension.getPropertyStyleValue(e, StyleNames.beginConnectorType);\r\n        if (bct != null && typeof (_output.style) == \"object\") {\r\n            _output.style.beginConnectorType = enums_1.ConnectorPosition.ToConnectorPosition(bct);\r\n        }\r\n        const ect = ElementExtension.getPropertyStyleValue(e, StyleNames.endConnectorType);\r\n        if (ect != null && typeof (_output.style) == \"object\") {\r\n            _output.style.endConnectorType = enums_1.ConnectorPosition.ToConnectorPosition(ect);\r\n        }\r\n        //if (ect != null) _output.endConnectorType = ConnectorPosition.ToConnectorPosition(ect);\r\n        _output.startMarker = ElementExtension.gtGetStyleBooleanWithUndefined(e, StyleNames.markerStart);\r\n        _output.endMarker = ElementExtension.gtGetAttributeBooleanWithUndefined(e, StyleNames.markerEnd);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"x1\");\r\n            e.removeAttribute(\"x2\");\r\n            e.removeAttribute(\"x3\");\r\n            e.removeAttribute(\"y1\");\r\n            e.removeAttribute(\"y2\");\r\n            e.removeAttribute(\"y3\");\r\n            //e.removeAttribute(\"start-marker\");\r\n            //e.removeAttribute(\"end-marker\");\r\n            e.removeAttribute(\"begin-vertex\");\r\n            e.removeAttribute(\"end-vertex\");\r\n            /*\r\n            e.removeAttribute(\"begin-connector\");\r\n            e.removeAttribute(\"end-connector\");\r\n            */\r\n        }\r\n        return _output;\r\n    }\r\n    initializeOption(option) {\r\n        const _option = super.initializeOption(option);\r\n        const markerStartName = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.markerStart);\r\n        const markerEndName = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.markerEnd);\r\n        if (typeof _option.startMarker === \"undefined\" && markerStartName != null)\r\n            _option.startMarker = markerStartName == \"true\";\r\n        if (typeof _option.endMarker === \"undefined\" && markerEndName != null)\r\n            _option.endMarker = markerEndName == \"true\";\r\n        if (typeof _option.x1 === \"undefined\")\r\n            _option.x1 = 0;\r\n        if (typeof _option.y1 === \"undefined\")\r\n            _option.y1 = 0;\r\n        if (typeof _option.x2 === \"undefined\")\r\n            _option.x2 = 300;\r\n        if (typeof _option.y2 === \"undefined\")\r\n            _option.y2 = 300;\r\n        if (typeof _option.beginVertex === \"string\") {\r\n            const obj = g_textbox_1.GTextBox.getObjectFromID(_option.beginVertex);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                _option.beginVertex = obj;\r\n            }\r\n        }\r\n        if (typeof _option.endVertex === \"string\") {\r\n            const obj = g_textbox_1.GTextBox.getObjectFromID(_option.endVertex);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                _option.endVertex = obj;\r\n            }\r\n        }\r\n        //const styleBeginConnectorType = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.beginConnectorType);\r\n        //const styleEndConnectorType = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.endConnectorType);\r\n        //if (_option.beginConnectorType === undefined && styleBeginConnectorType === null) _option.beginConnectorType = ConnectorPosition.Auto;\r\n        //if (_option.endConnectorType === undefined && styleEndConnectorType === null) _option.endConnectorType = ConnectorPosition.Auto;\r\n        //if (_option.pathTextAlignment === undefined) _option.pathTextAlignment = PathTextAlighnment.center;\r\n        return _option;\r\n    }\r\n    isDrawnText() {\r\n        const text = this.svgTextPath.textContent;\r\n        if (text == null || text.length == 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            const len = this.svgTextPath.getComputedTextLength();\r\n            return len != 0;\r\n        }\r\n    }\r\n    static getConnectedVertexFromDic(edge, isBegin) {\r\n        const dic = isBegin ? GEdge.connectedBeginVertexDic : GEdge.connectedEndVertexDic;\r\n        if (edge.objectID in dic) {\r\n            const id = dic[edge.objectID];\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(id);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                return obj;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    static setConnectedVertexFromDic(edge, isBegin) {\r\n        const dic = isBegin ? GEdge.connectedBeginVertexDic : GEdge.connectedEndVertexDic;\r\n        const id = isBegin ? edge.beginVertexID : edge.endVertexID;\r\n        if (id == null) {\r\n            if (edge.objectID in dic) {\r\n                delete dic[edge.objectID];\r\n            }\r\n        }\r\n        else {\r\n            dic[edge.objectID] = id;\r\n        }\r\n    }\r\n    /*\r\n    protected setClassNameOfSVGGroup() {\r\n        const parent = this.svgGroup.parentElement;\r\n        if (parent instanceof SVGElement) {\r\n            const className = AttributeNames.StyleValue.defaultEdgeClass;\r\n            if (className != null) {\r\n                this.svgGroup.setAttribute(\"class\", className);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    get degree() {\r\n        const rad = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);\r\n        const degree = (180 * rad) / Math.PI;\r\n        return degree;\r\n    }\r\n    get defaultClassName() {\r\n        return DefaultClassNames.defaultEdgeClass;\r\n    }\r\n    //private _svgPath: SVGPathElement | null;\r\n    get svgPath() {\r\n        return this.svgSurface;\r\n    }\r\n    get svgTextPath() {\r\n        return this._svgTextPath;\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = DefaultClassNames.defaultEdgePathClass;\r\n        //if (_className != null) option.surfaceClass = _className;\r\n        this._svgSurface = GEdge.createPath(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\r\n    }\r\n    /**\r\n         * SVGPathElementを生成します。\r\n         * @param parent 生成したSVGPathElementを子に追加する要素\r\n         * @param x 開始位置のX座標\r\n         * @param y 開始位置のY座標\r\n         * @param x2 終了位置のX座標\r\n         * @param y2 終了位置のY座標\r\n         * @param className SVGPathElementのクラス属性名\r\n         * @returns 生成されたSVGPathElement\r\n         */\r\n    static createPath(parent, x, y, x2, y2, className, style) {\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n        parent.appendChild(path);\r\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\r\n        if (style !== undefined) {\r\n            if (typeof (style) == \"string\") {\r\n                path.setAttribute(\"style\", style);\r\n            }\r\n            else {\r\n                path.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\r\n            }\r\n        }\r\n        if (typeof (className) == \"string\") {\r\n            path.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            path.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\r\n        }\r\n        /*\r\n    if (className !== undefined) {\r\n    } else {\r\n        if (path.style.stroke == null || path.style.stroke == \"\") path.style.stroke = \"black\";\r\n        if (path.style.fill == null || path.style.fill == \"\") path.style.fill = \"none\";\r\n        if (path.style.strokeWidth == null || path.style.strokeWidth == \"\") path.style.strokeWidth = \"1pt\";\r\n    }\r\n    */\r\n        return path;\r\n    }\r\n    get type() {\r\n        return \"g-edge\";\r\n    }\r\n    /**\r\n     * 辺の制御点を返します。\r\n     */\r\n    get controlPoint() {\r\n        const r = this.pathPoints;\r\n        r.shift();\r\n        r.pop();\r\n        return r;\r\n    }\r\n    set controlPoint(value) {\r\n        const fst = [this.x1, this.y1];\r\n        const lst = [this.x2, this.y2];\r\n        value.unshift(fst);\r\n        value.push(lst);\r\n        this.pathPoints = value;\r\n    }\r\n    /**\r\n    開始接点の接続位置を返します。\r\n    */\r\n    get beginConnectorType() {\r\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.beginConnectorType);\r\n        return enums_1.ConnectorPosition.ToConnectorPosition(p);\r\n    }\r\n    /**\r\n    開始接点の接続位置を設定します。\r\n    */\r\n    set beginConnectorType(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.beginConnectorType, value);\r\n        //this.svgGroup.setAttribute(Edge.beginConnectorTypeName, ToStrFromConnectorPosition(value));\r\n    }\r\n    /**\r\n    終了接点の接続位置を返します。\r\n    */\r\n    get endConnectorType() {\r\n        const p = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.endConnectorType);\r\n        return enums_1.ConnectorPosition.ToConnectorPosition(p);\r\n    }\r\n    /**\r\n    終了接点の接続位置を設定します。\r\n    */\r\n    set endConnectorType(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.endConnectorType, value);\r\n    }\r\n    get beginVertexID() {\r\n        return this.svgGroup.getAttribute(AttributeNames.beginNodeName);\r\n    }\r\n    set beginVertexID(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(AttributeNames.beginNodeName);\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(AttributeNames.beginNodeName, v);\r\n        }\r\n    }\r\n    get endVertexID() {\r\n        return this.svgGroup.getAttribute(AttributeNames.endNodeName);\r\n    }\r\n    set endVertexID(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(AttributeNames.endNodeName);\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(AttributeNames.endNodeName, v);\r\n        }\r\n    }\r\n    get isAppropriatelyReverseMode() {\r\n        const p = this.svgGroup.getAttribute(AttributeNames.isAppropriatelyReverseTextMode);\r\n        if (p == null) {\r\n            return false;\r\n        }\r\n        else {\r\n            return p == \"true\";\r\n        }\r\n        //return this.svgGroup.getAttribute(AttributeNames.appropriateEdgeText);\r\n    }\r\n    set isAppropriatelyReverseMode(v) {\r\n        this.svgGroup.setAttribute(AttributeNames.isAppropriatelyReverseTextMode, v.toString());\r\n    }\r\n    get side() {\r\n        return this.svgTextPath.getAttribute(\"side\");\r\n    }\r\n    set side(v) {\r\n        if (v == null) {\r\n            this.svgTextPath.removeAttribute(\"side\");\r\n        }\r\n        else {\r\n            this.svgTextPath.setAttribute(\"side\", v);\r\n        }\r\n    }\r\n    /*\r\n    public setAppropriateText(){\r\n        const text = this.svgTextPath.textContent;\r\n        if(text != null){\r\n            this.isAppropriateText = text;\r\n        }\r\n    }\r\n    */\r\n    /**\r\n     * 開始位置の矢印オブジェクトを返します。\r\n     */\r\n    get markerStart() {\r\n        if (this.svgPath != null) {\r\n            var p = this.svgPath.getAttribute(\"marker-start\");\r\n            if (p != null) {\r\n                const str = p.substring(5, p.length - 1);\r\n                const ele = document.getElementById(str);\r\n                return ele;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * 開始位置の矢印オブジェクトを設定します。\r\n     * @param value 代入するSVGMarkerElementもしくはNull\r\n     */\r\n    set markerStart(value) {\r\n        if (this.svgPath != null) {\r\n            if (value == null) {\r\n                this.svgPath.removeAttribute(\"marker-start\");\r\n            }\r\n            else {\r\n                this.svgGroup.appendChild(value);\r\n                this.svgPath.setAttribute(\"marker-start\", `url(#${value.id})`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 終了位置の矢印オブジェクトを返します。\r\n     */\r\n    get markerEnd() {\r\n        if (this.svgPath != null) {\r\n            var p = this.svgPath.getAttribute(\"marker-end\");\r\n            if (p != null) {\r\n                const str = p.substring(5, p.length - 1);\r\n                const ele = document.getElementById(str);\r\n                return ele;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set markerEnd(value) {\r\n        if (this.svgPath != null) {\r\n            if (value == null) {\r\n                this.svgPath.removeAttribute(\"marker-end\");\r\n            }\r\n            else {\r\n                this.svgGroup.appendChild(value);\r\n                this.svgPath.setAttribute(\"marker-end\", `url(#${value.id})`);\r\n            }\r\n        }\r\n    }\r\n    removeVertexEvent(vertex) {\r\n        vertex.svgGroup.removeEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\r\n    }\r\n    addVertexEvent(vertex) {\r\n        vertex.svgGroup.addEventListener(AttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\r\n    }\r\n    /**\r\n    開始接点を返します。\r\n    */\r\n    get beginVertex() {\r\n        if (this.beginVertexID == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return g_textbox_1.GTextBox.getObjectFromObjectID(this.beginVertexID);\r\n        }\r\n    }\r\n    /**\r\n    開始接点を設定します。\r\n    */\r\n    set beginVertex(value) {\r\n        if (value == null) {\r\n            this.beginVertexID = null;\r\n        }\r\n        else {\r\n            this.beginVertexID = value.objectID;\r\n        }\r\n        this.update();\r\n    }\r\n    /**\r\n    終了接点を返します。\r\n    */\r\n    get endVertex() {\r\n        if (this.endVertexID == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return g_textbox_1.GTextBox.getObjectFromObjectID(this.endVertexID);\r\n        }\r\n    }\r\n    /**\r\n    終了接点を設定します。\r\n    */\r\n    set endVertex(value) {\r\n        if (value == null) {\r\n            this.endVertexID = null;\r\n        }\r\n        else {\r\n            this.endVertexID = value.objectID;\r\n        }\r\n        this.update();\r\n    }\r\n    /**\r\n     * この辺を廃棄します。廃棄した辺はグラフから取り除かれます。\r\n     */\r\n    dispose() {\r\n        this.beginVertex = null;\r\n        this.endVertex = null;\r\n    }\r\n    /**\r\n    この辺が廃棄されているときTrueを返します。\r\n    */\r\n    /*\r\n     get isDisposed(): boolean {\r\n         return this.graph == null;\r\n     }\r\n     */\r\n    /**\r\n    開始位置のX座標を返します。\r\n    */\r\n    get x1() {\r\n        return this.pathPoints[0][0];\r\n    }\r\n    set x1(value) {\r\n        const p = this.pathPoints;\r\n        p[0][0] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    /**\r\n    開始位置のY座標を返します。\r\n    */\r\n    get y1() {\r\n        return this.pathPoints[0][1];\r\n    }\r\n    set y1(value) {\r\n        const p = this.pathPoints;\r\n        p[0][1] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    /**\r\n    終了位置のX座標を返します。\r\n    */\r\n    get x2() {\r\n        const d = this.pathPoints;\r\n        return d[d.length - 1][0];\r\n    }\r\n    set x2(value) {\r\n        const p = this.pathPoints;\r\n        p[p.length - 1][0] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    /**\r\n    終了位置のY座標を返します。\r\n    */\r\n    get y2() {\r\n        const d = this.pathPoints;\r\n        return d[d.length - 1][1];\r\n    }\r\n    set y2(value) {\r\n        const p = this.pathPoints;\r\n        p[p.length - 1][1] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    /**\r\n     * svgPathのstyle:stroke-dasharrayを返します。\r\n     */\r\n    /*\r\n     public get strokeDasharray(): string | null{\r\n        if (this.svgPath != null) {\r\n            var s = this.svgPath.getPropertyStyleValue(\"stroke-dasharray\");\r\n            return s;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    public set strokeDasharray(value: string | null) {\r\n        if (this.svgPath != null) {\r\n            if (value != null) {\r\n                this.svgPath.setPropertyStyleValue(\"stroke-dasharray\", value);\r\n            } else {\r\n                this.svgPath.removeAttribute(\"stroke-dasharray\");\r\n            }\r\n        }\r\n    }\r\n    */\r\n    /**\r\n     * svgPathのstyle:strokeを返します。\r\n     */\r\n    get lineColor() {\r\n        if (this.svgPath != null) {\r\n            return ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"black\");\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    removeTextLengthAttribute() {\r\n        if (this.svgText.hasAttribute(\"textLength\"))\r\n            this.svgText.removeAttribute(\"textLength\");\r\n        if (this.svgTextPath.hasAttribute(\"textLength\"))\r\n            this.svgTextPath.removeAttribute(\"textLength\");\r\n        if (this.svgText.hasAttribute(\"letter-spacing\"))\r\n            this.svgText.removeAttribute(\"letter-spacing\");\r\n    }\r\n    setRegularInterval(value) {\r\n        this.removeTextLengthAttribute();\r\n        const textRect = SVGTextBox.getSize(this.svgText);\r\n        //const box = this.svgText.getBBox();\r\n        const diff = value - textRect.width;\r\n        const number = this.svgText.textContent != null ? this.svgText.textContent.length : 0;\r\n        if (number >= 2) {\r\n            const w = diff / (number - 1);\r\n            this.svgText.setAttribute(\"letter-spacing\", `${w}`);\r\n        }\r\n        this.svgText.setAttribute(\"textLength\", `${value}`);\r\n        this.svgTextPath.setAttribute(\"textLength\", `${value}`);\r\n    }\r\n    get pathPoints() {\r\n        const dAttr = this.svgPath.getAttribute(\"d\");\r\n        if (dAttr == null)\r\n            throw Error(\"error\");\r\n        const d = dAttr.split(\" \");\r\n        let i = 0;\r\n        const r = [];\r\n        while (i < d.length) {\r\n            if (d[i] == \"M\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                i += 3;\r\n            }\r\n            else if (d[i] == \"L\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                i += 3;\r\n            }\r\n            else if (d[i] == \"Q\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                r.push([Number(d[i + 3]), Number(d[i + 4])]);\r\n                i += 5;\r\n            }\r\n            else {\r\n                throw Error(\"path points parse error\");\r\n            }\r\n        }\r\n        /*\r\n        if(r.length == 0){\r\n            r.push([0, 0]);\r\n            r.push([0, 0]);\r\n        }\r\n        */\r\n        return r;\r\n    }\r\n    set pathPoints(points) {\r\n        let path = \"\";\r\n        if (points.length == 2) {\r\n            const [x1, y1] = points[0];\r\n            const [x2, y2] = points[1];\r\n            path = `M ${x1} ${y1} L ${x2} ${y2}`;\r\n        }\r\n        else if (points.length == 3) {\r\n            const [x1, y1] = points[0];\r\n            const [x2, y2] = points[2];\r\n            const [cx1, cy1] = points[1];\r\n            path = `M ${x1} ${y1} Q ${cx1} ${cy1} ${x2} ${y2}`;\r\n        }\r\n        else if (points.length == 1) {\r\n            throw Error(\"path points ivnalid error\");\r\n        }\r\n        else {\r\n            path = `M ${0} ${0} L ${0} ${0}`;\r\n        }\r\n        const prevPath = this.svgPath.getAttribute(\"d\");\r\n        if (prevPath == null || path != prevPath) {\r\n            this.svgPath.setAttribute(\"d\", path);\r\n        }\r\n    }\r\n    updateConnectorInfo() {\r\n        const oldBeginVertex = GEdge.getConnectedVertexFromDic(this, true);\r\n        const oldEndVertex = GEdge.getConnectedVertexFromDic(this, false);\r\n        if (this.beginVertex != oldBeginVertex) {\r\n            if (oldBeginVertex != null) {\r\n                this.removeVertexEvent(oldBeginVertex);\r\n                if (oldBeginVertex.outcomingEdges.indexOf(this) != -1) {\r\n                    oldBeginVertex.removeOutcomingEdge(this);\r\n                }\r\n            }\r\n            if (this.beginVertex != null) {\r\n                this.addVertexEvent(this.beginVertex);\r\n                if (this.beginVertex.outcomingEdges.indexOf(this) == -1) {\r\n                    this.beginVertex.insertOutcomingEdge(this);\r\n                }\r\n            }\r\n            GEdge.setConnectedVertexFromDic(this, true);\r\n        }\r\n        if (this.endVertex != oldEndVertex) {\r\n            if (oldEndVertex != null) {\r\n                this.removeVertexEvent(oldEndVertex);\r\n                if (oldEndVertex.incomingEdges.indexOf(this) != -1) {\r\n                    oldEndVertex.removeIncomingEdge(this);\r\n                }\r\n            }\r\n            if (this.endVertex != null) {\r\n                this.addVertexEvent(this.endVertex);\r\n                if (this.endVertex.incomingEdges.indexOf(this) == -1) {\r\n                    this.endVertex.insertIncomingEdge(this);\r\n                }\r\n            }\r\n            GEdge.setConnectedVertexFromDic(this, false);\r\n        }\r\n        //if(this.beginVertexID != )\r\n    }\r\n    revTextForApp() {\r\n        if (this.side == \"left\" || this.side == null) {\r\n            this.side = \"right\";\r\n        }\r\n        else {\r\n            this.side = \"left\";\r\n        }\r\n        const tspans = new Array(0);\r\n        this.svgTextPath.children.item;\r\n        for (let i = this.svgTextPath.children.length; i >= 0; i--) {\r\n            const tspan = this.svgTextPath.children.item(i);\r\n            if (tspan instanceof SVGTSpanElement) {\r\n                tspans.push(tspan);\r\n            }\r\n        }\r\n        tspans.forEach((v) => v.remove());\r\n        tspans.forEach((v) => {\r\n            const text = v.textContent;\r\n            if (text != null) {\r\n                const revText = GEdge.getRevString(text);\r\n                v.textContent = revText;\r\n            }\r\n            this.svgTextPath.appendChild(v);\r\n        });\r\n    }\r\n    /**\r\n     * 再描画します。\r\n     */\r\n    update() {\r\n        super.update();\r\n        this.updateConnectorInfo();\r\n        this.hasConnectedObserverFunction = false;\r\n        //this._observer.disconnect();\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null) {\r\n            enum_extension_1.setCpmoutedDashArray(this.svgPath);\r\n        }\r\n        //this._observer.observe(this.svgGroup, this._observerOption);\r\n        this.hasConnectedObserverFunction = true;\r\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\r\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\r\n        const [x1, y1] = this.beginVertex != null ? this.beginVertex.getLocation(this.beginConnectorType, cx2, cy2) : [cx1, cy1];\r\n        const [x2, y2] = this.endVertex != null ? this.endVertex.getLocation(this.endConnectorType, cx1, cy1) : [cx2, cy2];\r\n        /*\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n        */\r\n        const points = this.pathPoints;\r\n        points[0] = [x1, y1];\r\n        points[points.length - 1] = [x2, y2];\r\n        this.pathPoints = points;\r\n        if (this.isAppropriatelyReverseMode) {\r\n            const degree = this.degree;\r\n            if (degree < -90 || degree > 90) {\r\n                //Rev\r\n                if (this.side == \"left\" || this.side == null) {\r\n                    this.revTextForApp();\r\n                }\r\n            }\r\n            else {\r\n                if (this.side == \"right\") {\r\n                    this.revTextForApp();\r\n                }\r\n            }\r\n        }\r\n        if (this.markerStart != null) {\r\n            var node = this.markerStart.firstChild;\r\n            if (this.lineColor != null) {\r\n                node.setAttribute(\"fill\", this.lineColor);\r\n            }\r\n        }\r\n        if (this.markerEnd != null) {\r\n            var node = this.markerEnd.firstChild;\r\n            if (this.lineColor != null) {\r\n                node.setAttribute(\"fill\", this.lineColor);\r\n            }\r\n        }\r\n        const strokeWidth = ElementExtension.getPropertyStyleValue(this.svgPath, \"stroke-width\");\r\n        if (strokeWidth != null) {\r\n            const diffy = CommonFunctions.toPX(strokeWidth) + 3;\r\n            this.svgText.setAttribute(\"dy\", `-${diffy}`);\r\n        }\r\n        else {\r\n            this.svgText.setAttribute(\"dy\", \"0\");\r\n        }\r\n        if (this.pathTextAlignment == enums_1.PathTextAlighnment.regularInterval) {\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            const strLen = this.svgTextPath.textContent == null ? 0 : this.svgTextPath.textContent.length;\r\n            const strWidth = SVGTextBox.getTextEmulatedWidth(this.svgTextPath);\r\n            if (strWidth > 0) {\r\n                const paddingWidth = pathLen - strWidth;\r\n                const paddingUnit = paddingWidth / (strLen + 1);\r\n                //const startPos = pathLen / (strLen + 1);\r\n                let textPathLen = pathLen - (paddingUnit * 2);\r\n                if (textPathLen <= 0)\r\n                    textPathLen = 5;\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${paddingUnit}`);\r\n                this.setRegularInterval(textPathLen);\r\n            }\r\n        }\r\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.end) {\r\n            this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            this.removeTextLengthAttribute();\r\n            //const textRect = SVGTextBox.getSize(this.svgText);\r\n            const strWidth = SVGTextBox.getTextEmulatedWidth(this.svgTextPath);\r\n            //const box = this.svgText.getBBox();\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            //this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            //this.svgTextPath.setAttribute(\"startOffset\", `${pathLen - strWidth}`);\r\n            if (this.side == \"right\") {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            }\r\n            else {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${pathLen - strWidth}`);\r\n            }\r\n        }\r\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.center) {\r\n            this.removeTextLengthAttribute();\r\n            //const textRect = SVGTextBox.getSize(this.svgText);\r\n            const strWidth = SVGTextBox.getTextEmulatedWidth(this.svgTextPath);\r\n            //const box = this.svgText.getBBox();\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            const offset = (pathLen - strWidth) / 2;\r\n            if (this.side == \"right\") {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${offset}`);\r\n            }\r\n            else {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${offset}`);\r\n            }\r\n            //こっちだとEdgeではおかしくなる\r\n            //this.svgTextPath.startOffset.baseVal.value = (pathLen - box.width)/2;                    \r\n        }\r\n        else {\r\n            const strWidth = SVGTextBox.getTextEmulatedWidth(this.svgTextPath);\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            if (this.side == \"right\") {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${pathLen - strWidth}`);\r\n            }\r\n            else {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            }\r\n            //this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            this.removeTextLengthAttribute();\r\n            //this.svgText.textLength.baseVal.value = 0;\r\n        }\r\n        return false;\r\n    }\r\n    static getRevString(text) {\r\n        let s = \"\";\r\n        for (let i = text.length - 1; i >= 0; i--) {\r\n            s += text[i];\r\n        }\r\n        return s;\r\n    }\r\n    /**\r\n     * この辺のテキストがパスに沿って均等に描画される状態ならばTrueを返します。\r\n     */\r\n    get pathTextAlignment() {\r\n        const value = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.PathTextAlignment, \"center\");\r\n        return enums_1.PathTextAlighnment.toPathTextAlighnment(value);\r\n    }\r\n    set pathTextAlignment(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.PathTextAlignment, value);\r\n    }\r\n    save() {\r\n    }\r\n    setIndexDictionaryForVBA(vertexDic, edgeDic) {\r\n        if (this.controlPoint.length == 0) {\r\n            edgeDic[this.objectID] = Object.keys(edgeDic).length;\r\n        }\r\n        else if (this.controlPoint.length > 0) {\r\n            //edgeDic[this.objectID] = Object.keys(edgeDic).length;\r\n            for (let i = 0; i < this.VBAConnectorNumber; i++) {\r\n                vertexDic[`${this.objectID}_${i}`] = Object.keys(vertexDic).length;\r\n            }\r\n            for (let i = 0; i <= this.VBAConnectorNumber; i++) {\r\n                edgeDic[`${this.objectID}_${i}`] = Object.keys(edgeDic).length;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 矢印オブジェクトを作成します。\r\n     */\r\n    static createMark(option = {}) {\r\n        var [marker, path] = SVG.createMarker(option);\r\n        if (option.isEnd != undefined && option.isEnd) {\r\n            path.setAttribute(\"transform\", \"rotate(180,5,5)\");\r\n            marker.setAttribute(\"refX\", \"0\");\r\n        }\r\n        marker.id = `marker-${GEdge.markerCounter++}`;\r\n        return marker;\r\n    }\r\n    static createStartMarker(option = {}) {\r\n        const option2 = { className: option.className, strokeWidth: option.strokeWidth, color: option.color, isEnd: true };\r\n        return this.createMark(option2);\r\n    }\r\n    static createEndMarker(option = {}) {\r\n        return this.createMark(option);\r\n    }\r\n    /*\r\n    public setStyleForPNG() {\r\n        SVG.setStyleForPNG(this.svgPath);\r\n        SVG.setStyleForPNG(this.svgText);\r\n        SVG.setStyleForPNG(this.svgTextPath);\r\n\r\n    }\r\n    */\r\n    get shape() {\r\n        return \"msoConnectorStraight\";\r\n    }\r\n    createVBACode(id) {\r\n        const lineArr = [];\r\n        const r = [];\r\n        r.push(`Sub create${id}(createdSlide As slide)`);\r\n        r.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        r.push(` Dim obj As Shape`);\r\n        if (this.controlPoint.length == 0) {\r\n            r.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0)`);\r\n            if (this.beginVertex != null && this.endVertex != null) {\r\n                if (this.markerStart != null) {\r\n                    r.push(` obj.Line.BeginArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` obj.Line.BeginArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` obj.Line.BeginArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n                if (this.markerEnd != null) {\r\n                    r.push(` obj.Line.EndArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` obj.Line.EndArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` obj.Line.EndArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n                const begType = enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, this.endVertex.x, this.endVertex.y));\r\n                const endType = enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, this.beginVertex.x, this.beginVertex.y));\r\n                r.push(` Call EditConnector(obj.ConnectorFormat, shapes_(\"${this.beginVertex.objectID}\"), shapes_(\"${this.endVertex.objectID}\"), ${begType}, ${endType})`);\r\n                const lineType = enum_extension_1.getLineType(this.svgPath);\r\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\r\n                const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\r\n                const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n                r.push(` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n            }\r\n        }\r\n        else if (this.controlPoint.length > 0 && this.beginVertex != null && this.endVertex != null) {\r\n            //subline.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0)`);\r\n            //lineArr.push(i);\r\n            r.push(` Dim nodes(${this.VBAConnectorNumber}) As Shape`);\r\n            for (let j = 0; j < this.VBAConnectorNumber; j++) {\r\n                const t = (j + 1) / (this.VBAConnectorNumber + 1);\r\n                const centerPoint = CommonFunctions.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], t);\r\n                r.push(`shapes_.AddShape(msoShapeOval, ${centerPoint[0]}, ${centerPoint[1]}, 0, 0).name = \"${this.objectID}_node_${j}\"`);\r\n            }\r\n            for (let j = 0; j <= this.VBAConnectorNumber; j++) {\r\n                //const centerPoint = Common.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], 0.5);\r\n                const edgeID = `${this.objectID}_edge_${j}`;\r\n                const beg = j == 0 ? this.beginVertex.objectID : `${this.objectID}_node_${j - 1}`;\r\n                const end = j == this.VBAConnectorNumber ? this.endVertex.objectID : `${this.objectID}_node_${j}`;\r\n                r.push(` shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0).name = \"${this.objectID}_edge_${j}\"`);\r\n                const lineType = enum_extension_1.getLineType(this.svgPath);\r\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\r\n                const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\r\n                const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n                r.push(` Call EditLine(shapes_(\"${edgeID}\").Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n                const begType = j == 0 ? enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, this.endVertex.x, this.endVertex.y)) : 1;\r\n                const endType = j == this.VBAConnectorNumber ? enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, this.beginVertex.x, this.beginVertex.y)) : 1;\r\n                r.push(` Call EditConnector(shapes_(\"${edgeID}\").ConnectorFormat, shapes_(\"${beg}\"), shapes_(\"${end}\"), ${begType}, ${endType})`);\r\n            }\r\n            /*\r\n            const edgeBeginID = edgeDic[`${this.objectID}_${0}`];\r\n            const edgeEndID = edgeDic[`${this.objectID}_${this.VBAConnectorNumber}`];\r\n\r\n            if (this.beginVertex != null && this.endVertex != null) {\r\n                if (this.markerStart != null) {\r\n                    r.push(` edges(${edgeBeginID}).Line.BeginArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` edges(${edgeBeginID}).Line.BeginArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` edges(${edgeBeginID}).Line.BeginArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n                if (this.markerEnd != null) {\r\n                    r.push(` edges(${edgeEndID}).Line.EndArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` edges(${edgeEndID}).Line.EndArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` edges(${edgeEndID}).Line.EndArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n\r\n            }\r\n            */\r\n        }\r\n        lineArr.forEach((v) => {\r\n            const lineType = enum_extension_1.getLineType(this.svgPath);\r\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke\", \"gray\"));\r\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"stroke-width\", \"4\"));\r\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgPath, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n            r.push(` Call EditLine(edges(${v}).Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n        });\r\n        //subline.forEach((v) => sub.push([v]));\r\n        const textCodes = this.createVBACodeOfText(id);\r\n        textCodes.forEach((v, i) => r.push(`Call create${id}_label_${i}(shapes_)`));\r\n        r.push(`End Sub`);\r\n        textCodes.forEach((v) => v.forEach((w) => r.push(w)));\r\n        return r;\r\n    }\r\n    get hasSize() {\r\n        return false;\r\n    }\r\n    /**\r\n     * VBAコードを作成します。\r\n     * @param shapes\r\n     * @param result\r\n     */\r\n    createVBACodeOfText(id) {\r\n        const r = [];\r\n        const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgTextPath, \"font-size\", \"12\"));\r\n        const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(this.svgTextPath, \"font-family\", \"MS PGothic\"));\r\n        const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(this.svgTextPath, \"font-weight\", \"none\"));\r\n        if (this.svgTextPath.textContent != null) {\r\n            for (let i = 0; i < this.svgTextPath.textContent.length; i++) {\r\n                const s = new Array(0);\r\n                const p1 = this.svgTextPath.getStartPositionOfChar(i);\r\n                const p2 = this.svgTextPath.getEndPositionOfChar(i);\r\n                const width = Math.abs(p2.x - p1.x);\r\n                const height = Math.abs(p2.y - p1.y);\r\n                const rad = this.svgTextPath.getRotationOfChar(i);\r\n                const diffx = (fontSize * 1 / 2) * Math.sin((rad / 180) * Math.PI);\r\n                const diffy = (fontSize * 3 / 8) + ((fontSize * 3 / 8) * Math.cos((rad / 180) * Math.PI));\r\n                const left = p1.x + diffx;\r\n                //const top = this.graph.svgGroup.getY() + p1.y - (fontSize / 2);\r\n                const top = p1.y - (fontSize * 1 / 4) - diffy;\r\n                //const top = this.graph.svgGroup.getY() + p1.y - diffy;\r\n                s.push(`Sub create${id}_label_${i}(shapes_ As Shapes)`);\r\n                s.push(`With shapes_.AddTextBox(msoTextOrientationHorizontal, ${left}, ${top},${width},${fontSize})`);\r\n                s.push(`.TextFrame.TextRange.Text = \"${this.svgTextPath.textContent[i]}\"`);\r\n                s.push(`.TextFrame.marginLeft = 0`);\r\n                s.push(`.TextFrame.marginRight = 0`);\r\n                s.push(`.TextFrame.marginTop = 0`);\r\n                s.push(`.TextFrame.marginBottom = 0`);\r\n                s.push(`.TextFrame.TextRange.Font.Size = ${fontSize}`);\r\n                s.push(`.TextFrame.TextRange.Font.name = \"${fontFamily}\"`);\r\n                s.push(`.TextFrame.TextRange.Font.Bold = ${fontBold}`);\r\n                s.push(`.IncrementRotation(${this.svgTextPath.getRotationOfChar(i)})`);\r\n                //s.push(`.IncrementRotation(${this.svgText.transform.baseVal.getItem(0).angle})`);\r\n                s.push(`End With`);\r\n                s.push(`End Sub`);\r\n                r.push(s);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\nGEdge.connectedBeginVertexDic = {};\r\nGEdge.connectedEndVertexDic = {};\r\nGEdge.markerCounter = 0;\r\nexports.GEdge = GEdge;\r\n//}\r\n//# sourceMappingURL=g_edge.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_edge.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_ellipse.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_ellipse.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GAbstractEllipseCircle extends g_vertex_1.GVertex {\r\n    get rx() {\r\n        return 5;\r\n    }\r\n    get ry() {\r\n        return 5;\r\n    }\r\n    /**\r\n    頂点の幅を返します。\r\n    */\r\n    get width() {\r\n        return this.rx * 2;\r\n    }\r\n    /**\r\n    頂点の高さを返します。\r\n    */\r\n    get height() {\r\n        return this.ry * 2;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n    }\r\n    /**\r\n    テキストの領域を返します。\r\n    */\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        rect.x = -this.rx;\r\n        rect.y = -this.ry;\r\n        return rect;\r\n    }\r\n    getLocation(type, x, y) {\r\n        const centerX = (Math.sqrt(2) / 2) * this.rx;\r\n        const centerY = (Math.sqrt(2) / 2) * this.ry;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - this.ry];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n                return [this.cx + centerX, this.cy - centerY];\r\n            case enums_1.ConnectorPosition.Right:\r\n                return [this.cx + this.rx, this.cy];\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + centerX, this.cy + centerY];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + this.ry];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n                return [this.cx - centerX, this.cy + centerY];\r\n            case enums_1.ConnectorPosition.Left:\r\n                return [this.cx - this.rx, this.cy];\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - centerX, this.cy - centerY];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const radius = this.rx;\r\n        const r = (Math.sqrt(2) / 2) * radius;\r\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + r, this.y + r);\r\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + r, this.y - r);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GAbstractEllipseCircle = GAbstractEllipseCircle;\r\nclass GEllipse extends GAbstractEllipseCircle {\r\n    get svgEllipse() {\r\n        return this._svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (this.type == enums_1.ShapeObjectType.Ellipse)\r\n            this.firstFunctionAfterInitialized();\r\n        //this.update();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\r\n        this._svgSurface = GEllipse.createEllipse(this.svgGroup, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgEllipse, this.svgText);\r\n    }\r\n    static createEllipse(parent, className, style) {\r\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\r\n        parent.appendChild(circle);\r\n        if (style !== undefined) {\r\n            if (typeof (style) == \"string\") {\r\n                circle.setAttribute(\"style\", style);\r\n            }\r\n            else {\r\n                circle.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\r\n            }\r\n        }\r\n        circle.rx.baseVal.value = AttributeNames.defaultCircleRadius;\r\n        circle.ry.baseVal.value = AttributeNames.defaultCircleRadius;\r\n        if (typeof (className) == \"string\") {\r\n            circle.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            circle.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\r\n        }\r\n        const radius = ElementExtension.getPropertyStyleNumberValue(circle, StyleNames.defaultRadius, null);\r\n        if (radius != null) {\r\n            circle.rx.baseVal.value = radius;\r\n            circle.ry.baseVal.value = radius;\r\n        }\r\n        /*\r\n        if (className == null) {\r\n            if(circle.style.stroke == null || circle.style.stroke == \"\")circle.style.stroke = \"black\";\r\n            if(circle.style.strokeWidth == null || circle.style.strokeWidth == \"\")circle.style.strokeWidth = \"1pt\";\r\n            if(circle.style.fill == null || circle.style.fill == \"\")circle.style.fill = \"white\";\r\n        } else {\r\n\r\n        }\r\n        */\r\n        circle.cx.baseVal.value = 0;\r\n        circle.cy.baseVal.value = 0;\r\n        return circle;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        return output;\r\n    }\r\n    get width() {\r\n        return this.svgEllipse.rx.baseVal.value * 2;\r\n    }\r\n    get height() {\r\n        return this.svgEllipse.ry.baseVal.value * 2;\r\n    }\r\n    set width(value) {\r\n        const _rx = value / 2;\r\n        if (this.width != value)\r\n            this.svgEllipse.setAttribute(\"rx\", _rx.toString());\r\n    }\r\n    set height(value) {\r\n        const _ry = value / 2;\r\n        if (this.height != value)\r\n            this.svgEllipse.setAttribute(\"ry\", _ry.toString());\r\n    }\r\n    get rx() {\r\n        return this.svgEllipse.rx.baseVal.value;\r\n    }\r\n    get ry() {\r\n        return this.svgEllipse.ry.baseVal.value;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Ellipse;\r\n    }\r\n    /*\r\n    public getLocation(type: ConnectorPosition, x: number, y: number): [number, number] {\r\n\r\n        const centerX = (Math.sqrt(2) / 2) * this.svgEllipse.rx.baseVal.value;\r\n        const centerY = (Math.sqrt(2) / 2) * this.svgEllipse.ry.baseVal.value;\r\n\r\n        switch (type) {\r\n            case ConnectorPosition.Top:\r\n                return [this.cx, this.cy - this.ry];\r\n            case ConnectorPosition.TopRight:\r\n                return [this.cx + centerX, this.cy - centerY];\r\n            case ConnectorPosition.Right:\r\n                return [this.cx + this.rx, this.cy];\r\n            case ConnectorPosition.BottomRight:\r\n                return [this.cx + centerX, this.cy + centerY];\r\n            case ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + this.ry];\r\n            case ConnectorPosition.BottomLeft:\r\n                return [this.cx - centerX, this.cy + centerY];\r\n            case ConnectorPosition.Left:\r\n                return [this.cx - this.rx, this.cy];\r\n            case ConnectorPosition.TopLeft:\r\n                return [this.cx - centerX, this.cy - centerY];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    protected getAutoPosition(x: number, y: number): ConnectorPosition {\r\n        const radius = this.rx;\r\n        const r = (Math.sqrt(2) / 2) * radius;\r\n        const line1 = new VLine(this.x, this.y, this.x + r, this.y + r);\r\n        const line2 = new VLine(this.x, this.y, this.x + r, this.y - r);\r\n\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n\r\n        if (b1) {\r\n            if (b2) {\r\n                return ConnectorPosition.Top;\r\n            } else {\r\n                return ConnectorPosition.Right;\r\n            }\r\n        } else {\r\n            if (b2) {\r\n                return ConnectorPosition.Left;\r\n            } else {\r\n                return ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n    */\r\n    get shape() {\r\n        return \"msoShapeOval\";\r\n    }\r\n}\r\nexports.GEllipse = GEllipse;\r\n/*\r\nexport type EllipseAttributes = TextBoxShapeAttributes & {\r\n    speakerX? : number,\r\n    speakerY? : number,\r\n}\r\n*/\r\n//}\r\n//# sourceMappingURL=g_ellipse.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_ellipse.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_graph.js":
/*!**************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_graph.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nconst g_edge_1 = __webpack_require__(/*! ./g_edge */ \"./node_modules/graph-table-svg/dist/objects/g_edge.js\");\r\nconst g_rect_1 = __webpack_require__(/*! ./g_rect */ \"./node_modules/graph-table-svg/dist/objects/g_rect.js\");\r\nconst g_rect_button_1 = __webpack_require__(/*! ./g_rect_button */ \"./node_modules/graph-table-svg/dist/objects/g_rect_button.js\");\r\nconst g_callout_1 = __webpack_require__(/*! ./g_callout */ \"./node_modules/graph-table-svg/dist/objects/g_callout.js\");\r\nconst g_arrow_callout_1 = __webpack_require__(/*! ./g_arrow_callout */ \"./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js\");\r\nconst g_ellipse_1 = __webpack_require__(/*! ./g_ellipse */ \"./node_modules/graph-table-svg/dist/objects/g_ellipse.js\");\r\nconst g_circle_1 = __webpack_require__(/*! ./g_circle */ \"./node_modules/graph-table-svg/dist/objects/g_circle.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\nconst graph_arrangement_1 = __webpack_require__(/*! ./graph_helpers/graph_arrangement */ \"./node_modules/graph-table-svg/dist/objects/graph_helpers/graph_arrangement.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst Extensions = __webpack_require__(/*! ../interfaces/extensions */ \"./node_modules/graph-table-svg/dist/interfaces/extensions.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\n/**\r\nグラフを表します。\r\n*/\r\nclass GGraph extends g_object_1.GObject {\r\n    constructor(box, option = {}) {\r\n        super(box, option);\r\n        this._roots = [];\r\n        this.objectCreatedFunction = (e) => {\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(e.target);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                this.dispatchVertexCreatedEvent(obj);\r\n            }\r\n            else if (obj instanceof g_edge_1.GEdge) {\r\n            }\r\n            else {\r\n            }\r\n        };\r\n        if (this.type == enums_1.ShapeObjectType.Graph)\r\n            this.firstFunctionAfterInitialized();\r\n        //this.svgGroup.addEventListener(AttributeNames.objectCreatedEventName, this.objectCreatedFunction);\r\n    }\r\n    get graphAllocateFunction() {\r\n        const svg = this.svgGroup;\r\n        const f = svg.__graph_allocate_function;\r\n        return f;\r\n    }\r\n    set graphAllocateFunction(value) {\r\n        this.svgGroup.__graph_allocate_function = value;\r\n    }\r\n    get vertices() {\r\n        const r = [];\r\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\r\n            const item = g_object_1.GObject.getObjectFromObjectID(v.getAttribute(AttributeNames.objectIDName));\r\n            if (item instanceof g_vertex_1.GVertex) {\r\n                r.push(item);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get edges() {\r\n        const r = [];\r\n        HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(AttributeNames.objectIDName)).forEach((v) => {\r\n            const item = g_object_1.GObject.getObjectFromObjectID(v.getAttribute(AttributeNames.objectIDName));\r\n            if (item instanceof g_edge_1.GEdge) {\r\n                r.push(item);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get roots() {\r\n        return this.vertices.filter((v) => v.incomingEdges.length == 0);\r\n    }\r\n    get vertexXInterval() {\r\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.vertexXInterval);\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return parseInt(v);\r\n        }\r\n    }\r\n    set vertexXInterval(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.vertexXInterval, value == null ? null : value.toString());\r\n    }\r\n    get vertexYInterval() {\r\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.vertexYInterval);\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return parseInt(v);\r\n        }\r\n    }\r\n    get direction() {\r\n        const v = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.graphDirection);\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (v == \"up\") {\r\n                return \"up\";\r\n            }\r\n            else if (v == \"left\") {\r\n                return \"left\";\r\n            }\r\n            else if (v == \"right\") {\r\n                return \"right\";\r\n            }\r\n            else {\r\n                return \"down\";\r\n            }\r\n        }\r\n    }\r\n    set direction(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.graphDirection, value == null ? null : value.toString());\r\n    }\r\n    set vertexYInterval(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.vertexYInterval, value == null ? null : value.toString());\r\n    }\r\n    /*\r\n    get defaultVertexClass(): string | null {\r\n        return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultVertexClass);\r\n    }\r\n    set defaultVertexClass(value: string | null) {\r\n        this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultVertexClass, value);\r\n    }\r\n    */\r\n    /*\r\n     get defaultEdgeClass(): string | null {\r\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultEdgeClass);\r\n     }\r\n     */\r\n    /*\r\n     set defaultEdgeClass(value: string | null) {\r\n         this.svgGroup.setPropertyStyleValue(AttributeNames.Style.defaultEdgeClass, value);\r\n     }\r\n     */\r\n    /**\r\n    根を返します。\r\n    */\r\n    get rootVertex() {\r\n        if (this.roots.length == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.roots[0];\r\n        }\r\n    }\r\n    /**\r\n     * 頂点もしくは辺をグラフに追加します。\r\n     * @param item\r\n     */\r\n    add(item) {\r\n        if (item instanceof g_vertex_1.GVertex) {\r\n            this.svgGroup.insertBefore(item.svgGroup, this.svgGroup.firstChild);\r\n        }\r\n        else {\r\n            this.svgGroup.appendChild(item.svgGroup);\r\n        }\r\n    }\r\n    /**\r\n     * 頂点もしくは辺を削除します。\r\n     * @param item\r\n     */\r\n    remove(item) {\r\n        this.svgGroup.removeChild(item.svgGroup);\r\n        item.dispose();\r\n    }\r\n    clear() {\r\n        while (this.edges.length > 0) {\r\n            this.remove(this.edges[0]);\r\n        }\r\n        while (this.vertices.length > 0) {\r\n            this.remove(this.vertices[0]);\r\n        }\r\n    }\r\n    /**\r\n            * 与えられた二つの頂点と辺を接続します。\r\n            * @param beginVertex 開始節\r\n            * @param edge 接続する辺\r\n            * @param endVertex 終了節\r\n            * @param option 接続オプション\r\n            * @param option.incomingInsertIndex endVertexのincomingEdgeの配列に今回の辺をどの位置に挿入するか\r\n            * @param option.outcomingInsertIndex beginVertexのoutcomingEdgeの配列に今回の辺をどの位置に挿入するか\r\n            * @param option.beginConnectorType beginVertexの接続位置\r\n            * @param option.endConnectorType endVertexの接続位置\r\n            */\r\n    connect(beginVertex, edge, endVertex, option = {}) {\r\n        const oIndex = option.outcomingInsertIndex == undefined ? beginVertex.outcomingEdges.length : option.outcomingInsertIndex;\r\n        const iIndex = option.incomingInsertIndex == undefined ? endVertex.incomingEdges.length : option.incomingInsertIndex;\r\n        //this._connect(node1, edge, node2);\r\n        beginVertex.insertOutcomingEdge(edge, oIndex);\r\n        endVertex.insertIncomingEdge(edge, iIndex);\r\n        const i = this.roots.indexOf(beginVertex);\r\n        const j = this.roots.indexOf(endVertex);\r\n        if (j != -1) {\r\n            if (i == -1) {\r\n                this.roots[j] = beginVertex;\r\n            }\r\n            else {\r\n                this.roots.splice(j, 1);\r\n            }\r\n        }\r\n        if (option.beginConnectorType != undefined)\r\n            edge.beginConnectorType = option.beginConnectorType;\r\n        if (option.endConnectorType != undefined)\r\n            edge.endConnectorType = option.endConnectorType;\r\n    }\r\n    getOrderedVertices(order, node = null) {\r\n        const r = [];\r\n        if (node == null) {\r\n            this.roots.forEach((v) => {\r\n                this.getOrderedVertices(order, v).forEach((w) => {\r\n                    r.push(w);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            const edges = node.outcomingEdges;\r\n            if (order == enums_1.VertexOrder.Preorder) {\r\n                r.push(node);\r\n                edges.forEach((v) => {\r\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                });\r\n            }\r\n            else if (order == enums_1.VertexOrder.Postorder) {\r\n                edges.forEach((v) => {\r\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                });\r\n                r.push(node);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    /**\r\n     * 親ノードに子ノードを追加します。\r\n     * @param parent\r\n     * @param child\r\n     * @param option\r\n     */\r\n    appendChild(parent, child, option = {}) {\r\n        const _child = child == null ? GGraph.createVertex2(this) : child;\r\n        const edge = GGraph.createEdge(this);\r\n        this.connect(parent, edge, _child, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\r\n        //this.createdNodeCallback(child);\r\n        this.relocate();\r\n    }\r\n    get relocateStyle() {\r\n        return ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.relocateName);\r\n    }\r\n    set relocateStyle(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.relocateName, value);\r\n    }\r\n    relocate() {\r\n        //console.log(this.isDrawnText());\r\n        //if(this.isDrawnText()){\r\n        this.hasConnectedObserverFunction = false;\r\n        const value = this.relocateStyle;\r\n        if (this.graphAllocateFunction !== undefined) {\r\n            this.graphAllocateFunction(this);\r\n        }\r\n        else if (value != null) {\r\n            if (value == \"standard\") {\r\n                graph_arrangement_1.GraphArrangement.standardTreeWidthArrangement(this);\r\n            }\r\n            else {\r\n                const p = Function(\"v\", `return ${value}(v)`);\r\n                const f = Function(\"graph\", `${value}(graph)`);\r\n                f(this);\r\n            }\r\n        }\r\n        //this.relocate();\r\n        //this.moveInCanvas();\r\n        this.hasConnectedObserverFunction = true;\r\n        // }\r\n    }\r\n    get width() {\r\n        return this.Noderegion().width;\r\n    }\r\n    get height() {\r\n        return this.Noderegion().height;\r\n    }\r\n    set width(value) {\r\n    }\r\n    set height(value) {\r\n    }\r\n    Noderegion() {\r\n        const _x = SVGGExtension.getX(this.svgGroup);\r\n        const _y = SVGGExtension.getY(this.svgGroup);\r\n        let left = _x;\r\n        let right = _y;\r\n        let top = _x;\r\n        let bottom = _y;\r\n        this.vertices.forEach((v) => {\r\n            const x = v.x + _x;\r\n            const y = v.y + _y;\r\n            if (x < left)\r\n                left = x;\r\n            if (right < (x + v.width))\r\n                right = x + v.width;\r\n            if (y < top)\r\n                top = y;\r\n            if (bottom < (y + v.height))\r\n                bottom = y + v.height;\r\n        });\r\n        return new vline_1.Rectangle(left, top, right - left, bottom - top);\r\n    }\r\n    moveInCanvas() {\r\n        const rect = this.Noderegion();\r\n        if (rect.x < 0) {\r\n            this.x = this.x - (rect.x);\r\n        }\r\n        if (rect.y < 0) {\r\n            this.y = this.y - (rect.y);\r\n        }\r\n    }\r\n    build(logicGraph) {\r\n        const option = logicGraph instanceof logic_tree_1.LogicTree ? logicGraph.graphOption : logicGraph.graphOption;\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        this.clear();\r\n        const svgsvg = SVG.getSVGSVG(this.svgGroup);\r\n        if (option.direction !== undefined) {\r\n            this.direction = option.direction;\r\n        }\r\n        if (logicGraph instanceof logic_tree_1.LogicGraph) {\r\n            const dic = new Map();\r\n            logicGraph.nodes.forEach((v, i) => {\r\n                const node = GGraph.createVertex(svgsvg, \"g-circle\");\r\n                node.svgText.textContent = v.text;\r\n                this.add(node);\r\n                dic.set(i, node);\r\n            });\r\n            logicGraph.nodes.forEach((v, i) => {\r\n                v.outputEdges.forEach((e, j) => {\r\n                    const edge = GGraph.createEdge(svgsvg);\r\n                    if (e.text != undefined) {\r\n                        const b = option.isLatexMode == undefined ? false : option.isLatexMode;\r\n                        Extensions.setTextContent(edge.svgTextPath, e.text, b);\r\n                    }\r\n                    this.add(edge);\r\n                    const beginNode = dic.get(i);\r\n                    const endNode = dic.get(e.endNodeIndex);\r\n                    if (beginNode == undefined || endNode == undefined)\r\n                        throw Error(\"error\");\r\n                    this.connect(beginNode, edge, endNode);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            const dic = new Map();\r\n            logicGraph.getOrderedNodes(enums_1.VertexOrder.Preorder).forEach((v, i) => {\r\n                const node = GGraph.createVertex(svgsvg, \"g-circle\", v.vertexOption);\r\n                //node.svgText.textContent = v.vertexText;\r\n                this.add(node);\r\n                dic.set(v, node);\r\n            });\r\n            logicGraph.getOrderedNodes(enums_1.VertexOrder.Preorder).forEach((v, i) => {\r\n                v.children.forEach((e, j) => {\r\n                    if (e != null) {\r\n                        const edge = GGraph.createEdge(svgsvg, e.edgeOption);\r\n                        if (edge.svgTextPath.textContent != null) {\r\n                            //const b = option.isLatexMode == undefined ? false : option.isLatexMode;\r\n                            //edge.svgTextPath.setTextContent(e.parentEdgeText, b);\r\n                            //console.log(\"@\" + edge.svgText.getComputedTextLength() + \"/\" + edge.svgText.textContent);\r\n                            //this.svgSurface!.onload = this.onLoadFunction;\r\n                            edge.isAppropriatelyReverseMode = true;\r\n                            //edge.setAppropriateText();\r\n                        }\r\n                        this.add(edge);\r\n                        const beginNode = dic.get(v);\r\n                        const endNode = dic.get(e);\r\n                        if (beginNode == undefined || endNode == undefined)\r\n                            throw Error(\"error\");\r\n                        this.connect(beginNode, edge, endNode);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        if (option.relocateStyle !== undefined) {\r\n            this.relocateStyle = option.relocateStyle;\r\n        }\r\n        else {\r\n            this.relocateStyle = \"standard\";\r\n        }\r\n        //this.x = 200;\r\n        //this.y = 200;\r\n        if (option.x != undefined)\r\n            SVGGExtension.setX(this.svgGroup, option.x);\r\n        if (option.y != undefined)\r\n            SVGGExtension.setY(this.svgGroup, option.y);\r\n        this.relocate();\r\n    }\r\n    /*\r\n     public constructFromLogicTree(roots: LogicTree[] | LogicTree, option: { x?: number, y?: number, isLatexMode?: boolean } = {}) {\r\n         if (option.isLatexMode == undefined) option.isLatexMode = false;\r\n         if (roots instanceof Array) {\r\n             this.clear();\r\n             roots.forEach((v) => {\r\n                 if (v != null) {\r\n                     this.createChildFromLogicTree(null, v, option);\r\n                 }\r\n             });\r\n             this.relocate();\r\n \r\n         } else {\r\n             this.constructFromLogicTree([roots], option);\r\n         }\r\n         if (option.x != undefined) this.svgGroup.setX(option.x);\r\n         if (option.y != undefined) this.svgGroup.setY(option.y);\r\n \r\n         //this.roots = roots;\r\n     }\r\n     */\r\n    removeGraph(svg) {\r\n        if (svg.contains(this.svgGroup)) {\r\n            svg.removeChild(this.svgGroup);\r\n        }\r\n    }\r\n    /*\r\n    public isDrawnText() :boolean{\r\n        if(this.edges.length == 0){\r\n            return true;\r\n        }else{\r\n            \r\n            const b = this.edges.every((v) => v.isDrawnText());\r\n            return b;\r\n        }\r\n    }\r\n    */\r\n    /**\r\n     * グラフの領域を表すRectangleを返します。位置の基準はグラフが追加されているNodeです。\r\n     */\r\n    getRegion() {\r\n        const rects = this.vertices.map((v) => v.region);\r\n        const rect = vline_1.Rectangle.merge(rects);\r\n        rect.addOffset(SVGGExtension.getX(this.svgGroup), SVGGExtension.getY(this.svgGroup));\r\n        return rect;\r\n    }\r\n    /**\r\n     * 入力のVertexを親として、入力のLogicTreeを子とした部分木を作成します。\r\n     * @param parent 親にするVertex\r\n     * @param logicVertex 子にするLogicTree\r\n     * @param option 作成オプション\r\n     * @returns logicVertexを表すVertex\r\n     */\r\n    createChildFromLogicTree(parent = null, logicVertex, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        //const node: GVertex = <any>createVertex(this, { class: logicVertex.vertexClass == null ? undefined : logicVertex.vertexClass } );\r\n        const node = GGraph.createVertex2(this, logicVertex.vertexOption);\r\n        //if (logicVertex.vertexText != null) SVGTextBox.setTextToSVGText(node.svgText, logicVertex.vertexText, option.isLatexMode);\r\n        if (parent != null) {\r\n            const edge = GGraph.createEdge(this, logicVertex.edgeOption);\r\n            /*\r\n            if (logicVertex.parentEdgeText != null) {\r\n                edge.svgTextPath.setTextContent(logicVertex.parentEdgeText, option.isLatexMode);\r\n                edge.pathTextAlignment = PathTextAlighnment.regularInterval;\r\n            }\r\n            */\r\n            this.connect(parent, edge, node, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\r\n        }\r\n        else {\r\n            this.roots.push(node);\r\n        }\r\n        logicVertex.children.forEach((v) => {\r\n            if (v != null)\r\n                this.createChildFromLogicTree(node, v, option);\r\n        });\r\n        //this.createdNodeCallback(node);\r\n        return node;\r\n    }\r\n    createVBACode(id) {\r\n        const r = [];\r\n        this.vertices.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\r\n        this.edges.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\r\n        return r;\r\n    }\r\n    get VBAObjectNum() {\r\n        return this.vertices.length + this.edges.length;\r\n    }\r\n    getStyleValue(className, valueName) {\r\n        if (this.svgGroup.hasAttribute(\"class\")) {\r\n            const oldClass = this.svgGroup.getAttribute(\"class\");\r\n            this.svgGroup.setAttribute(\"class\", className);\r\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\r\n            this.svgGroup.setAttribute(\"class\", oldClass);\r\n            return r;\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"class\", className);\r\n            const r = ElementExtension.getPropertyStyleValue(this.svgGroup, valueName);\r\n            this.svgGroup.removeAttribute(\"class\");\r\n            return r;\r\n        }\r\n    }\r\n    dispatchVertexCreatedEvent(vertex) {\r\n        var event = document.createEvent(\"HTMLEvents\");\r\n        event.initEvent(AttributeNames.vertexCreatedEventName, true, true);\r\n        vertex.svgGroup.dispatchEvent(event);\r\n    }\r\n    setRootIndex(vertex, rootIndex) {\r\n        if (vertex.graph == this) {\r\n            if (rootIndex < this.roots.length) {\r\n                this.svgGroup.insertBefore(vertex.svgGroup, this.roots[rootIndex].svgGroup);\r\n            }\r\n            else {\r\n                if (this.roots.length == 0) {\r\n                    if (this.svgGroup.firstChild == null) {\r\n                        this.svgGroup.appendChild(vertex.svgGroup);\r\n                    }\r\n                    else {\r\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.svgGroup.firstChild);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.roots[this.roots.length - 1].svgGroup.nextSibling == null) {\r\n                        this.svgGroup.appendChild(vertex.svgGroup);\r\n                    }\r\n                    else {\r\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.roots[this.roots.length - 1].svgGroup.nextSibling);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw Error(\"error!\");\r\n        }\r\n    }\r\n    observerFunction(x) {\r\n        super.observerFunction(x);\r\n        for (let i = 0; i < x.length; i++) {\r\n            const p = x[i];\r\n            if (p.attributeName == \"style\") {\r\n                console.log(\"observerFunction\");\r\n                this.relocate();\r\n            }\r\n        }\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Graph;\r\n    }\r\n    resizeUpdate() {\r\n        this.relocate();\r\n    }\r\n    /*\r\n    public update() {\r\n        super.update();\r\n        \r\n    }\r\n    */\r\n    static createVertex2(parent, option = {}) {\r\n        let _parent = parent.svgGroup;\r\n        if (option.class == undefined)\r\n            option.class = DefaultClassNames.defaultVertexClass;\r\n        const type = typeof (option.class) == \"string\" ? parent.getStyleValue(option.class, StyleNames.defaultSurfaceType) : null;\r\n        if (type != null) {\r\n            switch (type) {\r\n                case enums_1.ShapeObjectType.Callout: return new g_callout_1.GCallout(_parent, option);\r\n                case enums_1.ShapeObjectType.ArrowCallout: return new g_arrow_callout_1.GArrowCallout(_parent, option);\r\n                case enums_1.ShapeObjectType.Ellipse: return new g_ellipse_1.GEllipse(_parent, option);\r\n                case enums_1.ShapeObjectType.Circle: return new g_circle_1.GCircle(_parent, option);\r\n                case enums_1.ShapeObjectType.Rect: return new g_rect_1.GRect(_parent, option);\r\n            }\r\n        }\r\n        return new g_ellipse_1.GEllipse(_parent, option);\r\n    }\r\n    static createVertex(parent, type, option = {}) {\r\n        let _parent;\r\n        if (parent instanceof g_object_1.GObject) {\r\n            _parent = parent.svgGroup;\r\n        }\r\n        else if (parent instanceof SVGElement) {\r\n            _parent = parent;\r\n        }\r\n        else {\r\n            _parent = document.getElementById(parent);\r\n        }\r\n        switch (type) {\r\n            case enums_1.ShapeObjectType.Callout: return new g_callout_1.GCallout(_parent, option);\r\n            case enums_1.ShapeObjectType.ArrowCallout: return new g_arrow_callout_1.GArrowCallout(_parent, option);\r\n            case enums_1.ShapeObjectType.Ellipse: return new g_ellipse_1.GEllipse(_parent, option);\r\n            case enums_1.ShapeObjectType.Rect: return new g_rect_1.GRect(_parent, option);\r\n            case enums_1.ShapeObjectType.RectButton: return new g_rect_button_1.GRectButton(_parent, option);\r\n            case enums_1.ShapeObjectType.Circle: return new g_circle_1.GCircle(_parent, option);\r\n        }\r\n        throw Error(\"error\");\r\n    }\r\n    static createEdge(parent, option = {}) {\r\n        let _parent;\r\n        if (parent instanceof g_object_1.GObject) {\r\n            _parent = parent.svgGroup;\r\n        }\r\n        else if (parent instanceof SVGElement) {\r\n            _parent = parent;\r\n        }\r\n        else {\r\n            _parent = document.getElementById(parent);\r\n        }\r\n        return new g_edge_1.GEdge(_parent, option);\r\n    }\r\n}\r\nexports.GGraph = GGraph;\r\n//}\r\n//# sourceMappingURL=g_graph.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_graph.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_object.js":
/*!***************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_object.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./node_modules/graph-table-svg/dist/html/gui_observer.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst draggable_object_1 = __webpack_require__(/*! ../html/draggable_object */ \"./node_modules/graph-table-svg/dist/html/draggable_object.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\nclass GObject {\r\n    constructor(svgbox, option = {}) {\r\n        this._svgSurface = null;\r\n        /*\r\n        public get shape() : ShapeObjectType {\r\n            return ShapeObjectType.Object;\r\n        }\r\n        */\r\n        this._isInitialized = false;\r\n        this._hasConnectedObserverFunction = false;\r\n        this.groupObserverOption = { attributes: true, childList: true, subtree: true };\r\n        this.pUpdateFunc = () => {\r\n            this.resizeUpdate();\r\n        };\r\n        this.observerFunc = (x) => {\r\n            this.observerFunction(x);\r\n        };\r\n        this._isUpdating = false;\r\n        this.updateAttributes = [\"style\", \"transform\", \"data-speaker-x\", \"data-speaker-y\",\r\n            \"data-width\", \"data-height\", \"data-arrow-neck-width\", \"data-arrow-neck-height\",\r\n            \"data-arrow-head-width\", \"data-arrow-head-height\"];\r\n        CSS.setGraphTableCSS();\r\n        let parentElement = svgbox instanceof SVGElement ? svgbox : document.getElementById(svgbox);\r\n        if (parentElement instanceof SVGSVGElement && !GUIObserver.isObserved(parentElement)) {\r\n            GUIObserver.observeSVGSVG(parentElement);\r\n        }\r\n        /*\r\n        if(!HTMLFunctions.isShow(parentElement)){\r\n            throw Error(\"The parent element of the instance must be displayed when the instance is created\");\r\n        }\r\n        */\r\n        this._svgGroup = SVG.createGroup(parentElement);\r\n        if (typeof (option.class) == \"string\") {\r\n            this._svgGroup.setAttribute(\"class\", option.class);\r\n        }\r\n        else if (typeof (option.class) == \"object\") {\r\n            const newClassName = CSS.getOrCreateClassName(option.class);\r\n            this._svgGroup.setAttribute(\"class\", newClassName);\r\n        }\r\n        else if (this.defaultClassName !== undefined) {\r\n            this._svgGroup.setAttribute(\"class\", this.defaultClassName);\r\n        }\r\n        if (option.style !== undefined) {\r\n            if (typeof (option.style) == \"string\") {\r\n                this._svgGroup.setAttribute(\"style\", option.style);\r\n            }\r\n            else if (typeof (option.style) == \"object\") {\r\n                const newStyleName = CSS.getRuleContentString(CSS.toRuleMap(option.style));\r\n                this._svgGroup.setAttribute(\"class\", newStyleName);\r\n            }\r\n            //this._svgGroup.setAttribute(\"style\", option.style);\r\n        }\r\n        //this.setClassNameOfSVGGroup();\r\n        GObject.setObjectFromObjectID(this);\r\n        this.svgGroup.operator = this;\r\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, this.type);\r\n        const _option = this.initializeOption(option);\r\n        this.createSurface(parentElement, _option);\r\n        if (typeof _option.id !== \"undefined\")\r\n            this.svgGroup.id = _option.id;\r\n        //if(_option.surfaceClass !== undefined && this.svgSurface !== null) this.svgSurface.setAttribute(\"class\", _option.surfaceClass);\r\n        if (_option.width !== undefined) {\r\n            this.width = _option.width;\r\n        }\r\n        if (_option.height !== undefined) {\r\n            this.height = _option.height;\r\n        }\r\n        this._observer = new MutationObserver(this.observerFunc);\r\n        this._observerOption = { attributes: true, childList: true, subtree: true };\r\n        this.hasConnectedObserverFunction = true;\r\n        this.dispatchObjectCreatedEvent();\r\n        this.addResizeEvent();\r\n        this.__x = option.x;\r\n        this.__y = option.y;\r\n        this.__cx = option.cx;\r\n        this.__cy = option.cy;\r\n        const __svg = this.svgGroup;\r\n        __svg.operator = this;\r\n        /*\r\n        if (_option.x !== undefined) this.fixedX = _option.x;\r\n        if (_option.y !== undefined) this.fixedY = _option.y;\r\n        */\r\n        if (this.type == enums_1.ShapeObjectType.Object)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    disconnectObserverFunction() {\r\n        this._observer.disconnect();\r\n    }\r\n    connectObserverFunction() {\r\n        this._observer.observe(this.svgGroup, this._observerOption);\r\n    }\r\n    get hasConnectedObserverFunction() {\r\n        return this._hasConnectedObserverFunction;\r\n    }\r\n    set hasConnectedObserverFunction(b) {\r\n        if (this._hasConnectedObserverFunction != b) {\r\n            if (b) {\r\n                this.connectObserverFunction();\r\n            }\r\n            else {\r\n                this.disconnectObserverFunction();\r\n            }\r\n            this._hasConnectedObserverFunction = b;\r\n        }\r\n    }\r\n    get defaultClassName() {\r\n        return undefined;\r\n    }\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    firstFunctionAfterInitialized() {\r\n        if (this._isInitialized) {\r\n            throw new Error(\"This function is already called\");\r\n        }\r\n        this._isInitialized = true;\r\n        this.update();\r\n        if (this.__cx !== undefined)\r\n            this.cx = this.__cx;\r\n        if (this.__cy !== undefined)\r\n            this.cy = this.__cy;\r\n        if (this.__x !== undefined)\r\n            this.x = this.__x;\r\n        if (this.__y !== undefined)\r\n            this.y = this.__y;\r\n    }\r\n    removeResizeEvent() {\r\n        this.svgGroup.removeEventListener(AttributeNames.resizeName, this.pUpdateFunc);\r\n    }\r\n    addResizeEvent() {\r\n        this.svgGroup.addEventListener(AttributeNames.resizeName, this.pUpdateFunc);\r\n    }\r\n    /*\r\n    private addOnLoadEvent() {\r\n        console.log(\"addon\")\r\n        this.svgGroup.onload = this.onLoadFunction;\r\n        //this.svgGroup.addEventListener(\"load\", this.onLoadFunction);\r\n    }\r\n\r\n    private removeOnLoadEvent() {\r\n        \r\n        this.svgGroup.removeEventListener(\"load\", this.onLoadFunction);\r\n    }\r\n    protected onLoadFunction = () => {\r\n        console.log(\"helo\");\r\n    }\r\n    */\r\n    firstResizeUpdate() {\r\n    }\r\n    /*\r\n    protected _isLoaded = false;\r\n    public get isLoaded(){\r\n        return this._isLoaded;\r\n    }\r\n    */\r\n    resizeUpdate() {\r\n        this.update();\r\n    }\r\n    initializeOption(option) {\r\n        const _option = Object.assign({}, option);\r\n        if (this.svgSurface != null && this.svgSurface.className != null) {\r\n            const width = ElementExtension.getPropertyStyleNumberValue(this.svgSurface, StyleNames.defaultWidth, null);\r\n            const height = ElementExtension.getPropertyStyleNumberValue(this.svgSurface, StyleNames.defaultHeight, null);\r\n            if (width != null)\r\n                _option.width = width;\r\n            if (height != null)\r\n                _option.height = height;\r\n        }\r\n        if (_option.width === undefined)\r\n            _option.width = 25;\r\n        if (_option.height === undefined)\r\n            _option.height = 25;\r\n        if (_option.cx === undefined)\r\n            _option.cx = 0;\r\n        if (_option.cy === undefined)\r\n            _option.cy = 0;\r\n        if (_option.surfaceClass === undefined)\r\n            _option.surfaceClass = DefaultClassNames.defaultSurfaceClass;\r\n        return _option;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        output.class = ElementExtension.gtGetAttributeStringWithUndefined(e, \"class\");\r\n        if (output.class === undefined)\r\n            ElementExtension.gtGetAttributeStringWithUndefined(e, \"group:class\");\r\n        output.surfaceClass = ElementExtension.gtGetAttributeStringWithUndefined(e, \"surface:class\");\r\n        output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, \"group:style\");\r\n        if (e.hasAttribute(\"style\"))\r\n            output.style = ElementExtension.gtGetAttributeStringWithUndefined(e, \"style\");\r\n        output.surfaceStyle = ElementExtension.gtGetAttributeStringWithUndefined(e, \"surface:style\");\r\n        output.cx = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"cx\");\r\n        output.cy = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"cy\");\r\n        output.width = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"width\");\r\n        output.height = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"height\");\r\n        output.x = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"x\");\r\n        output.y = ElementExtension.gtGetAttributeNumberWithUndefined(e, \"y\");\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"cx\");\r\n            e.removeAttribute(\"cy\");\r\n            e.removeAttribute(\"x\");\r\n            e.removeAttribute(\"y\");\r\n            e.removeAttribute(\"class\");\r\n            e.removeAttribute(\"surface:class\");\r\n            e.removeAttribute(\"group:class\");\r\n            e.removeAttribute(\"surface:style\");\r\n            e.removeAttribute(\"group:style\");\r\n            e.removeAttribute(\"style\");\r\n            e.removeAttribute(\"width\");\r\n            e.removeAttribute(\"height\");\r\n        }\r\n        return output;\r\n    }\r\n    get tag() {\r\n        return this._tag;\r\n    }\r\n    set tag(v) {\r\n        this._tag = v;\r\n    }\r\n    get isShow() {\r\n        return HTMLFunctions.isShow(this.svgGroup);\r\n    }\r\n    /**\r\n    セルを表しているSVGGElementを返します。\r\n    */\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get isLocated() {\r\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\r\n    }\r\n    get svgSurface() {\r\n        return this._svgSurface;\r\n    }\r\n    /**\r\nこのVertexのX座標を返します。\r\n*/\r\n    get cx() {\r\n        if (this.isCenterBased) {\r\n            return SVGGExtension.getX(this.svgGroup);\r\n        }\r\n        else {\r\n            return SVGGExtension.getX(this.svgGroup) + (this.width / 2);\r\n        }\r\n    }\r\n    set cx(value) {\r\n        if (this.isCenterBased) {\r\n            if (SVGGExtension.getX(this.svgGroup) != value) {\r\n                SVGGExtension.setX(this.svgGroup, value);\r\n            }\r\n        }\r\n        else {\r\n            SVGGExtension.setX(this.svgGroup, value - (this.width / 2));\r\n        }\r\n    }\r\n    /**\r\n    このVertexのY座標を返します。\r\n    */\r\n    get cy() {\r\n        if (this.isCenterBased) {\r\n            return SVGGExtension.getY(this.svgGroup);\r\n        }\r\n        else {\r\n            return SVGGExtension.getY(this.svgGroup) + (this.height / 2);\r\n        }\r\n    }\r\n    set cy(value) {\r\n        if (this.isCenterBased) {\r\n            if (SVGGExtension.getY(this.svgGroup) != value) {\r\n                SVGGExtension.setY(this.svgGroup, value);\r\n            }\r\n        }\r\n        else {\r\n            SVGGExtension.setY(this.svgGroup, value - (this.height / 2));\r\n        }\r\n    }\r\n    /**\r\n    頂点の幅を返します。\r\n    */\r\n    get width() {\r\n        if (this.hasSize) {\r\n            return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-width\", 0);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    set width(value) {\r\n        if (this.hasSize) {\r\n            if (this.width != value && value != null)\r\n                this.svgGroup.setAttribute(\"data-width\", value.toString());\r\n        }\r\n    }\r\n    /**\r\n    頂点の高さを返します。\r\n    */\r\n    get height() {\r\n        if (this.hasSize) {\r\n            return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-height\", 0);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    set height(value) {\r\n        if (this.hasSize) {\r\n            if (this.height != value && value != null)\r\n                this.svgGroup.setAttribute(\"data-height\", value.toString());\r\n        }\r\n    }\r\n    get fixedX() {\r\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedX\", null);\r\n    }\r\n    set fixedX(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(\"data-fixedX\");\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"data-fixedX\", v.toString());\r\n        }\r\n    }\r\n    get fixedY() {\r\n        return ElementExtension.gtGetAttributeNumber(this.svgGroup, \"data-fixedY\", null);\r\n    }\r\n    set fixedY(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(\"data-fixedY\");\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"data-fixedY\", v.toString());\r\n        }\r\n    }\r\n    get isCenterBased() {\r\n        return true;\r\n    }\r\n    get x() {\r\n        if (this.isCenterBased) {\r\n            return SVGGExtension.getX(this.svgGroup) - (this.width / 2);\r\n        }\r\n        else {\r\n            return SVGGExtension.getX(this.svgGroup);\r\n        }\r\n    }\r\n    get y() {\r\n        if (this.isCenterBased) {\r\n            return this.cy - (this.height / 2);\r\n        }\r\n        else {\r\n            return SVGGExtension.getY(this.svgGroup);\r\n        }\r\n    }\r\n    set x(v) {\r\n        if (this.isCenterBased) {\r\n            SVGGExtension.setX(this.svgGroup, v + (this.width / 2));\r\n        }\r\n        else {\r\n            SVGGExtension.setX(this.svgGroup, v);\r\n        }\r\n    }\r\n    set y(v) {\r\n        if (this.isCenterBased) {\r\n            SVGGExtension.setY(this.svgGroup, v + (this.height / 2));\r\n        }\r\n        else {\r\n            SVGGExtension.setY(this.svgGroup, v);\r\n        }\r\n    }\r\n    get isProhibitionOutOfRange() {\r\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.prohibitionOutOfRange, \"true\");\r\n        return p == \"true\";\r\n    }\r\n    set isProhibitionOutOfRange(v) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.prohibitionOutOfRange, v.toString());\r\n    }\r\n    moveInCanvas() {\r\n        this.x = (this.width / 2) + 10;\r\n        this.y = (this.height / 2) + 10;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Object;\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n    }\r\n    setClassNameOfSVGGroup() {\r\n    }\r\n    observerFunction(x) {\r\n        //throw Error(\"error1\");\r\n        let b = false;\r\n        if (!this.isLocated)\r\n            return;\r\n        for (let i = 0; i < x.length; i++) {\r\n            const p = x[i];\r\n            if (this.updateAttributes.some((v) => v == p.attributeName)) {\r\n                b = true;\r\n            }\r\n            if (p.target == this.svgGroup) {\r\n                if (p.attributeName == \"x\" || p.attributeName == \"y\") {\r\n                    this.dispatchConnectPositionChangedEvent();\r\n                }\r\n            }\r\n            if (p.attributeName == \"transform\") {\r\n                this.dispatchConnectPositionChangedEvent();\r\n            }\r\n        }\r\n        if (b)\r\n            this.update();\r\n    }\r\n    /**\r\n     * この頂点を廃棄します。廃棄された頂点はグラフから取り除かれます。\r\n     */\r\n    dispose() {\r\n    }\r\n    /**\r\n    この頂点が廃棄されていたらTrueを返します。\r\n    */\r\n    get isDisposed() {\r\n        return false;\r\n        //return this.graph == null;\r\n    }\r\n    /**\r\n    このVertexのObjectIDを返します。\r\n    */\r\n    get objectID() {\r\n        const r = this.svgGroup.getAttribute(AttributeNames.objectIDName);\r\n        if (r == null) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            return r;\r\n        }\r\n    }\r\n    createVBACode(id) {\r\n        const lines = [];\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(`End Sub`);\r\n        return lines;\r\n    }\r\n    get VBAObjectNum() {\r\n        return 1;\r\n    }\r\n    dispatchObjectCreatedEvent() {\r\n        var event = document.createEvent(\"HTMLEvents\");\r\n        event.initEvent(AttributeNames.objectCreatedEventName, true, true);\r\n        this.svgGroup.dispatchEvent(event);\r\n    }\r\n    update() {\r\n        if (!this._isInitialized) {\r\n            //throw new Error(\"This instance have not been initialized!\");\r\n        }\r\n        else {\r\n            this._isUpdating = true;\r\n            this._isUpdating = false;\r\n        }\r\n    }\r\n    dispatchConnectPositionChangedEvent() {\r\n        if (this.svgSurface != null) {\r\n            var event = document.createEvent(\"HTMLEvents\");\r\n            event.initEvent(AttributeNames.connectPositionChangedEventName, false, true);\r\n            this.svgGroup.dispatchEvent(event);\r\n        }\r\n    }\r\n    get hasSize() {\r\n        return false;\r\n    }\r\n    static getObjectFromObjectID(id) {\r\n        if (id instanceof SVGElement) {\r\n            if (id.hasAttribute(AttributeNames.objectIDName)) {\r\n                const _id = id.getAttribute(AttributeNames.objectIDName);\r\n                return GObject.getObjectFromObjectID(_id);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (id in this.objectDic) {\r\n                return this.objectDic[id];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    static setObjectFromObjectID(obj) {\r\n        const id = obj.objectID;\r\n        this.objectDic[id] = obj;\r\n    }\r\n    static getObjectFromID(id) {\r\n        for (let key in this.objectDic) {\r\n            if (this.objectDic[key].svgGroup.id == id) {\r\n                return this.objectDic[key];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * グラフの領域を表すRectangleを返します。位置の基準はグラフが追加されているNodeです。\r\n     */\r\n    getRegion() {\r\n        let rect = new vline_1.Rectangle();\r\n        rect.x = this.x;\r\n        rect.y = this.y;\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        return rect;\r\n    }\r\n    movable() {\r\n        draggable_object_1.DraggableObjectFunctions.appendDragFunctionsToDocument();\r\n        draggable_object_1.DraggableObjectFunctions.draggable(this.svgSurface, this.svgGroup);\r\n    }\r\n}\r\nGObject.objectDic = {};\r\nexports.GObject = GObject;\r\n//}\r\n//# sourceMappingURL=g_object.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_object.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_options.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_options.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//}\r\n//# sourceMappingURL=g_options.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_options.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_path_textbox.js":
/*!*********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_path_textbox.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/// <reference path=\"g_vertex.ts\"/>\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nclass GPathTextBox extends g_vertex_1.GVertex {\r\n    //private _svgPath: SVGPathElement;\r\n    get svgPath() {\r\n        return this.svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        /*\r\n        if(this.surface!.className == null && this.surface!.getPropertyStyleValue(\"fill\") == null){\r\n            this.surface!.setPropertyStyleValue(\"fill\", \"white\");\r\n        }\r\n        */\r\n        //this.update();\r\n        if (this.type == enums_1.ShapeObjectType.PathTextBox)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = DefaultClassNames.defaultTextboxPathClass;\r\n        //const _className = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultPathClass);\r\n        //if(_className != null) option.surfaceClass = _className;\r\n        this._svgSurface = GPathTextBox.createSurfacePath(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\r\n    }\r\n    static createSurfacePath(parent, x, y, x2, y2, className, style) {\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n        parent.appendChild(path);\r\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\r\n        if (style !== undefined) {\r\n            if (typeof (style) == \"string\") {\r\n                path.setAttribute(\"style\", style);\r\n            }\r\n            else {\r\n                path.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\r\n            }\r\n        }\r\n        //if(style !== undefined) path.setAttribute(\"style\", style);\r\n        if (typeof (className) == \"string\") {\r\n            path.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            path.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\r\n        }\r\n        //path.setAttribute(\"class\", className)\r\n        /*\r\n    if (className != null) {\r\n        const dashStyle = path.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\r\n    } else {\r\n        if(path.style.stroke == null || path.style.stroke == \"\")path.style.stroke = \"black\";\r\n        if(path.style.fill == null || path.style.fill == \"\")path.style.fill = \"white\";\r\n        if(path.style.strokeWidth == null || path.style.strokeWidth == \"\")path.style.strokeWidth = \"1pt\";\r\n    }\r\n    */\r\n        return path;\r\n    }\r\n    initializeOption(option) {\r\n        const _option = super.initializeOption(option);\r\n        return _option;\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        if (this.isAutoSizeShapeToFitText == enums_1.AutoSizeShapeToFitText.Auto) {\r\n            const textRect = SVGTextBox.getSize(this.svgText);\r\n            //const b = this.svgText.getBBox();\r\n            rect.width = textRect.width;\r\n            rect.height = textRect.height;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        else {\r\n            rect.width = this.width - this.marginPaddingLeft;\r\n            rect.height = this.height - this.marginPaddingTop;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        return rect;\r\n    }\r\n    /*\r\n    private getVBAEditLine(id: number): string {\r\n        const lineColor = VBATranslateFunctions.colorToVBA(this.svgPath.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n        const lineType = GraphTableSVG.msoDashStyle.getLineType(this.svgPath);\r\n        const strokeWidth = parseInt(this.svgPath.getPropertyStyleValueWithDefault(\"stroke-width\", \"4\"));\r\n        const visible = this.svgPath.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n        return ` Call EditLine(obj${id}.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`;\r\n    }\r\n    */\r\n    get type() {\r\n        return \"g-path-textbox\";\r\n    }\r\n    /**\r\n    * 接続部分の座標を返します。\r\n    * @param type\r\n    * @param x\r\n    * @param y\r\n    */\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + wr, this.cy];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - wr, this.cy];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\r\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GPathTextBox = GPathTextBox;\r\n//}\r\n//# sourceMappingURL=g_path_textbox.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_path_textbox.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_rect.js":
/*!*************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_rect.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\n//namespace GraphTableSVG {\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./node_modules/graph-table-svg/dist/html/enum_extension.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GRect extends g_vertex_1.GVertex {\r\n    get svgRectangle() {\r\n        return this._svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this.updateAttributes.push(\"width\");\r\n        this.updateAttributes.push(\"height\");\r\n        //throw Error(\"error2\");\r\n        //this.update();\r\n        if (this.type == enums_1.ShapeObjectType.Rect)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        this._svgSurface = GRect.createRectangle(this.svgGroup, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgRectangle, this.svgText);\r\n    }\r\n    /**\r\n     * SVGRectElementを生成します。\r\n     * @param parent 生成したSVG要素を子に追加する要素\r\n     * @param className 生成するSVG要素のクラス属性名\r\n     * @returns 生成されたSVGRectElement\r\n     */\r\n    static createRectangle(parent, className, style) {\r\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n        parent.appendChild(rect);\r\n        rect.width.baseVal.value = 30;\r\n        rect.height.baseVal.value = 30;\r\n        if (style !== undefined) {\r\n            if (typeof (style) == \"string\") {\r\n                rect.setAttribute(\"style\", style);\r\n            }\r\n            else {\r\n                rect.setAttribute(\"style\", CSS.buildClassNameFromSurfaceClassCSS(style));\r\n            }\r\n        }\r\n        //if(style !== undefined) rect.setAttribute(\"style\", style);\r\n        if (className == null) {\r\n            if (rect.style.stroke == null || rect.style.stroke == \"\")\r\n                rect.style.stroke = \"black\";\r\n            if (rect.style.fill == null || rect.style.fill == \"\")\r\n                rect.style.fill = \"white\";\r\n            if (rect.style.strokeWidth == null || rect.style.strokeWidth == \"\")\r\n                rect.style.strokeWidth = \"1pt\";\r\n        }\r\n        else {\r\n            if (typeof (className) == \"string\") {\r\n                rect.setAttribute(\"class\", className);\r\n            }\r\n            else {\r\n                rect.setAttribute(\"class\", CSS.buildClassNameFromSurfaceClassCSS(className));\r\n            }\r\n            //const dashStyle = rect.getPropertyStyleValue(GraphTableSVG.AttributeNames.Style.msoDashStyleName);\r\n            //if (dashStyle != null) msoDashStyle.setStyle(rect, dashStyle);\r\n            const width = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultWidth, null);\r\n            if (width != null) {\r\n                rect.width.baseVal.value = width;\r\n            }\r\n            const height = ElementExtension.getPropertyStyleNumberValue(rect, StyleNames.defaultHeight, null);\r\n            if (height != null) {\r\n                rect.height.baseVal.value = height;\r\n            }\r\n        }\r\n        return rect;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        return output;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Rect;\r\n    }\r\n    /**\r\n    テキストの領域を返します。\r\n    */\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        rect.x = (-this.width / 2);\r\n        rect.y = (-this.height / 2);\r\n        return rect;\r\n    }\r\n    /**\r\n    頂点の幅を返します。\r\n    */\r\n    get width() {\r\n        return this.svgRectangle.width.baseVal.value;\r\n    }\r\n    set width(value) {\r\n        if (this.width != value)\r\n            this.svgRectangle.setAttribute(\"width\", value.toString());\r\n    }\r\n    /**\r\n    頂点の高さを返します。\r\n    */\r\n    get height() {\r\n        return this.svgRectangle.height.baseVal.value;\r\n    }\r\n    set height(value) {\r\n        if (this.height != value)\r\n            this.svgRectangle.setAttribute(\"height\", value.toString());\r\n    }\r\n    updateSurface() {\r\n        this.svgRectangle.x.baseVal.value = -this.width / 2;\r\n        this.svgRectangle.y.baseVal.value = -this.height / 2;\r\n        //this._observer.disconnect();\r\n        this.hasConnectedObserverFunction = false;\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null) {\r\n            enum_extension_1.setCpmoutedDashArray(this.svgRectangle);\r\n        }\r\n        this.hasConnectedObserverFunction = true;\r\n        //this._observer.observe(this.svgGroup, this._observerOption);\r\n    }\r\n    /**\r\n            * 接続部分の座標を返します。\r\n            * @param type\r\n            * @param x\r\n            * @param y\r\n            */\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + wr, this.cy];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - wr, this.cy];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\r\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n    get shape() {\r\n        return \"msoShapeRectangle\";\r\n    }\r\n}\r\nexports.GRect = GRect;\r\n//}\r\n//# sourceMappingURL=g_rect.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_rect.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_rect_button.js":
/*!********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_rect_button.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst g_rect_1 = __webpack_require__(/*! ./g_rect */ \"./node_modules/graph-table-svg/dist/objects/g_rect.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nclass GRectButton extends g_rect_1.GRect {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        //this.update();\r\n        if (this.type == enums_1.ShapeObjectType.RectButton)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    initializeOption(option) {\r\n        let b = false;\r\n        if (option.width !== undefined || option.height !== undefined) {\r\n            b = true;\r\n        }\r\n        if (option.surfaceClass === undefined) {\r\n            option.surfaceClass = DefaultClassNames.defaultRectButtonSurfaceClass;\r\n        }\r\n        const _option = super.initializeOption(option);\r\n        return _option;\r\n    }\r\n    get defaultClassName() {\r\n        return undefined;\r\n        //return GraphTableSVG.AttributeNames.StyleValue.defaultRectButtonClass;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.RectButton;\r\n    }\r\n}\r\nexports.GRectButton = GRectButton;\r\n//}\r\n//# sourceMappingURL=g_rect_button.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_rect_button.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_table.js":
/*!**************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_table.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Color = __webpack_require__(/*! ../common/color */ \"./node_modules/graph-table-svg/dist/common/color.js\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst CommonFunctions = __webpack_require__(/*! ../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\n//import {GTableOption} from \"../options/attributes_option\"\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\nconst gobject_functions_1 = __webpack_require__(/*! ../logics/gobject_functions */ \"./node_modules/graph-table-svg/dist/logics/gobject_functions.js\");\r\nconst row_1 = __webpack_require__(/*! ./table_helpers/row */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/row.js\");\r\nconst column_1 = __webpack_require__(/*! ./table_helpers/column */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/column.js\");\r\nconst border_row_1 = __webpack_require__(/*! ./table_helpers/border_row */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/border_row.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./node_modules/graph-table-svg/dist/common/vba_functions.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ../interfaces/svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js\");\r\n/**\r\nテーブルを表します。\r\n*/\r\nclass GTable extends g_object_1.GObject {\r\n    /**\r\n     * コンストラクタです。\r\n     */\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this._isNoneMode = false;\r\n        /**\r\n        各行を表す配列を返します。読み取り専用です。\r\n        */\r\n        this._rows = new Array(0);\r\n        /**\r\n        各列を表す配列を返します。読み取り専用です。\r\n        */\r\n        this._columns = new Array(0);\r\n        this._borderRows = new Array(0);\r\n        this._borderColumns = new Array(0);\r\n        //private _cells: Cell[][] = [];\r\n        this.isConstructing = false;\r\n        this._isDrawing = false;\r\n        this._isAutoResized = false;\r\n        this._cellTextObserverFunc = (x) => {\r\n            let b = false;\r\n            let b2 = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (p.type == \"childList\") {\r\n                    b = true;\r\n                    b2 = true;\r\n                }\r\n                for (let j = 0; j < p.addedNodes.length; j++) {\r\n                    const item = p.addedNodes.item(j);\r\n                    if (item != null && item.nodeName == \"#text\") {\r\n                        b = true;\r\n                        b2 = true;\r\n                    }\r\n                }\r\n            }\r\n            if (b2 && !this.isConstructing) {\r\n                //if(this.cellArray.some((v)=>v.isErrorCell)) throw new Error(\"err!\");\r\n                this.fitSizeToOriginalCells(false);\r\n            }\r\n            if (b)\r\n                this.update();\r\n        };\r\n        // #endregion\r\n        this._isTextObserved = false;\r\n        this.isSetSize = false;\r\n        // #endregion\r\n        // #region update\r\n        this.prevShow = false;\r\n        CSS.setGraphTableCSS();\r\n        this._svgHiddenGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgRowBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgRowBorderGroup.setAttribute(\"name\", \"rowBorderGroup\");\r\n        this._svgColumnBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgColumnBorderGroup.setAttribute(\"name\", \"columnBorderGroup\");\r\n        this._svgHiddenGroup.style.visibility = \"hidden\";\r\n        this.svgGroup.appendChild(this.svgHiddenGroup);\r\n        this.svgGroup.appendChild(this.svgRowBorderGroup);\r\n        this.svgGroup.appendChild(this.svgColumnBorderGroup);\r\n        this._cellTextObserver = new MutationObserver(this._cellTextObserverFunc);\r\n        this.updateAttributes = [];\r\n        this.isConstructing = true;\r\n        this.firstSetSize();\r\n        if (option.table === undefined) {\r\n            if (option.rowCount == undefined)\r\n                option.rowCount = 5;\r\n            if (option.columnCount == undefined)\r\n                option.columnCount = 5;\r\n            this.setSize(option.columnCount, option.rowCount);\r\n            if (option.rowHeight != undefined) {\r\n                this.rows.forEach((v) => v.height = option.rowHeight);\r\n            }\r\n            if (option.columnWidth != undefined) {\r\n                this.columns.forEach((v) => v.width = option.columnWidth);\r\n            }\r\n            for (let y = 0; y < this.rowCount; y++) {\r\n                for (let x = 0; x < this.columnCount; x++) {\r\n                    this.updateCellByLogicCell(null, x, y);\r\n                }\r\n            }\r\n            //this.update();\r\n        }\r\n        else {\r\n            this.svgGroup.style.display = \"none\";\r\n            this._isNoneMode = true;\r\n            this.constructFromLogicTable(option.table);\r\n            this._isNoneMode = false;\r\n            this.svgGroup.style.removeProperty(\"display\");\r\n            this.isTextObserved = true;\r\n        }\r\n        //if (option.cx !== undefined) this.cx = option.cx;\r\n        //if (option.cy !== undefined) this.cy = option.cy;\r\n        this.isConstructing = false;\r\n        //this.update();\r\n        if (this.type == enums_1.ShapeObjectType.Table)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    get isNoneMode() {\r\n        return this._isNoneMode;\r\n    }\r\n    get isCenterBased() {\r\n        return false;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        //const widthsStr = e.getPropertyStyleValue(\"--widths\");\r\n        const table = logic_table_1.LogicTable.constructLogicTable(e);\r\n        g_object_1.GObject.constructAttributes(e, removeAttributes, output);\r\n        if (table != null) {\r\n            output.table = table;\r\n        }\r\n        if (output.x !== undefined)\r\n            output.table.x = output.x;\r\n        if (output.y !== undefined)\r\n            output.table.y = output.y;\r\n        if (output.class !== undefined) {\r\n            if (typeof (output.class) == \"string\") {\r\n                output.table.tableClassName = output.class;\r\n            }\r\n            else {\r\n                const newClassName = CSS.getOrCreateClassName(output.class);\r\n                output.table.tableClassName = newClassName;\r\n            }\r\n        }\r\n        while (e.childNodes.length > 0)\r\n            e.removeChild(e.childNodes.item(0));\r\n        return output;\r\n    }\r\n    get svgRowBorderGroup() {\r\n        return this._svgRowBorderGroup;\r\n    }\r\n    get svgColumnBorderGroup() {\r\n        return this._svgColumnBorderGroup;\r\n    }\r\n    get borderRows() {\r\n        return this._borderRows;\r\n    }\r\n    get borderColumns() {\r\n        return this._borderColumns;\r\n    }\r\n    get width() {\r\n        let width = 0;\r\n        this.columns.forEach((v) => width += v.width);\r\n        return width;\r\n    }\r\n    set width(value) {\r\n    }\r\n    get height() {\r\n        let height = 0;\r\n        this.rows.forEach((v) => height += v.height);\r\n        return height;\r\n    }\r\n    set height(value) {\r\n    }\r\n    /**\r\n     * mergeによって見えなくなったBorderなどを格納している特別なSVGGElementです。\r\n     */\r\n    get svgHiddenGroup() {\r\n        return this._svgHiddenGroup;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Table;\r\n    }\r\n    /**\r\n    各行を表す配列を返します。読み取り専用です。\r\n    */\r\n    get rows() {\r\n        return this._rows;\r\n    }\r\n    /**\r\n    各列を表す配列を返します。読み取り専用です。\r\n    */\r\n    get columns() {\r\n        return this._columns;\r\n    }\r\n    /**\r\n    各セルを格納している二次元ジャグ配列を返します。\r\n    */\r\n    get cells() {\r\n        return this.rows.map((v) => v.cells);\r\n    }\r\n    get isDrawing() {\r\n        return this._isDrawing;\r\n    }\r\n    get isAutoResized() {\r\n        return this._isAutoResized;\r\n    }\r\n    set isAutoResized(value) {\r\n        this._isAutoResized = value;\r\n        if (value) {\r\n            this.update();\r\n        }\r\n    }\r\n    get cellTextObserver() {\r\n        return this._cellTextObserver;\r\n    }\r\n    /**\r\n    * テーブルの行方向の単位セルの数を返します。\r\n    * @returns 表の列数\r\n    */\r\n    get columnCount() {\r\n        if (this.cells.length == 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            if (this.rows.length > 2 && (this.rows[0].length != this.rows[1].length))\r\n                throw new Error(\"Invalid length error\");\r\n            return this.rows[0].length;\r\n        }\r\n    }\r\n    /**\r\n    * テーブルの列方向の単位セルの数を返します。\r\n    * @returns 表の行数\r\n    */\r\n    get rowCount() {\r\n        return this.cells.length;\r\n    }\r\n    // #endregion\r\n    // #region property\r\n    /*\r\n     get defaultCellClass(): string | null {\r\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellClass);\r\n     }\r\n     */\r\n    /*\r\n     get defaultBorderClass(): string | null {\r\n         return this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultBorderClass);\r\n     }\r\n     */\r\n    /**\r\n    各セルを表す配列を返します。テーブルの左上のセルから右に向かってインデックスが割り当てられ、\r\n    テーブル右下のセルが配列の最後の値となります。読み取り専用です。\r\n    */\r\n    get cellArray() {\r\n        const arr = new Array(0);\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                arr.push(this.cells[y][x]);\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    /**\r\n    各ボーダーを表す配列を返します。\r\n    ボーダーの順番は未定義です。\r\n    読み取り専用です。\r\n    */\r\n    get borders() {\r\n        const arr = new Array(0);\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                if (arr.indexOf(this.cells[y][x].svgTopBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgTopBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgLeftBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgLeftBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgRightBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgRightBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgBottomBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgBottomBorder);\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    // #endregion\r\n    // #region method\r\n    /**\r\n     * セルの元々のサイズに合わせて表のサイズを調整します。\r\n     * @param allowShrink 各行と各列が現在の幅より短くなることを許す\r\n     */\r\n    fitSizeToOriginalCells(allowShrink) {\r\n        this.rows.forEach((v) => v.fitHeightToOriginalCell(allowShrink));\r\n        this.columns.forEach((v) => v.fitWidthToOriginalCell(allowShrink));\r\n    }\r\n    /**\r\n     * 指定したセル座標のセルを返します。そのようなセルが存在しない場合nullを返します。\r\n     * @param x セルの列番号\r\n     * @param y セルの行番号\r\n     */\r\n    getTryCell(x, y) {\r\n        if (x < 0 || x >= this.columnCount || y < 0 || y >= this.rowCount) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.cells[y][x];\r\n        }\r\n    }\r\n    /**\r\n     * 指定したセル座標範囲の二次元セル配列を返します。\r\n     * @param x 範囲の左上を示す列番号\r\n     * @param y 範囲の左上を示す行番号\r\n     * @param width 範囲に含まれる列数\r\n     * @param height 範囲に含まれる行数\r\n     */\r\n    getRangeCells(x, y, width, height) {\r\n        let cells = new Array(height);\r\n        for (let i = 0; i < cells.length; i++) {\r\n            cells[i] = new Array(0);\r\n            for (let j = 0; j < width; j++) {\r\n                cells[i].push(this.cells[y + i][x + j]);\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n    /**\r\n     * 指定したセル座標範囲のセルを配列でかえします。\r\n     * @param x 範囲の左上を示す列番号\r\n     * @param y 範囲の左上を示す行番号\r\n     * @param width 範囲に含まれる列数\r\n     * @param height 範囲に含まれる行数\r\n     */\r\n    getRangeCellArray(x, y, width, height) {\r\n        let cells = new Array();\r\n        this.getRangeCells(x, y, width, height).forEach((v) => { v.forEach((w) => { cells.push(w); }); });\r\n        return cells;\r\n    }\r\n    /**\r\n    所属しているSVGタグ上でのテーブルの領域を表すRectangleクラスを返します。\r\n    */\r\n    getRegion() {\r\n        let rect = new vline_1.Rectangle();\r\n        rect.x = SVGGExtension.getX(this.svgGroup);\r\n        rect.y = SVGGExtension.getY(this.svgGroup);\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        return rect;\r\n        /*\r\n        const regions = this.cellArray.map((v) => v.region);\r\n        const rect = Rectangle.merge(regions);\r\n        rect.addOffset(this.svgGroup.getX(), this.svgGroup.getY());\r\n        return rect;\r\n        */\r\n    }\r\n    /**\r\n    * 強調セルを全て返します。\r\n    */\r\n    getEmphasizedCells() {\r\n        return this.cellArray.filter((v) => v.isEmphasized);\r\n    }\r\n    /**\r\n    * 表を文字列に変換した結果を返します。\r\n    */\r\n    toPlainText() {\r\n        const plainTable = this.cells.map((v) => v.map((w) => w.toPlainText()));\r\n        const widtharr = new Array(this.columnCount);\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            widtharr[x] = 0;\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const width = plainTable[y][x].length;\r\n                if (widtharr[x] < width)\r\n                    widtharr[x] = width;\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                plainTable[y][x] = CommonFunctions.paddingLeft(plainTable[y][x], widtharr[x], \" \");\r\n            }\r\n        }\r\n        return plainTable.map((v) => v.join(\",\")).join(\"\\n\");\r\n    }\r\n    get isTextObserved() {\r\n        return this._isTextObserved;\r\n    }\r\n    set isTextObserved(b) {\r\n        if (this._isTextObserved != b) {\r\n            if (this._isTextObserved) {\r\n                this.cellTextObserver.disconnect();\r\n            }\r\n            else {\r\n                const option1 = { childList: true, subtree: true };\r\n                this.cellArray.forEach((v) => {\r\n                    this.cellTextObserver.observe(v.svgText, option1);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // #region construct2\r\n    updateCellByLogicCell(table, x, y) {\r\n        const cell = this.cells[y][x];\r\n        //const isShow = HTMLFunctions.(this.svgGroup);\r\n        if (table != null) {\r\n            const cellInfo = table.cells[y][x];\r\n            if (cellInfo != null) {\r\n                CSS.setCSSClass(cell.svgGroup, cellInfo.cellClass);\r\n                if (cellInfo.backgroundClass != null) {\r\n                    CSS.setCSSClass(cell.svgBackground, cellInfo.backgroundClass);\r\n                }\r\n                /*\r\n                if (cellInfo.textClass != null) {\r\n                    CSS.setCSSClass(cell.svgText, cellInfo.textClass);\r\n                }\r\n                */\r\n                gobject_functions_1.createTextElementFromLogicCell(cellInfo, cell.svgText);\r\n                //cellInfo.createTextElement(cell.svgText);\r\n                if (cellInfo.topBorderClass !== undefined) {\r\n                    CSS.setCSSClass(cell.svgTopBorder, cellInfo.topBorderClass);\r\n                }\r\n                if (cellInfo.leftBorderClass !== undefined) {\r\n                    CSS.setCSSClass(cell.svgLeftBorder, cellInfo.leftBorderClass);\r\n                }\r\n                if (cellInfo.rightBorderClass !== undefined) {\r\n                    CSS.setCSSClass(cell.svgRightBorder, cellInfo.rightBorderClass);\r\n                }\r\n                if (cellInfo.bottomBorderClass !== undefined) {\r\n                    CSS.setCSSClass(cell.svgBottomBorder, cellInfo.bottomBorderClass);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * LogicTableからTableを構築します。\r\n     * @param table 入力LogicTable\r\n     */\r\n    constructFromLogicTable(table) {\r\n        if (table.tableClassName != null)\r\n            this.svgGroup.setAttribute(\"class\", table.tableClassName);\r\n        this.setSize(table.columnWidths.length, table.rowHeights.length);\r\n        if (table.x != null)\r\n            this.cx = table.x;\r\n        if (table.y != null)\r\n            this.cy = table.y;\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                this.updateCellByLogicCell(table, x, y);\r\n            }\r\n        }\r\n        //this.fitSizeToOriginalCells();\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            const h = table.rowHeights[y];\r\n            if (h != null)\r\n                this.rows[y].height = h;\r\n        }\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            const w = table.columnWidths[x];\r\n            //this.columns[x].defaultWidth = w;\r\n            if (w != null)\r\n                this.columns[x].width = w;\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const logicCell = table.cells[y][x];\r\n                if (logicCell.connectedColumnCount > 1 || logicCell.connectedRowCount > 1) {\r\n                    if (cell.canMerge(logicCell.connectedColumnCount, logicCell.connectedRowCount)) {\r\n                        cell.merge(logicCell.connectedColumnCount, logicCell.connectedRowCount);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //this.updateNodeRelations();\r\n        if (this.isInitialized) {\r\n            this.update();\r\n        }\r\n    }\r\n    /**\r\n     * 二次元文字列配列から表を作成します。\r\n     * @param table 各セルの文字列\r\n     * @param option 表情報\r\n     * @param option.x 表のx座標\r\n     * @param option.y 表のy座標\r\n     * @param option.rowHeight 各行の縦幅(px)\r\n     * @param option.columnWidth 各列の横幅(px)\r\n     * @param option.tableClassName 表(svgGroup)のクラス属性\r\n     * @param option.isLatexMode Trueのときセルの文字列をLatex表記とみなして描画します。\r\n     *\r\n     */\r\n    construct(table, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        if (option.x == undefined)\r\n            option.x = 0;\r\n        if (option.y == undefined)\r\n            option.y = 0;\r\n        [this.cx, this.cy] = [option.x, option.y];\r\n        this.clear();\r\n        let width = 0;\r\n        table.forEach((v) => { if (v.length > width)\r\n            width = v.length; });\r\n        let height = table.length;\r\n        this.setSize(width, height);\r\n        table.forEach((v, y) => {\r\n            v.forEach((str, x) => {\r\n                SVGTextExtension.setTextContent(this.cells[y][x].svgText, str, option.isLatexMode);\r\n            });\r\n        });\r\n        if (option.rowHeight != undefined) {\r\n            this.rows.forEach((v) => v.height = option.rowHeight);\r\n        }\r\n        if (option.columnWidth != undefined) {\r\n            this.columns.forEach((v) => v.width = option.columnWidth);\r\n        }\r\n    }\r\n    // #endregion\r\n    // #region vba\r\n    /**\r\n     * 表からVBAコードを作成します。\r\n     * @param id\r\n     * @param slide\r\n     */\r\n    createVBACode2(id, slide) {\r\n        const lines = new Array(0);\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        const [main, sub] = this.createVBAMainCode(\"createdSlide\", id);\r\n        lines.push(main);\r\n        lines.push(`End Sub`);\r\n        lines.push(sub);\r\n        return lines;\r\n    }\r\n    /**\r\n     * 現在のテーブルを表すVBAコードを返します。\r\n     */\r\n    createVBAMainCode(slideName, id) {\r\n        const fstLines = [];\r\n        const lines = new Array(0);\r\n        fstLines.push(` Dim tableS As shape`);\r\n        fstLines.push(` Dim table_ As table`);\r\n        //lines.push(` Set tableS = CreateTable(createdSlide, ${table.height}, ${table.width})`);\r\n        fstLines.push(` Set tableS = ${slideName}.Shapes.AddTable(${this.rowCount}, ${this.columnCount})`);\r\n        fstLines.push(` tableS.Left = ${SVGGExtension.getX(this.svgGroup)}`);\r\n        fstLines.push(` tableS.Top = ${SVGGExtension.getY(this.svgGroup)}`);\r\n        //page.Shapes.AddTable(row_, column_)\r\n        fstLines.push(` Set table_ = tableS.table`);\r\n        const tableName = \"table_\";\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            lines.push([` Call EditRow(${tableName}.Rows(${y + 1}), ${this.rows[y].height})`]);\r\n        }\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            lines.push([` Call EditColumn(${tableName}.Columns(${x + 1}), ${this.columns[x].width})`]);\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                let color = Color.createRGBFromColorName(ElementExtension.getPropertyStyleValueWithDefault(cell.svgBackground, \"fill\", \"gray\"));\r\n                //const style = cell.svgBackground.style.fill != null ? VBATranslateFunctions.colorToVBA(cell.svgBackground.style.fill) : \"\";\r\n                vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(lines, this.cells[y][x].svgText, `${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame.TextRange`);\r\n                lines.push([`${tableName}.cell(${y + 1},${x + 1}).Shape.Fill.ForeColor.RGB = RGB(CInt(${color.r}), CInt(${color.g}), CInt(${color.b}))`]);\r\n                //lines.push(` Call EditCell(${tableName}.cell(${y + 1},${x + 1}), \"${cell.svgText.textContent}\", ${color})`);\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(cell.verticalAnchor == null ? \"\" : cell.verticalAnchor);\r\n                const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(cell.horizontalAnchor == null ? \"\" : cell.horizontalAnchor);\r\n                lines.push([` Call EditCellTextFrame(${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame, ${cell.paddingTop}, ${cell.paddingBottom}, ${cell.paddingLeft}, ${cell.paddingRight}, ${vAnchor}, ${hAnchor})`]);\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const upLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgTopBorder, \"stroke\", \"gray\"));\r\n                const upLineStrokeWidth = cell.svgTopBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgTopBorder.style.strokeWidth) : \"\";\r\n                const upLineVisibility = cell.svgTopBorder.style.visibility != null ? vba_functions_1.visible(cell.svgTopBorder.style.visibility) : \"\";\r\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderTop), ${upLineStyle}, ${upLineStrokeWidth}, ${upLineVisibility})`]);\r\n                const leftLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgLeftBorder, \"stroke\", \"gray\"));\r\n                const leftLineStrokeWidth = cell.svgLeftBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgLeftBorder.style.strokeWidth) : \"\";\r\n                const leftLineVisibility = cell.svgLeftBorder.style.visibility != null ? vba_functions_1.visible(cell.svgLeftBorder.style.visibility) : \"\";\r\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderLeft), ${leftLineStyle}, ${leftLineStrokeWidth}, ${leftLineVisibility})`]);\r\n                if (x + 1 == this.columnCount) {\r\n                    const rightLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgRightBorder, \"stroke\", \"gray\"));\r\n                    const rightLineStrokeWidth = cell.svgRightBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgRightBorder.style.strokeWidth) : \"\";\r\n                    const rightLineVisibility = cell.svgRightBorder.style.visibility != null ? vba_functions_1.visible(cell.svgRightBorder.style.visibility) : \"\";\r\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderRight), ${rightLineStyle}, ${rightLineStrokeWidth}, ${rightLineVisibility})`]);\r\n                }\r\n                if (y + 1 == this.rowCount) {\r\n                    const bottomLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(cell.svgBottomBorder, \"stroke\", \"gray\"));\r\n                    const bottomLineStrokeWidth = cell.svgBottomBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgBottomBorder.style.strokeWidth) : \"\";\r\n                    const bottomLineVisibility = cell.svgBottomBorder.style.visibility != null ? vba_functions_1.visible(cell.svgBottomBorder.style.visibility) : \"\";\r\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderBottom), ${bottomLineStyle}, ${bottomLineStrokeWidth}, ${bottomLineVisibility})`]);\r\n                }\r\n            }\r\n        }\r\n        this.cellArray.forEach((v) => {\r\n            if (v.isMaster) {\r\n                const cells = v.cellsInGroup;\r\n                for (let y = 0; y < cells.length; y++) {\r\n                    for (let x = 1; x < cells[y].length; x++) {\r\n                        lines.push([` ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][x].cellY + 1}, ${cells[y][x].cellX + 1})`]);\r\n                    }\r\n                }\r\n                for (let y = 1; y < cells.length; y++) {\r\n                    lines.push([` ${tableName}.Cell(${cells[0][0].cellY + 1}, ${cells[0][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1})`]);\r\n                }\r\n            }\r\n        });\r\n        const x0 = vba_functions_1.VBATranslateFunctions.joinLines(fstLines);\r\n        const [x1, y1] = vba_functions_1.VBATranslateFunctions.splitCode(lines, `${tableName} as Table`, `${tableName}`, id);\r\n        return [vba_functions_1.VBATranslateFunctions.joinLines([x0, x1]), y1];\r\n    }\r\n    // #endregion\r\n    //private _updateCounter = 0;\r\n    // #region dynamic\r\n    /**\r\n     * 新しいセルを作成します。\r\n     */\r\n    /*\r\n    private createCell(cellX: number, cellY: number): Cell {\r\n        const cellClass = this.defaultCellClass == null ? undefined : this.defaultCellClass;\r\n        const borderClass = this.defaultBorderClass == null ? undefined : this.defaultBorderClass;\r\n\r\n        const option: CellOption = { cellClass: cellClass, borderClass: borderClass };\r\n        return new Cell(this, cellX, cellY, option);\r\n    }\r\n    */\r\n    /*\r\n    Dynamic Method\r\n    */\r\n    /**\r\n     * テーブルを削除します。\r\n     * @param svg 表が格納されているSVG要素\r\n     */\r\n    removeTable(svg) {\r\n        if (svg.contains(this.svgGroup)) {\r\n            svg.removeChild(this.svgGroup);\r\n        }\r\n    }\r\n    firstSetSize() {\r\n        this.createRowBorder(0, 1);\r\n        this.createRowBorder(0, 1);\r\n        this.createColumnBorder(0, 1);\r\n        this.createColumnBorder(0, 1);\r\n        this._rows.splice(0, 0, new row_1.CellRow(this, 0, undefined));\r\n        this._rows[0]._appendCell();\r\n        this._columns.splice(0, 0, new column_1.CellColumn(this, 0));\r\n    }\r\n    borderSizeCheck(_w, _h) {\r\n        const w = this.borderRows[0].borders.length;\r\n        const h = this.borderColumns[0].borders.length;\r\n        if (w != _w)\r\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\r\n        if (h != _h)\r\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\r\n        this.borderRows.forEach((v, i) => {\r\n            if (w != v.borders.length)\r\n                throw Error(\"border rows error\");\r\n        });\r\n        this.borderColumns.forEach((v, i) => {\r\n            if (h != v.borders.length)\r\n                throw Error(`border column error ${h} ${v.borders.length} ${i}`);\r\n        });\r\n        //return [w, h];\r\n    }\r\n    /**\r\n     * 表の列数と行数を変更します。\r\n     * @param columnCount 列数\r\n     * @param rowCount 行数\r\n     */\r\n    setSize(columnCount, rowCount) {\r\n        this.clear();\r\n        this.isSetSize = true;\r\n        const borderRowCount = rowCount + 1;\r\n        const borderColumnCount = columnCount + 1;\r\n        if (this.rowCount == 0 || this.columnCount == 0)\r\n            throw Error(\"Table Empty Error\");\r\n        /*\r\n        while (this._borderRows.length < rowCount + 1) {\r\n            const i = this._borderRows.length;\r\n            this.createRowBorder(i);\r\n            this.insertLineIntoColumns(i)\r\n            //this.createRow(i-1);\r\n        }\r\n        */\r\n        while (this.rowCount < rowCount) {\r\n            this.primitiveInsertRow(this.rowCount, false);\r\n        }\r\n        while (this.columnCount < columnCount) {\r\n            this.primitiveInsertColumn(this.columnCount, false);\r\n        }\r\n        /*\r\n        this.borderSizeCheck(1, rowCount);\r\n        while (this._borderColumns.length < columnCount + 1) {\r\n            const i = this._borderColumns.length + 1;\r\n            this.createColumnBorder(i);\r\n            this.insertLineIntoRows(i);\r\n        }\r\n        this.borderSizeCheck(columnCount, rowCount);\r\n\r\n        while (this.columnCount < columnCount) {\r\n            this.createColumn(this.columnCount);\r\n        }\r\n        */\r\n        /*\r\n        while (this.rowCount < rowCount) {\r\n            this.createRow(this.rowCount);\r\n        }\r\n        */\r\n        this.updateNodeRelations();\r\n        this.isSetSize = false;\r\n        /*\r\n        this.renumbering();\r\n        this.update();\r\n        */\r\n    }\r\n    primitiveInsertRow(ithRow, insertTopBorders) {\r\n        let ithRowBorder = insertTopBorders ? ithRow : ithRow + 1;\r\n        if (ithRow < 0 || ithRow > this.rowCount)\r\n            throw new Error(\"primitive insert row error\");\r\n        if (ithRow == 0)\r\n            ithRowBorder = 0;\r\n        if (ithRow == this.rowCount)\r\n            ithRowBorder = this.borderRows.length;\r\n        this.createRowBorder(ithRowBorder);\r\n        this.insertYVerticalBorders(ithRow);\r\n        this.createRow(ithRow);\r\n    }\r\n    primitiveInsertColumn(ithColumn, insertLeftBorders) {\r\n        let ithColumnBorder = insertLeftBorders ? ithColumn : ithColumn + 1;\r\n        if (ithColumn < 0 || ithColumn > this.columnCount)\r\n            throw new Error(\"primitive insert column error\");\r\n        if (ithColumn == 0)\r\n            ithColumnBorder = 0;\r\n        if (ithColumn == this.columnCount)\r\n            ithColumnBorder = this.borderColumns.length;\r\n        this.createColumnBorder(ithColumnBorder);\r\n        this.insertXHorizontalBorders(ithColumn);\r\n        this.createColumn(ithColumn);\r\n    }\r\n    get borderColumnCount() {\r\n        return this.columnCount + 1;\r\n    }\r\n    get borderRowCount() {\r\n        return this.rowCount + 1;\r\n    }\r\n    /**\r\n     * rowCount = 0, columnCount = 0のテーブルを作成します。\r\n     */\r\n    clear() {\r\n        if (this.rowCount == 0 || this.columnCount == 0)\r\n            throw Error(\"Table Empty Error\");\r\n        if (this.columnCount != this.columns.length)\r\n            throw Error(\"clear error\");\r\n        while (this.rowCount > 1) {\r\n            this.primitiveRemoveRow(1, false);\r\n        }\r\n        while (this.columnCount > 1) {\r\n            this.primitiveRemoveColumn(1, false);\r\n        }\r\n        this.updateNodeRelations();\r\n    }\r\n    /*\r\n    public removeCell(i: number) {\r\n        this.cells[i].removeFromTable(false);\r\n        //this.cells.forEach((v) => v.removeFromTable(false));\r\n        this.cells.splice(i, 1);\r\n    }\r\n    */\r\n    removeCellRow(i) {\r\n        this.rows[i]._dispose();\r\n        this.rows.splice(i, 1);\r\n    }\r\n    removeCellColumn(i) {\r\n        this.columns[i]._dispose();\r\n        this.columns.splice(i, 1);\r\n    }\r\n    primitiveRemoveRow(ithRow, removeTopBorders) {\r\n        const ithBorderRow = removeTopBorders ? ithRow : ithRow + 1;\r\n        if (ithRow < 0 || ithRow >= this.rowCount)\r\n            throw new Error(\"error\");\r\n        //this.removeRow(rowi);\r\n        this.removeCellRow(ithRow);\r\n        ;\r\n        this.removeRowBorder(ithBorderRow);\r\n        this.deleteYVerticalBorders(ithRow);\r\n    }\r\n    primitiveRemoveColumn(ithColumn, removeLeftBorders) {\r\n        const ithborderColumn = removeLeftBorders ? ithColumn : ithColumn + 1;\r\n        if (ithColumn < 0 || ithColumn >= this.columnCount)\r\n            throw new Error(\"primitive insert column error\");\r\n        this.removeCellColumn(ithColumn);\r\n        //this.columns[ithColumn].remove(true);\r\n        //this.table.columns.splice(x, 1);\r\n        this.removeColumnBorder(ithborderColumn);\r\n        this.deleteXHorizontalBorders(ithColumn);\r\n    }\r\n    removeColumnBorder(i) {\r\n        //this._borderRows.forEach((v) => v.removeBorder(i));\r\n        this._borderColumns[i].remove();\r\n        this._borderColumns.splice(i, 1);\r\n    }\r\n    removeRowBorder(i) {\r\n        //this._borderColumns.forEach((v) => v.removeBorder(i));\r\n        this._borderRows[i].remove();\r\n        this._borderRows.splice(i, 1);\r\n    }\r\n    removeRow(ithRow) {\r\n        this.primitiveRemoveRow(ithRow, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    removeColumn(ithColumn) {\r\n        this.primitiveRemoveColumn(ithColumn, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    deleteXHorizontalBorders(i) {\r\n        this._borderRows.forEach((v) => {\r\n            v.removeBorder(i);\r\n        });\r\n    }\r\n    deleteYVerticalBorders(i) {\r\n        this._borderColumns.forEach((v) => {\r\n            v.removeBorder(i);\r\n        });\r\n    }\r\n    createColumnBorder(i, borderRowCount = this.borderRows.length - 1) {\r\n        const column = new border_row_1.BorderColumn(this, i, borderRowCount, undefined);\r\n        this._borderColumns.splice(i, 0, column);\r\n    }\r\n    createRowBorder(i, borderColumnCount = this.borderColumns.length - 1) {\r\n        const row = new border_row_1.BorderRow(this, i, borderColumnCount, undefined);\r\n        this._borderRows.splice(i, 0, row);\r\n    }\r\n    createRow(i) {\r\n        //const cell: Cell[] = [];\r\n        //this.cells.splice(i, 0, cell);\r\n        const columnCount = this.columnCount;\r\n        const row = new row_1.CellRow(this, i, undefined);\r\n        this._rows.splice(i, 0, row);\r\n        row._appendCell(columnCount);\r\n        /*\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            cell[x] = this.createCell(x, i);\r\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\r\n        }\r\n        */\r\n    }\r\n    createColumn(i) {\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            this.rows[y]._insertCell(i);\r\n            //const cell = this.createCell(i, y);\r\n            //this.cells[y].splice(i, 0, cell);\r\n        }\r\n        this._columns.splice(i, 0, new column_1.CellColumn(this, i));\r\n    }\r\n    insertXHorizontalBorders(i) {\r\n        this._borderRows.forEach((v) => {\r\n            v.insertBorder(i, undefined);\r\n        });\r\n    }\r\n    insertYVerticalBorders(i) {\r\n        this._borderColumns.forEach((v) => {\r\n            v.insertBorder(i, undefined);\r\n        });\r\n    }\r\n    /**\r\n    * 新しい行をi番目の行に挿入します\r\n    * @param 挿入行の行番号\r\n    */\r\n    insertRow(ithRow) {\r\n        this.primitiveInsertRow(ithRow, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    /**\r\n    * 新しい列をi番目の列に挿入します。\r\n    * @param ithColumn 挿入列の列番号\r\n    */\r\n    insertColumn(ithColumn) {\r\n        this.primitiveInsertColumn(ithColumn, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    /**\r\n     * 新しい行を作って挿入します。\r\n     * @param i 挿入行の行番号\r\n     * @param columnCount 挿入行の列数\r\n     */\r\n    /*\r\n    private insertRowFunction(i: number, columnCount: number = this.columnCount) {\r\n        const cell: Cell[] = [];\r\n\r\n        this.cells.splice(i, 0, cell);\r\n        this._rows.splice(i, 0, new Row(this, i));\r\n        for (let x = 0; x < columnCount; x++) {\r\n            cell[x] = this.createCell(x, i);\r\n            if (this._columns.length <= x) this._columns.push(new Column(this, 0));\r\n        }\r\n\r\n    }\r\n    */\r\n    /**\r\n    新しい列を最後の列に追加します。\r\n    */\r\n    appendColumn() {\r\n        //this.insertColumn(this.columnCount);\r\n        this.primitiveInsertColumn(this.columnCount, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    /**\r\n    新しい行を行の最後に追加します。\r\n    */\r\n    appendRow() {\r\n        //this.insertRow(this.rowCount);\r\n        this.primitiveInsertRow(this.rowCount, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n        //this.update();\r\n    }\r\n    /**\r\n    各セルのサイズを再計算します。\r\n    */\r\n    update() {\r\n        super.update();\r\n        //this._observer.disconnect();\r\n        this.hasConnectedObserverFunction = false;\r\n        const display = ElementExtension.getPropertyStyleValue(this.svgGroup, \"display\");\r\n        const b = HTMLFunctions.isShow(this.svgGroup);\r\n        if (!b) {\r\n            return;\r\n        }\r\n        this._isDrawing = true;\r\n        if (true) {\r\n            this.cellArray.forEach((v) => v.update());\r\n            this.fitSizeToOriginalCells(false);\r\n            this.prevShow = false;\r\n        }\r\n        this.resize();\r\n        this.relocation();\r\n        this._isDrawing = false;\r\n        this.hasConnectedObserverFunction = true;\r\n        //this._observer.observe(this.svgGroup, this.groupObserverOption);\r\n    }\r\n    connectObserverFunction() {\r\n        this._observer.observe(this.svgGroup, this.groupObserverOption);\r\n    }\r\n    /**\r\n     * セル番号を振り直します。\r\n     */\r\n    /*\r\n    private renumbering() {\r\n\r\n        this.rows.forEach((v, i) => v.cellY = i);\r\n        this.columns.forEach((v, i) => v.cellX = i);\r\n        //this.cellArray.forEach((v) => v.updateBorderAttributes());\r\n\r\n    }\r\n    */\r\n    updateNodeRelations() {\r\n        this.rows.forEach((v, i) => v.cellY = i);\r\n        this.columns.forEach((v, i) => v.cellX = i);\r\n        this.borderRows.forEach((v, i) => {\r\n            if (v.borders.length != this.columnCount) {\r\n                throw new Error(`error row ${i} ${v.borders.length} ${this.columnCount}`);\r\n            }\r\n        });\r\n        this.borderColumns.forEach((v, i) => {\r\n            if (v.borders.length != this.rowCount) {\r\n                throw new Error(`error column ${i} ${v.borders.length} ${this.rowCount}`);\r\n            }\r\n        });\r\n        this.cellArray.forEach((v) => v.updateNodeRelations());\r\n    }\r\n    /**\r\n     * サイズを再計算します。\r\n     */\r\n    resize() {\r\n        this.rows.forEach((v) => v.resize());\r\n        this.columns.forEach((v) => v.resize());\r\n    }\r\n    /**\r\n     * 各セルの位置を再計算します。\r\n     */\r\n    relocation() {\r\n        let height = 0;\r\n        this.rows.forEach(function (x, i, arr) {\r\n            x.setY(height);\r\n            height += x.height;\r\n        });\r\n        let width = 0;\r\n        this.columns.forEach(function (x, i, arr) {\r\n            x.setX(width);\r\n            width += x.width;\r\n        });\r\n        this.cellArray.forEach((v) => v.relocation());\r\n        //this.rows.forEach((v) => v.relocation());\r\n    }\r\n}\r\nexports.GTable = GTable;\r\n//}\r\n//# sourceMappingURL=g_table.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_table.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_textbox.js":
/*!****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_textbox.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"g_object.ts\"/>\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst enums_2 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./node_modules/graph-table-svg/dist/html/enum_extension.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst SVGElementExtension = __webpack_require__(/*! ../interfaces/svg_element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_element_extension.js\");\r\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js\");\r\n//namespace GraphTableSVG {\r\nclass GTextBox extends g_object_1.GObject {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        //private isFixTextSize: boolean = false;\r\n        this.surfaceAttributes = [];\r\n        this._isSpecialTextBox = false;\r\n        this._minimumWidth = 10;\r\n        this._minimumHeight = 10;\r\n        this.textObserverFunc = (x) => {\r\n            if (!this.isLocated)\r\n                return;\r\n            let b = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (GTextBox.updateTextAttributes.some((v) => v == p.attributeName)) {\r\n                    b = true;\r\n                }\r\n                if (p.attributeName == null) {\r\n                    b = true;\r\n                }\r\n            }\r\n            if (b)\r\n                this.update();\r\n        };\r\n        /*\r\n        this._svgText = GTextBox.createSVGText(this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultTextClass));\r\n        this.svgGroup.appendChild(this.svgText);\r\n        this._textObserver = new MutationObserver(this.textObserverFunc);\r\n        const option2: MutationObserverInit = { childList: true, attributes: true, subtree: true };\r\n        this._textObserver.observe(this.svgText, option2);\r\n        */\r\n        const _option = this.initializeOption(option);\r\n        const textClass = CSS.createCSSClass(_option.textClass);\r\n        const styleClass = CSS.createCSSClass(_option.textStyle);\r\n        this._svgText = GTextBox.createSVGText(textClass, styleClass);\r\n        this.svgGroup.appendChild(this.svgText);\r\n        this._textObserver = new MutationObserver(this.textObserverFunc);\r\n        const option2 = { childList: true, attributes: true, subtree: true };\r\n        this._textObserver.observe(this.svgText, option2);\r\n        if (typeof _option.text == \"string\") {\r\n            SVGTextExtension.setTextContent(this.svgText, _option.text);\r\n        }\r\n        else if (Array.isArray(_option.text)) {\r\n            SVGTextBox.constructSVGTextByHTMLElements(this.svgText, _option.text, false);\r\n        }\r\n        else {\r\n        }\r\n        const b = ElementExtension.getPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText);\r\n        if (b === undefined && typeof (_option.style) == \"object\") {\r\n            const style = _option.style;\r\n            if (style.autoSizeShapeToFitText !== undefined) {\r\n                this.isAutoSizeShapeToFitText = style.autoSizeShapeToFitText;\r\n            }\r\n        }\r\n        //if(_option.x !== undefined) this.x = _option.x;\r\n        //if(_option.y !== undefined) this.y = _option.y;\r\n        if (this.type == enums_1.ShapeObjectType.Object)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    initializeOption(option) {\r\n        let b = false;\r\n        if (option.width !== undefined || option.height !== undefined) {\r\n            b = true;\r\n        }\r\n        const _option = super.initializeOption(option);\r\n        /*\r\n        if(_option.class === undefined){\r\n            _option.class = { isAutoSizeShapeToFitText : true, verticalAnchor : VerticalAnchor.Middle, horizontalAnchor : HorizontalAnchor.Center }\r\n        }\r\n        if(typeof(_option.class) == \"object\" ){\r\n            if(_option.class.isAutoSizeShapeToFitText === undefined) _option.class.isAutoSizeShapeToFitText = true;\r\n            if(_option.class.verticalAnchor === undefined) _option.class.verticalAnchor = VerticalAnchor.Middle;\r\n            if(_option.class.horizontalAnchor === undefined) _option.class.horizontalAnchor = HorizontalAnchor.Center;\r\n        }\r\n        */\r\n        //if (b && _option.isAutoSizeShapeToFitText === undefined) _option.isAutoSizeShapeToFitText = false;\r\n        //if (_option.isAutoSizeShapeToFitText === undefined) _option.isAutoSizeShapeToFitText = true;\r\n        //if (_option.verticalAnchor === undefined) _option.verticalAnchor = VerticalAnchor.Middle;\r\n        //if (_option.horizontalAnchor === undefined) _option.horizontalAnchor = HorizontalAnchor.Center;\r\n        if (_option.textClass === undefined)\r\n            _option.textClass = DefaultClassNames.defaultTextClass;\r\n        return _option;\r\n    }\r\n    /**\r\n    * SVGTextElementを生成します。\r\n    * @param className 生成するSVG要素のクラス属性名\r\n    * @returns 生成されたSVGTextElement\r\n    */\r\n    static createSVGText(className, style) {\r\n        const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n        _svgText.setAttribute(AttributeNames.objectIDName, (SVG.getNewID()).toString());\r\n        if (style !== undefined) {\r\n            _svgText.setAttribute(\"style\", style);\r\n        }\r\n        //_svgText.style.textAnchor = \"middle\";\r\n        if (className == null) {\r\n            if (_svgText.style.fill == null || _svgText.style.fill == \"\")\r\n                _svgText.style.fill = \"black\";\r\n            if (_svgText.style.fontSize == null || _svgText.style.fontSize == \"\")\r\n                _svgText.style.fontSize = \"14px\";\r\n            if (_svgText.style.fontWeight == null || _svgText.style.fontWeight == \"\")\r\n                _svgText.style.fontWeight = \"bold\";\r\n            if (_svgText.style.fontFamily == null || _svgText.style.fontFamily == \"\")\r\n                _svgText.style.fontFamily = 'Times New Roman';\r\n            if (_svgText.style.getPropertyValue(StyleNames.marginLeft) == \"\")\r\n                SVGTextExtension.setMarginLeft(_svgText, 10);\r\n            if (_svgText.style.getPropertyValue(StyleNames.marginRight) == \"\")\r\n                SVGTextExtension.setMarginRight(_svgText, 10);\r\n            if (_svgText.style.getPropertyValue(StyleNames.marginTop) == \"\")\r\n                SVGTextExtension.setMarginTop(_svgText, 10);\r\n            if (_svgText.style.getPropertyValue(StyleNames.marginBottom) == \"\")\r\n                SVGTextExtension.setMarginBottom(_svgText, 10);\r\n        }\r\n        else {\r\n            if (className != undefined) {\r\n                _svgText.setAttribute(\"class\", className);\r\n            }\r\n            //_svgText.className = className;\r\n        }\r\n        return _svgText;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_object_1.GObject.constructAttributes(e, removeAttributes, output);\r\n        //output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(AttributeNames.Style.autoSizeShapeToFitText);\r\n        const textChild = HTMLFunctions.getChildByNodeName(e, \"text\");\r\n        output.textClass = ElementExtension.gtGetAttributeStringWithUndefined(e, \"text:class\");\r\n        output.textStyle = ElementExtension.gtGetAttributeStringWithUndefined(e, \"text:style\");\r\n        if (e.hasAttribute(\"text\")) {\r\n            output.text = e.getAttribute(\"text\");\r\n        }\r\n        else if (e.children.length > 0) {\r\n            const tNodes = HTMLFunctions.getTNodes(e);\r\n            if (tNodes != null) {\r\n                tNodes.forEach((v) => v.remove());\r\n                output.text = tNodes;\r\n            }\r\n        }\r\n        else if (textChild != null) {\r\n        }\r\n        else if (e.innerHTML.length > 0) {\r\n            output.text = e.innerHTML;\r\n        }\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"text\");\r\n            e.removeAttribute(\"text:class\");\r\n            e.removeAttribute(\"text:style\");\r\n            e.style.removeProperty(StyleNames.autoSizeShapeToFitText);\r\n        }\r\n        return output;\r\n    }\r\n    get svgText() {\r\n        return this._svgText;\r\n    }\r\n    get horizontalAnchor() {\r\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.HorizontalAnchor, \"center\");\r\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\r\n    }\r\n    /**\r\n    テキストの水平方向の配置設定を設定します。\r\n    */\r\n    set horizontalAnchor(value) {\r\n        if (this.horizontalAnchor != value)\r\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.HorizontalAnchor, value);\r\n    }\r\n    /**\r\n    テキストの垂直方向の配置設定を返します。\r\n    */\r\n    get verticalAnchor() {\r\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.VerticalAnchor, \"middle\");\r\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\r\n    }\r\n    /**\r\n    テキストの垂直方向の配置設定を設定します。\r\n    */\r\n    set verticalAnchor(value) {\r\n        if (this.verticalAnchor != value)\r\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.VerticalAnchor, value);\r\n    }\r\n    /**\r\n     * このVertexがテキストに合わせてサイズを変える場合Trueを返します。\r\n     */\r\n    get isAutoSizeShapeToFitText() {\r\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.autoSizeShapeToFitText, \"semi-auto\");\r\n        if (b == \"auto\") {\r\n            return \"auto\";\r\n        }\r\n        else if (b == \"none\") {\r\n            return \"none\";\r\n        }\r\n        else {\r\n            return \"semi-auto\";\r\n        }\r\n        /*\r\n        if (b == undefined) {\r\n            return false;\r\n        } else {\r\n            return b;\r\n        }\r\n        */\r\n    }\r\n    set isAutoSizeShapeToFitText(value) {\r\n        ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.autoSizeShapeToFitText, value);\r\n        //this.svgGroup.setPropertyStyleValue(AttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\r\n    }\r\n    update() {\r\n        super.update();\r\n        this._isUpdating = true;\r\n        if (!this.isShow)\r\n            return;\r\n        //this._observer.disconnect();\r\n        this.hasConnectedObserverFunction = false;\r\n        if (this.svgText == null) {\r\n            throw new TypeError(\"svgText is null\");\r\n        }\r\n        SVGTextBox.sortText(this.svgText, this.horizontalAnchor, false);\r\n        if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.Auto) {\r\n            this.updateToFitText(true);\r\n            this.updateToFitText(false);\r\n        }\r\n        else if (this.isAutoSizeShapeToFitText == enums_2.AutoSizeShapeToFitText.SemiAuto) {\r\n            const textRect = SVGTextBox.getSize(this.svgText);\r\n            const width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\r\n            const height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\r\n            if (this.width < width) {\r\n                this.updateToFitText(true);\r\n            }\r\n            if (this.height < height) {\r\n                this.updateToFitText(false);\r\n            }\r\n            //this.innerRectangle\r\n        }\r\n        this.updateSurface();\r\n        if (this.fixedX != null && Math.abs(this.x - this.fixedX) > 20) {\r\n            this.x = this.fixedX;\r\n        }\r\n        if (this.fixedY != null && Math.abs(this.y - this.fixedY) > 20) {\r\n            this.y = this.fixedY;\r\n        }\r\n        /*\r\n        if(this.fixedY != null){\r\n            this.y = this.fixedY;\r\n        }\r\n        */\r\n        if (!this._isSpecialTextBox) {\r\n            SVGTextExtension.gtSetXY(this.svgText, this.innerRectangleWithoutMargin, this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\r\n        }\r\n        //Graph.setXY(this.svgText, this.innerRectangle, vAnchor, hAnchor);\r\n        this._isUpdating = false;\r\n        //this._observer.observe(this.svgGroup, this.groupObserverOption);\r\n        this.hasConnectedObserverFunction = true;\r\n    }\r\n    updateSurface() {\r\n        //this._observer.disconnect();\r\n        this.hasConnectedObserverFunction = false;\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null && this.svgSurface != null) {\r\n            enum_extension_1.setCpmoutedDashArray(this.svgSurface);\r\n        }\r\n        //this._observer.observe(this.svgGroup, this._observerOption);\r\n        this.hasConnectedObserverFunction = true;\r\n    }\r\n    updateToFitText(isWidth) {\r\n        //this.isFixTextSize = true;\r\n        //const box = this.svgText.getBBox();\r\n        const textRect = SVGTextBox.getSize(this.svgText);\r\n        const textWidth = textRect.width < this._minimumWidth ? this._minimumWidth : textRect.width;\r\n        const textHeight = textRect.height < this._minimumHeight ? this._minimumHeight : textRect.height;\r\n        if (isWidth) {\r\n            this.width = textWidth + this.marginPaddingLeft + this.marginPaddingRight;\r\n        }\r\n        else {\r\n            this.height = textHeight + this.marginPaddingTop + this.marginPaddingBottom;\r\n        }\r\n    }\r\n    get marginPaddingTop() {\r\n        return SVGTextExtension.getMarginTop(this.svgText) + SVGElementExtension.getPaddingTop(this.svgGroup);\r\n    }\r\n    get marginPaddingLeft() {\r\n        return SVGTextExtension.getMarginLeft(this.svgText) + SVGElementExtension.getPaddingLeft(this.svgGroup);\r\n    }\r\n    get marginPaddingRight() {\r\n        return SVGTextExtension.getMarginRight(this.svgText) + SVGElementExtension.getPaddingRight(this.svgGroup);\r\n    }\r\n    get marginPaddingBottom() {\r\n        return SVGTextExtension.getMarginBottom(this.svgText) + SVGElementExtension.getPaddingBottom(this.svgGroup);\r\n    }\r\n    get paddingTop() {\r\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\r\n    }\r\n    set paddingTop(value) {\r\n        SVGElementExtension.setPaddingTop(this.svgGroup, value);\r\n    }\r\n    get paddingLeft() {\r\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\r\n    }\r\n    set paddingLeft(value) {\r\n        SVGElementExtension.setPaddingLeft(this.svgGroup, value);\r\n    }\r\n    get paddingRight() {\r\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\r\n    }\r\n    set paddingRight(value) {\r\n        SVGElementExtension.setPaddingRight(this.svgGroup, value);\r\n    }\r\n    get paddingBottom() {\r\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\r\n    }\r\n    set paddingBottom(value) {\r\n        SVGElementExtension.setPaddingBottom(this.svgGroup, value);\r\n    }\r\n    get marginTop() {\r\n        return SVGTextExtension.getMarginTop(this.svgText);\r\n    }\r\n    set marginTop(value) {\r\n        SVGTextExtension.setMarginTop(this.svgText, value);\r\n    }\r\n    get marginLeft() {\r\n        return SVGTextExtension.getMarginLeft(this.svgText);\r\n    }\r\n    set marginLeft(value) {\r\n        SVGTextExtension.setMarginLeft(this.svgText, value);\r\n    }\r\n    get marginRight() {\r\n        return SVGTextExtension.getMarginRight(this.svgText);\r\n    }\r\n    set marginRight(value) {\r\n        SVGTextExtension.setMarginRight(this.svgText, value);\r\n    }\r\n    get marginBottom() {\r\n        return SVGTextExtension.getMarginBottom(this.svgText);\r\n    }\r\n    set marginBottom(value) {\r\n        SVGTextExtension.setMarginBottom(this.svgText, value);\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = 0;\r\n        rect.height = 0;\r\n        rect.x = 0;\r\n        rect.y = 0;\r\n        return rect;\r\n    }\r\n    get innerRectangleWithoutMargin() {\r\n        const rect = this.innerRectangle;\r\n        rect.width = rect.width - this.marginPaddingLeft - this.marginPaddingRight;\r\n        rect.height = rect.height - this.marginPaddingTop - this.marginPaddingBottom;\r\n        rect.x = rect.x + this.marginPaddingLeft;\r\n        rect.y = rect.y + this.marginPaddingTop;\r\n        return rect;\r\n    }\r\n    /*\r\n    get marginLeft(): number {\r\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-left\", 0);\r\n    }\r\n    set marginLeft(value: number) {\r\n        this.svgText.setPropertyStyleValue(\"--margin-left\", value.toString());\r\n    }\r\n    get marginTop(): number {\r\n        return this.svgText.getPropertyStyleNumberValue(\"--margin-top\", 0);\r\n    }\r\n    set marginTop(value: number) {\r\n        this.svgText.setPropertyStyleValue(\"--margin-top\", value.toString());\r\n    }\r\n    */\r\n    get svgElements() {\r\n        const r = [];\r\n        r.push(this.svgGroup);\r\n        r.push(this.svgText);\r\n        return r;\r\n    }\r\n    hasDescendant(obj) {\r\n        const ids = this.svgElements.map((v) => v.getAttribute(AttributeNames.objectIDName)).filter((v) => v != null);\r\n        const id = obj.getAttribute(AttributeNames.objectIDName);\r\n        return ids.some((v) => v == id);\r\n    }\r\n    get hasSize() {\r\n        return true;\r\n    }\r\n    get msoDashStyle() {\r\n        if (this.svgSurface != null) {\r\n            const dashStyle = ElementExtension.getPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName);\r\n            if (dashStyle != null) {\r\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set msoDashStyle(value) {\r\n        if (this.svgSurface != null) {\r\n            if (enums_1.msoDashStyle == null) {\r\n                this.svgSurface.style.removeProperty(StyleNames.msoDashStyleName);\r\n            }\r\n            else {\r\n                ElementExtension.setPropertyStyleValue(this.svgSurface, StyleNames.msoDashStyleName, value);\r\n            }\r\n        }\r\n    }\r\n}\r\nGTextBox.updateTextAttributes = [\"style\"];\r\nexports.GTextBox = GTextBox;\r\n//}\r\n//# sourceMappingURL=g_textbox.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_textbox.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/g_vertex.js":
/*!***************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/g_vertex.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/// <reference path=\"g_textbox.ts\"/>\r\n//namespace GraphTableSVG {\r\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./node_modules/graph-table-svg/dist/common/vba_functions.js\");\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\n//import { GGraph } from \"./g_graph\"\r\nconst virtual_tree_1 = __webpack_require__(/*! ./graph_helpers/virtual_tree */ \"./node_modules/graph-table-svg/dist/objects/graph_helpers/virtual_tree.js\");\r\nconst enum_extension_1 = __webpack_require__(/*! ../html/enum_extension */ \"./node_modules/graph-table-svg/dist/html/enum_extension.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nclass GVertex extends g_textbox_1.GTextBox {\r\n    /*\r\n    protected setClassNameOfSVGGroup() {\r\n        const parent = this.svgGroup.parentElement;\r\n        if (parent instanceof SVGElement) {\r\n            const className = GraphTableSVG.AttributeNames.StyleValue.defaultVertexClass;\r\n            if (className != null && !this.svgGroup.hasAttribute(\"class\") ) {\r\n                this.svgGroup.setAttribute(\"class\", className);\r\n            }\r\n        }\r\n    }\r\n    */\r\n    get defaultClassName() {\r\n        return DefaultClassNames.defaultVertexClass;\r\n    }\r\n    /**\r\n    * 接続部分のXY座標を返します。\r\n    * @param type\r\n    * @param x\r\n    * @param y\r\n    */\r\n    getLocation(type, x, y) {\r\n        return [this.cx, this.cy];\r\n    }\r\n    /**\r\n     * 与えられた位置から伸びた辺に対応する接続位置を返します。\r\n     * @param type\r\n     * @param x\r\n     * @param y\r\n     */\r\n    getConnectorType(type, x, y) {\r\n        if (type == enums_1.ConnectorPosition.Auto) {\r\n            return this.getAutoPosition(x, y);\r\n        }\r\n        else {\r\n            return type;\r\n        }\r\n    }\r\n    /**\r\n     * 与えられた位置から伸びた辺に対応する接続位置がAutoだったときの実際の接続位置を返します。\r\n     * @param x\r\n     * @param y\r\n     */\r\n    getAutoPosition(x, y) {\r\n        return enums_1.ConnectorPosition.Top;\r\n    }\r\n    /**\r\n    入辺配列を返します。\r\n    */\r\n    get outcomingEdges() {\r\n        const p = JSON.parse(ElementExtension.gtGetAttribute(this.svgGroup, \"outcoming-edges\", \"[]\"));\r\n        const p2 = p.map((v) => g_object_1.GObject.getObjectFromObjectID(v.toString()));\r\n        return p2;\r\n    }\r\n    /*\r\n    set outcomingEdges(edges : PPEdge[]) {\r\n        const mes = edges.map((v)=>v.objectID).join(\",\");\r\n        this.svgGroup.setAttribute(\"outcoming-edges\", mes);\r\n    }\r\n    */\r\n    /**\r\n    出辺配列を返します。\r\n    */\r\n    get incomingEdges() {\r\n        const p = JSON.parse(ElementExtension.gtGetAttribute(this.svgGroup, \"incoming-edges\", \"[]\"));\r\n        const p2 = p.map((v) => g_object_1.GObject.getObjectFromObjectID(v.toString()));\r\n        return p2;\r\n    }\r\n    /*\r\n    set incomingEdges(edges : PPEdge[]) {\r\n        const mes = edges.map((v)=>v.objectID).join(\",\");\r\n        this.svgGroup.setAttribute(\"incoming-edges\", mes);\r\n    }\r\n    */\r\n    /**\r\n     * 出辺を挿入します。\r\n     * @param edge\r\n     * @param insertIndex\r\n     */\r\n    insertOutcomingEdge(edge, insertIndex = this.outcomingEdges.length) {\r\n        const p = this.outcomingEdges.indexOf(edge);\r\n        if (p != -1) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            const edges = this.outcomingEdges;\r\n            edges.splice(insertIndex, 0, edge);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"outcoming-edges\", newEdges);\r\n            if (edge.beginVertex != this) {\r\n                edge.beginVertex = this;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 出辺を削除します。\r\n     * @param edge\r\n     */\r\n    removeOutcomingEdge(edge) {\r\n        const p = this.outcomingEdges.indexOf(edge);\r\n        if (p != null) {\r\n            const edges = this.outcomingEdges;\r\n            edges.splice(p, 1);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"outcoming-edges\", newEdges);\r\n            if (edge.beginVertex == this) {\r\n                edge.beginVertex = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * 入辺を挿入します。\r\n    * @param edge\r\n    * @param insertIndex\r\n    */\r\n    insertIncomingEdge(edge, insertIndex = this.incomingEdges.length) {\r\n        const p = this.incomingEdges.indexOf(edge);\r\n        if (p != -1) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            const edges = this.incomingEdges;\r\n            edges.splice(insertIndex, 0, edge);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"incoming-edges\", newEdges);\r\n            if (edge.endVertex != this) {\r\n                edge.endVertex = this;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 入辺を削除します。\r\n     * @param edge\r\n     */\r\n    removeIncomingEdge(edge) {\r\n        const p = this.incomingEdges.indexOf(edge);\r\n        if (p != null) {\r\n            const edges = this.incomingEdges;\r\n            edges.splice(p, 1);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"incoming-edges\", newEdges);\r\n            if (edge.endVertex == this) {\r\n                edge.endVertex = null;\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        while (this.incomingEdges.length > 0) {\r\n            this.removeIncomingEdge(this.incomingEdges[0]);\r\n        }\r\n        while (this.outcomingEdges.length > 0) {\r\n            this.removeOutcomingEdge(this.outcomingEdges[0]);\r\n        }\r\n    }\r\n    /**\r\n    * 親Vertex配列を返します。\r\n    */\r\n    getParents() {\r\n        return this.incomingEdges.filter((v) => v.beginVertex != null).map((v) => v.beginVertex);\r\n    }\r\n    /**\r\n    親との間の辺を返します。\r\n    */\r\n    get parentEdge() {\r\n        if (this.incomingEdges.length == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.incomingEdges[0];\r\n        }\r\n    }\r\n    /**\r\n    このVertexの親を返します。\r\n    */\r\n    get parent() {\r\n        if (this.parentEdge == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.parentEdge.beginVertex;\r\n        }\r\n    }\r\n    /**\r\n    このVertexに親がいないときTrueを返します。\r\n    */\r\n    get isNoParent() {\r\n        return this.parent == null;\r\n    }\r\n    /**\r\n    出辺配列を返します。\r\n    */\r\n    get children() {\r\n        return this.outcomingEdges.filter((v) => v.endVertex != null).map((v) => v.endVertex);\r\n    }\r\n    /**\r\n    このVertexが葉のときTrueを返します。\r\n    */\r\n    get isLeaf() {\r\n        return this.outcomingEdges.length == 0;\r\n    }\r\n    /**\r\n     * このVertexを頂点とする仮想部分木を作成します。\r\n     */\r\n    //get tree(): VirtualTree {\r\n    //    return new VirtualTree(this);\r\n    //}\r\n    createVirtualTree(excludedEdgeDic) {\r\n        return new virtual_tree_1.VirtualTree(this, excludedEdgeDic);\r\n    }\r\n    /**\r\n    このVertexの領域を返します。\r\n    */\r\n    get region() {\r\n        const p = new vline_1.Rectangle();\r\n        p.x = this.cx - (this.width / 2);\r\n        p.y = this.cy - (this.height / 2);\r\n        p.width = this.width;\r\n        p.height = this.height;\r\n        return p;\r\n    }\r\n    get shape() {\r\n        return \"NONE\";\r\n    }\r\n    /**\r\n             *\r\n             * @param id\r\n             */\r\n    createVBACode(id) {\r\n        const lines = [];\r\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"fill\", \"gray\"));\r\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n        const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(this.verticalAnchor);\r\n        const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(this.horizontalAnchor);\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        lines.push(` Dim obj As Shape`);\r\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.x}, ${this.y}, ${this.width}, ${this.height})`);\r\n        lines.push(` Call EditTextFrame(obj.TextFrame, ${this.marginPaddingTop}, ${this.marginPaddingBottom}, ${this.marginPaddingLeft}, ${this.marginPaddingRight}, false, ppAutoSizeNone)`);\r\n        lines.push(` Call EditAnchor(obj.TextFrame, ${vAnchor}, ${hAnchor})`);\r\n        vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(this.svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\r\n        //const adjustments = this.VBAAdjustments;\r\n        lines.push(this.getVBAEditLine());\r\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\r\n        this.VBAAdjustments.forEach((v, i) => {\r\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\r\n        });\r\n        lines.push(`End Sub`);\r\n        //sub.push([` Call EditTextEffect(nodes(${i}).TextEffect, ${fontSize}, \"${fontFamily}\")`]);\r\n        return lines;\r\n    }\r\n    /**\r\n     * VBAコードでのこの図形を表すShape図形のVBAAdjustmentsプロパティを表します。\r\n     */\r\n    get VBAAdjustments() {\r\n        return [];\r\n    }\r\n    getVBAEditLine() {\r\n        const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke\", \"gray\"));\r\n        const lineType = enum_extension_1.getLineType(this.svgSurface);\r\n        const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"stroke-width\", \"4\"));\r\n        const visible = ElementExtension.getPropertyStyleValueWithDefault(this.svgSurface, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n        return ` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`;\r\n    }\r\n    get graph() {\r\n        const v = this.svgGroup.parentElement;\r\n        if (v != null && v instanceof SVGGElement && v.hasAttribute(AttributeNames.objectIDName)) {\r\n            const id = v.getAttribute(AttributeNames.objectIDName);\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(id);\r\n            if (obj instanceof g_object_1.GObject) {\r\n                return obj;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexports.GVertex = GVertex;\r\n//}\r\n//# sourceMappingURL=g_vertex.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/g_vertex.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/graph_helpers/graph_arrangement.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/graph_helpers/graph_arrangement.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TreeArrangement = __webpack_require__(/*! ./tree_arangement */ \"./node_modules/graph-table-svg/dist/objects/graph_helpers/tree_arangement.js\");\r\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nvar GraphArrangement;\r\n(function (GraphArrangement) {\r\n    function standardTreeWidthArrangement(graph) {\r\n        const [xi, yi] = TreeArrangement.getXYIntervals(graph);\r\n        const direction = graph.direction;\r\n        const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\r\n        /*\r\n        const isTrie = graph.edges.every((v)=>{\r\n            return v.svgTextPath.textContent == null || v.svgTextPath.textContent.length <= 1;\r\n        })\r\n        */\r\n        const externalEdges = createExternalEdgeDicInlevelorder(graph);\r\n        let [x, y] = [0, 0];\r\n        roots.forEach((v => {\r\n            const tree = v.createVirtualTree(externalEdges);\r\n            standardTreeWidthArrangementSub(tree, xi, yi, direction);\r\n            tree.setRegionXYLocation(x, y);\r\n            x += tree.region().width;\r\n        }));\r\n    }\r\n    GraphArrangement.standardTreeWidthArrangement = standardTreeWidthArrangement;\r\n    function standardTreeWidthArrangementSub(tree, xInterval, yInterval, direction) {\r\n        tree.subTreeRoot.cx = 0;\r\n        tree.subTreeRoot.cy = 0;\r\n        let centerX = 0;\r\n        const children = tree.virtualTreeChildren;\r\n        let x = 0;\r\n        //tree.root.svgText.textContent = tree.getHeight().toString();\r\n        if (direction == \"down\") {\r\n            const edge = tree.subTreeRoot.parentEdge;\r\n            if (edge != null) {\r\n                edge.endConnectorType = enums_1.ConnectorPosition.Top;\r\n                edge.beginConnectorType = enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n        let childYInterval = yInterval;\r\n        children.forEach((v) => {\r\n            const path = v.parentEdge.svgTextPath;\r\n            if (path.textContent == null || path.textContent.length == 0) {\r\n            }\r\n            else if (path.textContent.length == 1) {\r\n                const padding = SVGTextBox.getRepresentativeFontSize(path);\r\n                const edgeLen = (SVGTextBox.getTextEmulatedWidth(path)) + (padding);\r\n                if (edgeLen > childYInterval)\r\n                    childYInterval = edgeLen;\r\n            }\r\n            else {\r\n                const padding = SVGTextBox.getRepresentativeFontSize(path);\r\n                const edgeLen = (SVGTextBox.getTextEmulatedWidth(path)) + (padding * 4);\r\n                if (edgeLen > childYInterval)\r\n                    childYInterval = edgeLen;\r\n            }\r\n        });\r\n        if (children.length == 1) {\r\n            tree.subTreeRoot.cx = children[0].root.cx;\r\n            standardTreeWidthArrangementSub(children[0], xInterval, yInterval, direction);\r\n            children[0].setRootLocation(tree.root.cx, childYInterval);\r\n        }\r\n        else if (children.length == 0) {\r\n        }\r\n        else {\r\n            for (let i = 0; i < children.length; i++) {\r\n                standardTreeWidthArrangementSub(children[i], xInterval, yInterval, direction);\r\n                const rect = children[i].region();\r\n                const diffX = children[i].root.cx - rect.x;\r\n                children[i].setRootLocation(x + diffX, childYInterval);\r\n                x += rect.width + xInterval;\r\n                if (i < children.length - 1) {\r\n                    centerX += x - (xInterval / 2);\r\n                }\r\n            }\r\n            centerX = centerX / (children.length - 1);\r\n            tree.subTreeRoot.cx = centerX;\r\n        }\r\n    }\r\n    function createExternalEdgeDicInPreorder(node, incomingEdge, externalEdges, touchedVertexes) {\r\n        if (incomingEdge == null) {\r\n            node.outcomingEdges.forEach((v) => {\r\n                const child = v.endVertex;\r\n                if (child != null) {\r\n                    createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            if (!touchedVertexes.has(node)) {\r\n                touchedVertexes.add(node);\r\n                node.outcomingEdges.forEach((v) => {\r\n                    const child = v.endVertex;\r\n                    if (child != null) {\r\n                        createExternalEdgeDicInPreorder(child, v, externalEdges, touchedVertexes);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                if (incomingEdge != null) {\r\n                    externalEdges.add(incomingEdge);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function createExternalEdgeDicInlevelorder(graph) {\r\n        const externalEdges = new Set();\r\n        const touchedVertexes = new Set();\r\n        const inputEdges = new Array(0);\r\n        const roots = graph.roots.length == 0 ? [graph.vertices[0]] : graph.roots;\r\n        roots.forEach((v => {\r\n            touchedVertexes.add(v);\r\n            v.outcomingEdges.forEach((w) => inputEdges.push(w));\r\n        }));\r\n        createExternalEdgeDicInlevelorderSub(inputEdges, externalEdges, touchedVertexes, 0);\r\n        return externalEdges;\r\n    }\r\n    function createExternalEdgeDicInlevelorderSub(inputEdges, externalEdges, touchedVertexes, level) {\r\n        //const edges = inputEdges.filter((v) => v.endVertex != null);\r\n        const nextEdges = new Array(0);\r\n        inputEdges.forEach((v) => {\r\n            if (v.endVertex != null) {\r\n                const node = v.endVertex;\r\n                if (!touchedVertexes.has(node)) {\r\n                    touchedVertexes.add(node);\r\n                    node.outcomingEdges.forEach((w) => nextEdges.push(w));\r\n                }\r\n                else {\r\n                    externalEdges.add(v);\r\n                }\r\n            }\r\n        });\r\n        if (nextEdges.length > 0) {\r\n            createExternalEdgeDicInlevelorderSub(nextEdges, externalEdges, touchedVertexes, level + 1);\r\n        }\r\n    }\r\n})(GraphArrangement = exports.GraphArrangement || (exports.GraphArrangement = {}));\r\n//}\r\n//# sourceMappingURL=graph_arrangement.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/graph_helpers/graph_arrangement.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/graph_helpers/tree_arangement.js":
/*!************************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/graph_helpers/tree_arangement.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//namespace GraphTableSVG {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\n//export namespace TreeArrangement {\r\nfunction reverse(graph, isX, isY) {\r\n    if (graph.vertices.length > 0) {\r\n        if (isY) {\r\n            const midY = middle(graph.vertices.map((v) => v.cy));\r\n            graph.vertices.forEach((v) => {\r\n                if (v.cy < midY) {\r\n                    v.cy += 2 * (midY - v.cy);\r\n                }\r\n                else {\r\n                    v.cy -= 2 * (v.cy - midY);\r\n                }\r\n            });\r\n        }\r\n        if (isX) {\r\n            const midX = middle(graph.vertices.map((v) => v.cx));\r\n            graph.vertices.forEach((v) => {\r\n                if (v.cx < midX) {\r\n                    v.cx += 2 * (midX - v.cx);\r\n                }\r\n                else {\r\n                    v.cx -= 2 * (v.cx - midX);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.reverse = reverse;\r\nfunction average(items) {\r\n    if (items.length > 0) {\r\n        let y = 0;\r\n        items.forEach((v) => {\r\n            y += v;\r\n        });\r\n        return y / items.length;\r\n    }\r\n    else {\r\n        throw new Error();\r\n    }\r\n}\r\nfunction middle(items) {\r\n    if (items.length > 0) {\r\n        let min = items[0];\r\n        let max = items[0];\r\n        items.forEach((w) => {\r\n            if (min > w)\r\n                min = w;\r\n            if (max < w)\r\n                max = w;\r\n        });\r\n        return (min + max) / 2;\r\n    }\r\n    else {\r\n        throw new Error();\r\n    }\r\n}\r\n/**\r\n * 子Vertexが一列に並ぶようにグラフ内のVertexを整列します。\r\n * @param graph\r\n */\r\nfunction alignVerticeByChildren(graph) {\r\n    if (!graph.isShow)\r\n        return;\r\n    const [xi, yi] = getXYIntervals(graph);\r\n    if (graph.rootVertex != null) {\r\n        const rootTree = graph.rootVertex.createVirtualTree();\r\n        const [x, y] = [rootTree.subTreeRoot.x, rootTree.subTreeRoot.y];\r\n        alignVerticeByChildrenSub(rootTree, xi, yi);\r\n        rootTree.setRootLocation(x, y);\r\n        //graph.update();\r\n    }\r\n    alignTrees(graph);\r\n}\r\nexports.alignVerticeByChildren = alignVerticeByChildren;\r\n/**\r\n * 子Vertexが一列に並ぶようにグラフ内のVertexを整列します。\r\n * @param tree\r\n * @param xInterval\r\n * @param yInterval\r\n */\r\nfunction alignVerticeByChildrenSub(tree, xInterval, yInterval) {\r\n    tree.subTreeRoot.cx = 0;\r\n    tree.subTreeRoot.cy = 0;\r\n    let leaves = 0;\r\n    const children = tree.virtualTreeChildren;\r\n    const leaveSizeWidthHalf = (tree.leaves.length * xInterval) / 2;\r\n    let x = -leaveSizeWidthHalf;\r\n    for (let i = 0; i < children.length; i++) {\r\n        alignVerticeByChildrenSub(children[i], xInterval, yInterval);\r\n        const w = (children[i].leaves.length * xInterval) / 2;\r\n        children[i].setRootLocation(x + w, yInterval);\r\n        x += children[i].leaves.length * xInterval;\r\n    }\r\n}\r\n/**\r\n * グラフ内のVertexからVertex間の水平間隔と垂直間隔を自動で算出します。\r\n * @param graph\r\n */\r\nfunction computeAutoXYIntervals(graph) {\r\n    let yMaximalInterval = 10;\r\n    let xMaximalInterval = 10;\r\n    graph.vertices.forEach((v) => {\r\n        if (v.width > xMaximalInterval)\r\n            xMaximalInterval = v.width;\r\n        if (v.height > yMaximalInterval)\r\n            yMaximalInterval = v.height;\r\n    });\r\n    return [xMaximalInterval * 2, yMaximalInterval * 2];\r\n}\r\n/**\r\n * グラフに設定されているVertex間の水平間隔と垂直間隔を算出します。\r\n * @param graph\r\n */\r\nfunction getXYIntervals(graph) {\r\n    const [xMaximalInterval, yMaximalInterval] = computeAutoXYIntervals(graph);\r\n    const xi = graph.vertexXInterval != null ? graph.vertexXInterval : xMaximalInterval;\r\n    const yi = graph.vertexYInterval != null ? graph.vertexYInterval : yMaximalInterval;\r\n    return [xi, yi];\r\n}\r\nexports.getXYIntervals = getXYIntervals;\r\n/**\r\n * グラフ内の森を並べます。最初の木が内接する四角形の左上の座標は[0,0]です。\r\n * @param graph\r\n */\r\nfunction alignTrees(graph) {\r\n    let x = 0;\r\n    graph.roots.forEach((v) => {\r\n        const region = v.createVirtualTree().region();\r\n        v.createVirtualTree().setRectangleLocation(x, 0);\r\n        //x += graph.vertexXInterval != null ? graph.vertexXInterval : 0;\r\n        x += region.width;\r\n    });\r\n}\r\nfunction addOffset(graph, x, y) {\r\n    graph.vertices.forEach((v) => {\r\n        v.cx += x;\r\n        v.cy += y;\r\n    });\r\n}\r\nexports.addOffset = addOffset;\r\n/**\r\n * 葉が一列に並ぶようにVertexを整列します。\r\n * @param forest\r\n * @param xInterval\r\n * @param yInterval\r\n */\r\nfunction alignVerticeByLeaveSub(forest, xInterval, yInterval) {\r\n    let leafCounter = 0;\r\n    forest.getOrderedVertices(enums_1.VertexOrder.Postorder).forEach((v) => {\r\n        let x = 0;\r\n        let y = 0;\r\n        if (v.isLeaf) {\r\n            x = leafCounter * xInterval;\r\n            leafCounter++;\r\n        }\r\n        else {\r\n            v.children.forEach((w) => {\r\n                x += w.cx;\r\n                if (y < w.cy)\r\n                    y = w.cy;\r\n            });\r\n            x = x / v.children.length;\r\n            y += yInterval;\r\n        }\r\n        v.cx = x;\r\n        v.cy = y;\r\n    });\r\n}\r\nexports.alignVerticeByLeaveSub = alignVerticeByLeaveSub;\r\n/**\r\n * 葉が一列に並ぶようにVertexを整列します。\r\n * @param graph\r\n */\r\nfunction alignVerticeByLeave(graph) {\r\n    if (!graph.isShow)\r\n        return;\r\n    graph.vertices.forEach((v) => { v.cx = 0; v.cy = 0; });\r\n    const [xi, yi] = getXYIntervals(graph);\r\n    alignVerticeByLeaveSub(graph, xi, yi);\r\n    reverse(graph, false, true);\r\n    //alignTrees(graph);\r\n    const reg = graph.getRegion();\r\n    const dx = reg.x < 0 ? -reg.x : 0;\r\n    const dy = reg.y < 0 ? -reg.y : 0;\r\n    addOffset(graph, dx, dy);\r\n}\r\nexports.alignVerticeByLeave = alignVerticeByLeave;\r\nfunction standardTreeWidthArrangement(graph) {\r\n    //const xInterval = graph.vertexXInterval;\r\n    //const yInterval = graph.vertexYInterval;\r\n    const [xi, yi] = getXYIntervals(graph);\r\n    if (graph.rootVertex != null) {\r\n        const rootTree = graph.rootVertex.createVirtualTree();\r\n        const [x, y] = [rootTree.subTreeRoot.cx, rootTree.subTreeRoot.cy];\r\n        standardTreeWidthArrangementSub(rootTree, xi, yi);\r\n        rootTree.setRootLocation(x, y);\r\n        //graph.update();\r\n    }\r\n}\r\nexports.standardTreeWidthArrangement = standardTreeWidthArrangement;\r\nfunction standardTreeWidthArrangementSub(tree, xInterval, yInterval) {\r\n    tree.subTreeRoot.cx = 0;\r\n    tree.subTreeRoot.cy = 0;\r\n    let centerX = 0;\r\n    const children = tree.virtualTreeChildren;\r\n    let x = 0;\r\n    if (children.length == 1) {\r\n        tree.subTreeRoot.cx = children[0].root.cx;\r\n        standardTreeWidthArrangementSub(children[0], xInterval, yInterval);\r\n        children[0].setRootLocation(children[0].root.x, yInterval);\r\n    }\r\n    else if (children.length == 0) {\r\n    }\r\n    else {\r\n        for (let i = 0; i < children.length; i++) {\r\n            standardTreeWidthArrangementSub(children[i], xInterval, yInterval);\r\n            const rect = children[i].region();\r\n            const diffX = children[i].root.cx - rect.x;\r\n            children[i].setRootLocation(x + diffX, yInterval);\r\n            x += rect.width + xInterval;\r\n            if (i < children.length - 1) {\r\n                centerX += x - (xInterval / 2);\r\n            }\r\n        }\r\n        centerX = centerX / (children.length - 1);\r\n        tree.subTreeRoot.cx = centerX;\r\n    }\r\n}\r\n//}\r\n//}\r\n//# sourceMappingURL=tree_arangement.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/graph_helpers/tree_arangement.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/graph_helpers/virtual_tree.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/graph_helpers/virtual_tree.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//namespace GraphTableSVG {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nclass VirtualTree {\r\n    constructor(_root, _externalEdgeDic) {\r\n        this.subTreeRoot = _root;\r\n        if (_externalEdgeDic !== undefined) {\r\n            this.externalEdges = _externalEdgeDic;\r\n        }\r\n        else {\r\n            this.externalEdges = new Set();\r\n        }\r\n    }\r\n    get root() {\r\n        return this.subTreeRoot;\r\n    }\r\n    /**\r\n     * 根の子ノードの配列を返します。\r\n     */\r\n    get children() {\r\n        //const p = this;\r\n        return this.subTreeRoot.outcomingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).map((v) => v.endVertex);\r\n        /*\r\n        return this.subTreeRoot.children.map(function (x, i, arr) {\r\n            return x;\r\n        });\r\n        */\r\n    }\r\n    get virtualTreeChildren() {\r\n        return this.children.map((v) => v.createVirtualTree(this.externalEdges));\r\n        //const child = this.children[nth];\r\n        //return child.createVirtualTree(this.externalEdges);\r\n    }\r\n    /**\r\n     * 根の親との間の辺を返します。\r\n     */\r\n    get parentEdge() {\r\n        const p = this.subTreeRoot.incomingEdges.filter((v) => !this.externalEdges.has(v) && v.beginVertex != null);\r\n        if (p.length != 0) {\r\n            return p[0];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        //return this.subTreeRoot.parentEdge;\r\n    }\r\n    /**\r\n     * この木の中の全てのVertexを返します。\r\n     * @param result\r\n     */\r\n    getSubtree(result = []) {\r\n        result.push(this.subTreeRoot);\r\n        const children = this.virtualTreeChildren;\r\n        if (children.length == 0) {\r\n            return result;\r\n        }\r\n        else {\r\n            children.forEach(function (x, i, arr) {\r\n                x.getSubtree(result);\r\n            });\r\n            return result;\r\n        }\r\n    }\r\n    /*\r\n    public getLeaves(): Vertex[] {\r\n        const p = this;\r\n        return this.getSubtree().filter(function (x, i, arr) {\r\n            return x.outcomingEdges.length == 0;\r\n        });\r\n    }\r\n    */\r\n    getHeight() {\r\n        const children = this.virtualTreeChildren;\r\n        if (children.length == 0) {\r\n            return 1;\r\n        }\r\n        else {\r\n            let max = 0;\r\n            children.forEach(function (x, i, arr) {\r\n                if (max < x.getHeight())\r\n                    max = x.getHeight();\r\n            });\r\n            return max + 1;\r\n        }\r\n    }\r\n    /**\r\n     * この木を内包する最小の四角形を返します。\r\n     */\r\n    region() {\r\n        const p = this.getSubtree();\r\n        let minX = this.subTreeRoot.x;\r\n        let maxX = this.subTreeRoot.x;\r\n        let minY = this.subTreeRoot.y;\r\n        let maxY = this.subTreeRoot.y;\r\n        p.forEach(function (x, i, arr) {\r\n            const rect = x.region;\r\n            if (minX > rect.x)\r\n                minX = rect.x;\r\n            if (maxX < rect.right)\r\n                maxX = rect.right;\r\n            if (minY > rect.y)\r\n                minY = rect.y;\r\n            if (maxY < rect.bottom)\r\n                maxY = rect.bottom;\r\n        });\r\n        const result = new vline_1.Rectangle();\r\n        result.x = minX;\r\n        result.y = minY;\r\n        result.width = maxX - minX;\r\n        result.height = maxY - minY;\r\n        return result;\r\n    }\r\n    /**\r\n     * 一番左の葉を返します。\r\n     */\r\n    get mostLeftLeave() {\r\n        return this.leaves[0];\r\n    }\r\n    addOffset(_x, _y) {\r\n        this.getSubtree().forEach(function (x, i, arr) {\r\n            x.cx += _x;\r\n            x.cy += _y;\r\n        });\r\n    }\r\n    setRectangleLocation(_x, _y) {\r\n        const x = this.mostLeftLeave.region.x;\r\n        const y = this.subTreeRoot.region.y;\r\n        const diffX = _x - x;\r\n        const diffY = _y - y;\r\n        this.addOffset(diffX, diffY);\r\n        //this.graph.updateEdges();\r\n    }\r\n    /**\r\n     * 根を入力位置に移動させます。木も同様に移動します。\r\n     * @param _x\r\n     * @param _y\r\n     */\r\n    setRootLocation(_x, _y) {\r\n        const x = this.subTreeRoot.cx;\r\n        const y = this.subTreeRoot.cy;\r\n        const diffX = _x - x;\r\n        const diffY = _y - y;\r\n        this.addOffset(diffX, diffY);\r\n        //this.graph.updateEdges();\r\n    }\r\n    setRegionXYLocation(_x, _y) {\r\n        const region = this.region();\r\n        const newX = _x - region.x;\r\n        const newY = _y - region.y;\r\n        this.addOffset(newX, newY);\r\n        //this.graph.updateEdges();\r\n    }\r\n    /**\r\n     * 葉の配列を返します。\r\n     */\r\n    get leaves() {\r\n        //const p = this;\r\n        return this.getSubtree().filter((x) => {\r\n            const r = x.outcomingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).length;\r\n            return r == 0;\r\n        });\r\n        //return this.getSubtree().filter(function (x, i, arr) {\r\n        //\r\n        //    return x.outcomingEdges.length == 0;\r\n        //});\r\n    }\r\n}\r\nexports.VirtualTree = VirtualTree;\r\n//}\r\n//# sourceMappingURL=virtual_tree.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/graph_helpers/virtual_tree.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/index.js":
/*!************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nexports.GObject = g_object_1.GObject;\r\nconst g_arrow_callout_1 = __webpack_require__(/*! ./g_arrow_callout */ \"./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js\");\r\nexports.GArrowCallout = g_arrow_callout_1.GArrowCallout;\r\nconst g_callout_1 = __webpack_require__(/*! ./g_callout */ \"./node_modules/graph-table-svg/dist/objects/g_callout.js\");\r\nexports.GCallout = g_callout_1.GCallout;\r\nconst g_circle_1 = __webpack_require__(/*! ./g_circle */ \"./node_modules/graph-table-svg/dist/objects/g_circle.js\");\r\nexports.GCircle = g_circle_1.GCircle;\r\nconst g_edge_1 = __webpack_require__(/*! ./g_edge */ \"./node_modules/graph-table-svg/dist/objects/g_edge.js\");\r\nexports.GEdge = g_edge_1.GEdge;\r\nconst g_ellipse_1 = __webpack_require__(/*! ./g_ellipse */ \"./node_modules/graph-table-svg/dist/objects/g_ellipse.js\");\r\nexports.GEllipse = g_ellipse_1.GEllipse;\r\nconst g_graph_1 = __webpack_require__(/*! ./g_graph */ \"./node_modules/graph-table-svg/dist/objects/g_graph.js\");\r\nexports.GGraph = g_graph_1.GGraph;\r\nconst g_rect_button_1 = __webpack_require__(/*! ./g_rect_button */ \"./node_modules/graph-table-svg/dist/objects/g_rect_button.js\");\r\nexports.GRectButton = g_rect_button_1.GRectButton;\r\nconst g_rect_1 = __webpack_require__(/*! ./g_rect */ \"./node_modules/graph-table-svg/dist/objects/g_rect.js\");\r\nexports.GRect = g_rect_1.GRect;\r\nconst g_table_1 = __webpack_require__(/*! ./g_table */ \"./node_modules/graph-table-svg/dist/objects/g_table.js\");\r\nexports.GTable = g_table_1.GTable;\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nexports.GTextBox = g_textbox_1.GTextBox;\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"./node_modules/graph-table-svg/dist/objects/g_vertex.js\");\r\nexports.GVertex = g_vertex_1.GVertex;\r\nconst g_path_textbox_1 = __webpack_require__(/*! ./g_path_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_path_textbox.js\");\r\nexports.GPathTextBox = g_path_textbox_1.GPathTextBox;\r\nconst GOptions = __webpack_require__(/*! ./g_options */ \"./node_modules/graph-table-svg/dist/objects/g_options.js\");\r\nexports.GOptions = GOptions;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/table_helpers/border_row.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/table_helpers/border_row.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\n/**\r\n * 表の行を表現するクラスです。\r\n */\r\nclass BorderRow {\r\n    constructor(_table, _y, columnSize, borderClass) {\r\n        this._borders = new Array(0);\r\n        this.table = _table;\r\n        this._svgGroup = SVG.createGroup(this.table.svgRowBorderGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"border_row\");\r\n        this.borderY = _y;\r\n        for (let x = 0; x < columnSize; x++) {\r\n            this.insertBorder(x, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\r\n        }\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    /**\r\n    列の単位セルのY座標を返します。\r\n    */\r\n    get borderY() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set borderY(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n    }\r\n    get borders() {\r\n        return this._borders;\r\n    }\r\n    insertBorder(coromni, borderClass) {\r\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\r\n        this._svgGroup.appendChild(line);\r\n        this._borders.splice(coromni, 0, line);\r\n    }\r\n    removeBorder(i) {\r\n        this._borders[i].remove();\r\n        this._borders.splice(i, 1);\r\n    }\r\n    remove() {\r\n        this.svgGroup.remove();\r\n    }\r\n}\r\nexports.BorderRow = BorderRow;\r\nclass BorderColumn {\r\n    constructor(_table, _x, rowSize, borderClass) {\r\n        this._borders = new Array(0);\r\n        this.table = _table;\r\n        this._svgGroup = SVG.createGroup(this.table.svgColumnBorderGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"border_column\");\r\n        this.borderX = _x;\r\n        for (let y = 0; y < rowSize; y++) {\r\n            this.insertBorder(y, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\r\n        }\r\n    }\r\n    /**\r\n    列の単位セルのY座標を返します。\r\n    */\r\n    get borderX() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set borderX(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get borders() {\r\n        return this._borders;\r\n    }\r\n    insertBorder(rowi, borderClass) {\r\n        const line = SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : DefaultClassNames.defaultCellBorderClass);\r\n        this._svgGroup.appendChild(line);\r\n        this._borders.splice(rowi, 0, line);\r\n    }\r\n    removeBorder(i) {\r\n        this._borders[i].remove();\r\n        this._borders.splice(i, 1);\r\n    }\r\n    remove() {\r\n        this.svgGroup.remove();\r\n    }\r\n}\r\nexports.BorderColumn = BorderColumn;\r\n//}\r\n//# sourceMappingURL=border_row.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/table_helpers/border_row.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n//namespace GraphTableSVG {\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CommonFunctions = __webpack_require__(/*! ../../common/common_functions */ \"./node_modules/graph-table-svg/dist/common/common_functions.js\");\r\nconst vline_1 = __webpack_require__(/*! ../../common/vline */ \"./node_modules/graph-table-svg/dist/common/vline.js\");\r\nconst AttributeNames = __webpack_require__(/*! ../../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst StyleNames = __webpack_require__(/*! ../../common/style_names */ \"./node_modules/graph-table-svg/dist/common/style_names.js\");\r\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\n//import {CellOption} from \"../../options/attributes_option\"\r\nconst enums_1 = __webpack_require__(/*! ../../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst SVGGExtension = __webpack_require__(/*! ../../interfaces/svg_g_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_g_extension.js\");\r\nconst SVGElementExtension = __webpack_require__(/*! ../../interfaces/svg_element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_element_extension.js\");\r\nconst SVGTextExtension = __webpack_require__(/*! ../../interfaces/svg_text_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js\");\r\nvar DirectionType;\r\n(function (DirectionType) {\r\n    DirectionType[DirectionType[\"top\"] = 0] = \"top\";\r\n    DirectionType[DirectionType[\"left\"] = 1] = \"left\";\r\n    DirectionType[DirectionType[\"right\"] = 2] = \"right\";\r\n    DirectionType[DirectionType[\"bottom\"] = 3] = \"bottom\";\r\n})(DirectionType = exports.DirectionType || (exports.DirectionType = {}));\r\nvar DirectionType2;\r\n(function (DirectionType2) {\r\n    DirectionType2[DirectionType2[\"topLeft\"] = 0] = \"topLeft\";\r\n    DirectionType2[DirectionType2[\"bottomLeft\"] = 1] = \"bottomLeft\";\r\n    DirectionType2[DirectionType2[\"bottomRight\"] = 2] = \"bottomRight\";\r\n    DirectionType2[DirectionType2[\"topRight\"] = 3] = \"topRight\";\r\n})(DirectionType2 = exports.DirectionType2 || (exports.DirectionType2 = {}));\r\n/**\r\n * セルをSVGで表現するためのクラスです。\r\n */\r\nclass Cell {\r\n    constructor(parent, _px, _py, option = {}) {\r\n        this.__currentClass = null;\r\n        this.tmpStyle = null;\r\n        this._observerFunc = (x) => {\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (p.attributeName == \"style\" || p.attributeName == \"class\") {\r\n                    if (p.attributeName == \"class\") {\r\n                        const className = this.svgGroup.getAttribute(\"class\");\r\n                        if (className != this.__currentClass) {\r\n                            this.recomputeDefaultProperties();\r\n                            this.__currentClass = className;\r\n                        }\r\n                    }\r\n                    this.locateSVGText();\r\n                }\r\n            }\r\n        };\r\n        this._assurancevisibility = false;\r\n        this._svgGroup = SVG.createGroup(null);\r\n        this._table = parent;\r\n        this.table.rows[_py].svgGroup.appendChild(this.svgGroup);\r\n        //this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgGroup.firstChild);\r\n        this.svgGroup.setAttribute(\"class\", option.cellClass !== undefined ? option.cellClass : DefaultClassNames.defaultCellClass);\r\n        this.svgGroup.setAttribute(AttributeNames.GroupAttribute, \"cell\");\r\n        this.svgGroup.setAttribute(Cell.cellXName, `${_px}`);\r\n        this.svgGroup.setAttribute(Cell.cellYName, `${_py}`);\r\n        this.setMasterDiffX(0);\r\n        this.setMasterDiffY(0);\r\n        const backGroundClass = DefaultClassNames.defaultCellBackgroungClass;\r\n        this._svgBackground = SVG.createCellRectangle(this.svgGroup, backGroundClass);\r\n        const textClass = DefaultClassNames.defaultTextClass;\r\n        this._svgText = SVG.createText(textClass);\r\n        this.svgGroup.appendChild(this.svgText);\r\n        //const borderClass = option.borderClass === undefined ? null : option.borderClass;\r\n        //const option1: MutationObserverInit = { childList: true, subtree: true };\r\n        //this.table.cellTextObserver.observe(this.svgText, option1);\r\n        this._observer = new MutationObserver(this._observerFunc);\r\n        const option2 = { attributes: true };\r\n        this._observer.observe(this.svgGroup, option2);\r\n    }\r\n    // #region style\r\n    recomputeDefaultProperties() {\r\n        /*\r\n        if(this.defaultBackgroundClass != null){\r\n            this._svgBackground.setAttribute(\"class\", this.defaultBackgroundClass);\r\n        }\r\n        if(this.defaultTextClass != null){\r\n            this._svgText.setAttribute(\"class\", this.defaultTextClass);\r\n        }\r\n        */\r\n    }\r\n    /*\r\n    public get class() : string | null{\r\n        return this.svgGroup.getAttribute(\"class\");\r\n    }\r\n    public set class(value : string | null){\r\n        if(value == null){\r\n            this.svgGroup.removeAttribute(\"class\");\r\n        }else{\r\n            this.svgGroup.setAttribute(\"class\", value);\r\n        }\r\n    }\r\n    */\r\n    /**\r\n     * このセルが強調してるかどうかを返します。\r\n     */\r\n    get isEmphasized() {\r\n        const cellClass = this.svgBackground.getAttribute(\"class\");\r\n        return cellClass == AttributeNames.cellEmphasisCellClass;\r\n    }\r\n    set isEmphasized(v) {\r\n        if (v) {\r\n            if (!this.isEmphasized) {\r\n                this.tmpStyle = this.svgBackground.getAttribute(\"class\");\r\n                this.svgBackground.setAttribute(\"class\", AttributeNames.cellEmphasisCellClass);\r\n            }\r\n        }\r\n        else {\r\n            if (this.isEmphasized) {\r\n                if (this.tmpStyle == null) {\r\n                    this.svgBackground.removeAttribute(\"class\");\r\n                }\r\n                else {\r\n                    this.svgBackground.setAttribute(\"class\", this.tmpStyle);\r\n                    this.tmpStyle = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * テキストのフォントサイズを返します。\r\n     */\r\n    get fontSize() {\r\n        const p = ElementExtension.getPropertyStyleValueWithDefault(this.svgText, \"font-size\", \"24\");\r\n        const p2 = parseInt(p);\r\n        return p2;\r\n    }\r\n    /**\r\n    テキストとセル間の左のパディング値を返します。\r\n    */\r\n    get paddingLeft() {\r\n        return SVGElementExtension.getPaddingLeft(this.svgGroup);\r\n    }\r\n    /**\r\n    テキストとセル間の右のパディング値を返します。\r\n    */\r\n    get paddingRight() {\r\n        return SVGElementExtension.getPaddingRight(this.svgGroup);\r\n    }\r\n    /**\r\n    テキストとセル間の上のパディング値を返します。\r\n    */\r\n    get paddingTop() {\r\n        return SVGElementExtension.getPaddingTop(this.svgGroup);\r\n    }\r\n    /**\r\n    テキストとセル間の下のパディング値を返します。\r\n    */\r\n    get paddingBottom() {\r\n        return SVGElementExtension.getPaddingBottom(this.svgGroup);\r\n    }\r\n    get horizontalAnchor() {\r\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.HorizontalAnchor, \"center\");\r\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\r\n    }\r\n    /**\r\n    テキストの水平方向の配置設定を設定します。\r\n    */\r\n    set horizontalAnchor(value) {\r\n        if (this.horizontalAnchor != value)\r\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.HorizontalAnchor, value);\r\n    }\r\n    /**\r\n    テキストの垂直方向の配置設定を返します。\r\n    */\r\n    get verticalAnchor() {\r\n        const b = ElementExtension.getPropertyStyleValueWithDefault(this.svgGroup, StyleNames.VerticalAnchor, \"middle\");\r\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\r\n    }\r\n    /**\r\n    テキストの垂直方向の配置設定を設定します。\r\n    */\r\n    set verticalAnchor(value) {\r\n        if (this.verticalAnchor != value)\r\n            ElementExtension.setPropertyStyleValue(this.svgGroup, StyleNames.VerticalAnchor, value);\r\n    }\r\n    /**\r\n    所属しているTableを返します。\r\n    */\r\n    get table() {\r\n        return this._table;\r\n    }\r\n    /**\r\n    セルの背景を表現しているSVGRectElementを返します。\r\n    */\r\n    get svgBackground() {\r\n        return this._svgBackground;\r\n    }\r\n    /**\r\n    セルのテキストを表現しているSVGTextElementを返します。\r\n    */\r\n    get svgText() {\r\n        return this._svgText;\r\n    }\r\n    /**\r\n    セルを表しているSVGGElementを返します。\r\n    */\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    // #endregion\r\n    // #region property\r\n    get innerExtraPaddingLeft() {\r\n        const p = this.fontSize;\r\n        return p / 16;\r\n    }\r\n    get innerExtraPaddingRight() {\r\n        const p = this.fontSize;\r\n        return p / 16;\r\n    }\r\n    //private _masterID: number;\r\n    /**\r\n     * このセルのx座標とマスターセルとのX座標の差分を返します。\r\n     */\r\n    get masterDiffX() {\r\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffXName));\r\n    }\r\n    /**\r\n     * このセルのx座標とマスターセルとのX座標の差分を設定します。\r\n     */\r\n    setMasterDiffX(id) {\r\n        this.svgGroup.setAttribute(Cell.masterDiffXName, `${id}`);\r\n    }\r\n    /**\r\n     * このセルのy座標とマスターセルとのy座標の差分を返します。\r\n     */\r\n    get masterDiffY() {\r\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffYName));\r\n    }\r\n    /**\r\n     * このセルのy座標とマスターセルとのy座標の差分を設定します。\r\n     */\r\n    setMasterDiffY(id) {\r\n        this.svgGroup.setAttribute(Cell.masterDiffYName, `${id}`);\r\n    }\r\n    /**\r\n     * マスターセルのx座標を返します。\r\n     */\r\n    get masterCellX() {\r\n        return this.cellX + this.masterDiffX;\r\n    }\r\n    /**\r\n     * マスターセルのx座標を設定します。\r\n     */\r\n    setMasterCellX(id) {\r\n        this.setMasterDiffX(id - this.cellX);\r\n    }\r\n    /**\r\n     * マスターセルのy座標を返します。\r\n     */\r\n    get masterCellY() {\r\n        return this.cellY + this.masterDiffY;\r\n    }\r\n    /**\r\n     * マスターセルのy座標を設定します。\r\n     */\r\n    setMasterCellY(id) {\r\n        this.setMasterDiffY(id - this.cellY);\r\n    }\r\n    /**\r\n     * マスターセルのIDを返します。\r\n     */\r\n    get masterID() {\r\n        return this.table.cells[this.masterCellY][this.masterCellX].ID;\r\n    }\r\n    /*\r\n    public set masterID(id: number) {\r\n        this.svgGroup.setAttribute(Cell.masterIDName, `${id}`);\r\n    }\r\n    */\r\n    /**\r\n     * マスターセルを返します。\r\n     */\r\n    get master() {\r\n        return this.table.cellArray[this.masterID];\r\n    }\r\n    /**\r\n    単位セルを基準にした自身のX座標を返します。\r\n    */\r\n    get cellX() {\r\n        return Number(this.svgGroup.getAttribute(Cell.cellXName));\r\n    }\r\n    /**\r\n    単位セルを基準にした自身のX座標を設定します。\r\n    */\r\n    set cellX(value) {\r\n        if (this.cellX != value)\r\n            this.svgGroup.setAttribute(Cell.cellXName, value.toString());\r\n    }\r\n    /**\r\n    単位セルを基準にした自身のY座標を返します。\r\n    */\r\n    get cellY() {\r\n        return Number(this.svgGroup.getAttribute(Cell.cellYName));\r\n    }\r\n    /**\r\n    単位セルを基準にした自身のY座標を設定します。\r\n    */\r\n    set cellY(value) {\r\n        if (this.cellY != value)\r\n            this.svgGroup.setAttribute(Cell.cellYName, value.toString());\r\n    }\r\n    /*\r\n    get defaultTextClass(): string | null {\r\n        const r = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultTextClass);\r\n        return r;\r\n    }\r\n    get defaultBackgroundClass(): string | null {\r\n        const v = this.svgGroup.getPropertyStyleValue(AttributeNames.Style.defaultCellBackgroundClass);\r\n        return v;\r\n    }\r\n    */\r\n    /**\r\n    CellがDocumentのDOMに所属しているかどうかを返します。\r\n    */\r\n    get isLocated() {\r\n        return CommonFunctions.IsDescendantOfBody(this.svgGroup);\r\n    }\r\n    /**\r\n     * このセルがマスターセルのときに限りTrueを返します。\r\n     */\r\n    get isMaster() {\r\n        return this.ID == this.masterID;\r\n    }\r\n    /**\r\n     * このセルが奴隷セルのときに限りTrueを返します。\r\n     */\r\n    get isSlave() {\r\n        return !this.isMaster;\r\n    }\r\n    /**\r\n    セルのIDを返します。\r\n    */\r\n    get ID() {\r\n        return this.cellX + (this.cellY * this.table.columnCount);\r\n    }\r\n    get isErrorCell() {\r\n        return this.table.cells[this.cellY][this.cellX] != this;\r\n    }\r\n    /**\r\n     * グループセルの行数を返します。\r\n     */\r\n    get GroupRowCount() {\r\n        if (!this.isMaster)\r\n            throw Error(\"Slave Error\");\r\n        return this.leftSideGroupCells.length;\r\n    }\r\n    /**\r\n     * グループセルの列数を返します。\r\n     */\r\n    get GroupColumnCount() {\r\n        if (!this.isMaster)\r\n            throw Error(\"Slave Error\");\r\n        return this.upperSideGroupCells.length;\r\n    }\r\n    /**\r\n     * グループセルを構成しているセルを2次元配列で返します。\r\n     */\r\n    get cellsInGroup() {\r\n        if (this.isMaster) {\r\n            return this.table.getRangeCells(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    /**\r\n     * グループセルを構成しているセルを配列で返します。\r\n     */\r\n    get cellArrayInGroup() {\r\n        if (this.isMaster) {\r\n            return this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    /**\r\n     * このセルがグループセルであるときに限りTrueを返します。\r\n     */\r\n    get isSingleCell() {\r\n        return this.isMaster && this.leftSideGroupCells.length == 1 && this.upperSideGroupCells.length == 1;\r\n    }\r\n    /**\r\n     * マスターセルかつ行数が１のときに限りTrueを返します。\r\n     */\r\n    get isMasterCellOfRowCountOne() {\r\n        return this.isMaster && this.leftSideGroupCells.length == 1;\r\n    }\r\n    /**\r\n     * マスターセルかつ列数が１のときに限りTrueを返します。\r\n     */\r\n    get isMasterCellOfColumnCountOne() {\r\n        return this.isMaster && this.upperSideGroupCells.length == 1;\r\n    }\r\n    /**\r\n    セルのX座標を返します。\r\n    */\r\n    get x() {\r\n        return SVGGExtension.getX(this.svgGroup);\r\n    }\r\n    /**\r\n    セルのX座標を設定します。\r\n    */\r\n    set x(value) {\r\n        SVGGExtension.setX(this.svgGroup, value);\r\n    }\r\n    /**\r\n    セルのY座標を返します。\r\n    */\r\n    get y() {\r\n        return SVGGExtension.getY(this.svgGroup);\r\n    }\r\n    /**\r\n    セルのY座標を設定します。\r\n    */\r\n    set y(value) {\r\n        SVGGExtension.setY(this.svgGroup, value);\r\n    }\r\n    /**\r\n    セルの幅を返します。\r\n    */\r\n    get width() {\r\n        return this.svgBackground.width.baseVal.value;\r\n    }\r\n    /**\r\n    セルの幅を設定します。\r\n    */\r\n    set width(value) {\r\n        this.svgBackground.width.baseVal.value = value;\r\n    }\r\n    /**\r\n    セルの高さを返します。\r\n    */\r\n    get height() {\r\n        return this.svgBackground.height.baseVal.value;\r\n    }\r\n    /**\r\n    セルの高さを設定します。\r\n    */\r\n    set height(value) {\r\n        this.svgBackground.height.baseVal.value = value;\r\n    }\r\n    /**\r\n    セルの領域を表すRectangleを返します。領域の基準は属しているテーブルのSVGGElementです。\r\n    */\r\n    get region() {\r\n        const p = new vline_1.Rectangle(this.x, this.y, this.width, this.height);\r\n        return p;\r\n    }\r\n    /**\r\n     * グループセルの横幅を返します。\r\n     */\r\n    get computeGroupWidth() {\r\n        const p = this.master.upperSideGroupCells;\r\n        const x2 = p[p.length - 1].cellX;\r\n        let w = 0;\r\n        for (let i = this.cellX; i <= x2; i++) {\r\n            w += this.table.columns[i].width;\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * グループセルの縦幅を返します。\r\n     */\r\n    get computeGroupHeight() {\r\n        const p = this.master.leftSideGroupCells;\r\n        const y2 = p[p.length - 1].cellY;\r\n        let w = 0;\r\n        for (let i = this.cellY; i <= y2; i++) {\r\n            w += this.table.rows[i].height;\r\n        }\r\n        return w;\r\n    }\r\n    /**\r\n     * ２つの線分がオーバーラップしている部分の線分を返します。\r\n     * @param v\r\n     * @param w\r\n     */\r\n    static computeOverlapRange(v, w) {\r\n        if (w[0] < v[0]) {\r\n            return Cell.computeOverlapRange(w, v);\r\n        }\r\n        else {\r\n            if (v[1] < w[0]) {\r\n                return null;\r\n            }\r\n            else {\r\n                if (w[1] < v[1]) {\r\n                    return [w[0], w[1]];\r\n                }\r\n                else {\r\n                    return [w[0], v[1]];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * ２つの線分がオーバーラップしているときに限り、その結合した線分を返します。\r\n     * @param v\r\n     * @param w\r\n     */\r\n    static computeDisjunction(v, w) {\r\n        if (w[0] < v[0]) {\r\n            return Cell.computeDisjunction(w, v);\r\n        }\r\n        else {\r\n            if (v[1] < w[0]) {\r\n                return null;\r\n            }\r\n            else {\r\n                return [v[0], Math.max(v[1], w[1])];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * このグループセルの左上のX座標と右上のX座標を返します。\r\n     */\r\n    get groupColumnRange() {\r\n        return [this.master.cellX, this.master.mostRightCellX];\r\n    }\r\n    /**\r\n     * このグループセルの左上のY座標と左下のY座標を返します。\r\n     */\r\n    get groupRowRange() {\r\n        return [this.master.cellY, this.master.mostBottomCellY];\r\n    }\r\n    computeBorderLength2(dir) {\r\n        //const andFunc = ((v, w) => v);\r\n        const d1 = dir == DirectionType.top || dir == DirectionType.bottom ? this.master.x : this.master.y;\r\n        const d2 = dir == DirectionType.top || dir == DirectionType.bottom ? this.master.x + this.computeGroupWidth : this.master.y + this.computeGroupHeight;\r\n        const nextCell = this.getNextMasterCell(dir);\r\n        if (nextCell != null) {\r\n            const e1 = dir == DirectionType.top || dir == DirectionType.bottom ? nextCell.x : nextCell.y;\r\n            const e2 = dir == DirectionType.top || dir == DirectionType.bottom ? nextCell.x + nextCell.computeGroupWidth : nextCell.y + nextCell.computeGroupHeight;\r\n            const range = Cell.computeOverlapRange([d1, d2], [e1, e2]);\r\n            if (range == null) {\r\n                return 0;\r\n                //throw Error(`error ${d1} ${d2} ${e1} ${e2}`);\r\n            }\r\n            else {\r\n                return range[1] - range[0];\r\n            }\r\n        }\r\n        else {\r\n            return d2 - d1;\r\n        }\r\n    }\r\n    // #endregion\r\n    // #region border\r\n    //private _borders: SVGLineElement[] = new Array(4);\r\n    //private _topBorder: SVGLineElement;\r\n    /**\r\n    セルの上にある枠を返します\r\n    */\r\n    get svgTopBorder() {\r\n        return this._table.borderRows[this.cellY].borders[this.cellX];\r\n        //return this._borders[DirectionType.top];\r\n    }\r\n    /*\r\n    set svgTopBorder(line: SVGLineElement) {\r\n\r\n        this._borders[DirectionType.top] = line;\r\n    }\r\n    */\r\n    /**\r\n    セルの左にある枠を返します\r\n    */\r\n    get svgLeftBorder() {\r\n        return this._table.borderColumns[this.cellX].borders[this.cellY];\r\n        //return this._borders[DirectionType.left];\r\n    }\r\n    /*\r\n    set svgLeftBorder(line: SVGLineElement) {\r\n        this._borders[DirectionType.left] = line;\r\n    }\r\n    */\r\n    /**\r\n    セルの右にある枠を返します\r\n    */\r\n    get svgRightBorder() {\r\n        return this._table.borderColumns[this.cellX + 1].borders[this.cellY];\r\n        //return this._borders[DirectionType.right];\r\n    }\r\n    /*\r\n    set svgRightBorder(line: SVGLineElement) {\r\n        this._borders[DirectionType.right] = line;\r\n\r\n    }\r\n    */\r\n    /**\r\n    セルの下にある枠を返します\r\n    */\r\n    get svgBottomBorder() {\r\n        return this._table.borderRows[this.cellY + 1].borders[this.cellX];\r\n        //return this._borders[DirectionType.bottom];\r\n    }\r\n    /*\r\n    set svgBottomBorder(line: SVGLineElement) {\r\n        this._borders[DirectionType.bottom] = line;\r\n\r\n    }\r\n    */\r\n    // #endregion\r\n    // #region other\r\n    /**\r\n    未定義\r\n    */\r\n    get logicalWidth() {\r\n        if (this.isMaster) {\r\n            let w = 0;\r\n            let now = this;\r\n            while (now != null && this.ID == now.masterID) {\r\n                now = this.rightCell;\r\n                w++;\r\n            }\r\n            return w;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    /**\r\n    未定義\r\n    */\r\n    get logicalHeight() {\r\n        if (this.isMaster) {\r\n            let h = 0;\r\n            let now = this;\r\n            while (now != null && this.ID == now.masterID) {\r\n                now = this.bottomCell;\r\n                h++;\r\n            }\r\n            return h;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    /**\r\n    セルが取るべき幅を返します。\r\n    */\r\n    get calculatedWidthUsingText() {\r\n        if (this.isLocated) {\r\n            const textRect = SVGTextBox.getSize(this.svgText, this._assurancevisibility);\r\n            return textRect.width + this.innerExtraPaddingLeft + this.innerExtraPaddingRight\r\n                + this.paddingLeft + this.paddingRight;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    /**\r\n    セルが取るべき高さを返します。\r\n    */\r\n    get calculatedHeightUsingText() {\r\n        if (this.isLocated) {\r\n            const textRect = SVGTextBox.getSize(this.svgText, this._assurancevisibility);\r\n            return textRect.height + this.paddingTop + this.paddingBottom;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    calculatedSizeUsingGroup() {\r\n        if (this.isLocated) {\r\n            let w = 0;\r\n            let h = 0;\r\n            this.leftSideGroupCells.forEach((v) => h += this.table.rows[v.cellY].height);\r\n            this.upperSideGroupCells.forEach((v) => w += this.table.columns[v.cellX].width);\r\n            return [w, h];\r\n        }\r\n        else {\r\n            return [0, 0];\r\n        }\r\n    }\r\n    computeSidePosition(dir) {\r\n        switch (dir) {\r\n            case DirectionType2.topLeft: return [this.x, this.y];\r\n            case DirectionType2.topRight: return [this.x + this.width, this.y];\r\n            case DirectionType2.bottomLeft: return [this.x, this.y + this.height];\r\n            case DirectionType2.bottomRight: return [this.x + this.width, this.y + this.height];\r\n        }\r\n        throw Error(\"error\");\r\n    }\r\n    // #endregion\r\n    // #region NextCell\r\n    /**\r\n     * 与えられた方向にあるセルを返します。\r\n     * @param direction\r\n     */\r\n    getNextCell(direction) {\r\n        switch (direction) {\r\n            case DirectionType.top: return this.cellY != 0 ? this.table.cells[this.cellY - 1][this.cellX] : null;\r\n            case DirectionType.left: return this.cellX != 0 ? this.table.cells[this.cellY][this.cellX - 1] : null;\r\n            case DirectionType.right: return this.cellX + 1 != this.table.columnCount ? this.table.cells[this.cellY][this.cellX + 1] : null;\r\n            case DirectionType.bottom: return this.cellY + 1 != this.table.rowCount ? this.table.cells[this.cellY + 1][this.cellX] : null;\r\n        }\r\n        throw Error(\"error\");\r\n    }\r\n    /**\r\n     * 与えられた方向にある、このセルが属しているグループセルとは異なる最初のグループセルのマスターセルを返します。\r\n     * @param direction\r\n     */\r\n    getNextMasterCell(direction) {\r\n        const nextCell = this.getNextCell(direction);\r\n        return nextCell == null ? null :\r\n            nextCell.masterID != this.masterID ? nextCell.master : nextCell.getNextMasterCell(direction);\r\n    }\r\n    /**\r\n    上にあるセルを返します。\r\n    */\r\n    get topCell() {\r\n        return this.getNextCell(DirectionType.top);\r\n    }\r\n    /**\r\n    左にあるセルを返します。\r\n    */\r\n    get leftCell() {\r\n        return this.getNextCell(DirectionType.left);\r\n    }\r\n    /**\r\n    右にあるセルを返します。\r\n    */\r\n    get rightCell() {\r\n        return this.getNextCell(DirectionType.right);\r\n    }\r\n    /**\r\n    下にあるセルを返します。\r\n    */\r\n    get bottomCell() {\r\n        return this.getNextCell(DirectionType.bottom);\r\n    }\r\n    /**\r\n     * 右下のセルを返します。\r\n     */\r\n    get bottomRightCell() {\r\n        return this.bottomCell == null ? null : this.bottomCell.rightCell == null ? null : this.bottomCell.rightCell;\r\n    }\r\n    /**\r\n     * 右上のセルを返します。\r\n     */\r\n    get topRightCell() {\r\n        return this.topCell == null ? null : this.topCell.rightCell == null ? null : this.topCell.rightCell;\r\n    }\r\n    /**\r\n     * 左下のセルを返します。\r\n     */\r\n    get bottomLeftCell() {\r\n        return this.bottomCell == null ? null : this.bottomCell.leftCell == null ? null : this.bottomCell.leftCell;\r\n    }\r\n    /**\r\n     * 左上のセルを返します。\r\n     */\r\n    get topLeftCell() {\r\n        return this.topCell == null ? null : this.topCell.leftCell == null ? null : this.topCell.leftCell;\r\n    }\r\n    /**\r\n     * このグループセルの上にあるグループセルのマスターセルを返します。\r\n     */\r\n    get topMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.top);\r\n    }\r\n    /**\r\n     * このグループセルの左にあるグループセルのマスターセルを返します。\r\n     */\r\n    get leftMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.left);\r\n    }\r\n    /**\r\n     * このグループセルの右にあるグループセルのマスターセルを返します。\r\n     */\r\n    get rightMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.right);\r\n    }\r\n    /**\r\n     * このグループセルの下にあるグループセルのマスターセルを返します。\r\n     */\r\n    get bottomMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.bottom);\r\n    }\r\n    /**\r\n     * グループセル内の右端にあるせるセルのX座標を返します。\r\n     */\r\n    get mostRightCellX() {\r\n        return this.cellX + this.GroupColumnCount - 1;\r\n    }\r\n    /**\r\n     * グループセル内の下端にあるせるセルのY座標を返します。\r\n     */\r\n    get mostBottomCellY() {\r\n        return this.cellY + this.GroupRowCount - 1;\r\n    }\r\n    /**\r\n     * 指定した方向にあるグループセルの配列を返します。\r\n     * @param direction\r\n     */\r\n    getNextGroupCells(direction) {\r\n        if (this.isMaster) {\r\n            //if(this.isErrorCell) throw new Error(\"error!\");\r\n            let w = [this];\r\n            let now = this.getNextCell(direction);\r\n            while (now != null && this.ID == now.masterID) {\r\n                w.push(now);\r\n                now = now.getNextCell(direction);\r\n                if (this.table.columnCount < w.length && (direction == DirectionType.left || direction == DirectionType.right)) {\r\n                    throw new Error(\"Invalid getNextGroupCells-Loop!\");\r\n                }\r\n            }\r\n            return w;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    /**\r\n    未定義\r\n    */\r\n    get leftSideGroupCells() {\r\n        return this.getNextGroupCells(DirectionType.bottom);\r\n    }\r\n    /**\r\n    未定義\r\n    */\r\n    get upperSideGroupCells() {\r\n        return this.getNextGroupCells(DirectionType.right);\r\n    }\r\n    // #endregion\r\n    /**\r\n     * セルの背景を表すSVGRectElementを作成します。\r\n     * @param className\r\n     */\r\n    /*\r\n    private static createCellRectangle(parent : SVGElement, className: string | null = null): SVGRectElement {\r\n        const rect = <SVGRectElement>document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n        parent.appendChild(rect);\r\n        rect.width.baseVal.value = 30;\r\n        rect.height.baseVal.value = 30;\r\n        if (className == null) {\r\n            rect.style.fill = \"#ffffff\";\r\n        } else {\r\n            SVG.createRectangle(className);\r\n        }\r\n        return rect;\r\n    }\r\n    */\r\n    toPlainText() {\r\n        if (this.isMaster) {\r\n            const textContext = this.svgText.textContent != null ? this.svgText.textContent : \"\";\r\n            if (this.isSingleCell) {\r\n                return textContext;\r\n            }\r\n            else {\r\n                return `${textContext}%%%${this.GroupColumnCount}%%%${this.GroupRowCount}`;\r\n            }\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    // #region update\r\n    updateNodeRelations() {\r\n        this.updateSVGGroupParent();\r\n        this.updateBorderParent();\r\n        //this.updateBorderAttributes();\r\n    }\r\n    /**\r\n     * このセルを更新します。\r\n     */\r\n    update() {\r\n        if (this.table.isNoneMode)\r\n            return;\r\n        const className = this.svgGroup.getAttribute(\"class\");\r\n        if (className != this.__currentClass) {\r\n            this.recomputeDefaultProperties();\r\n            this.__currentClass = className;\r\n        }\r\n        this.resize();\r\n        this.relocation();\r\n    }\r\n    /**\r\n     * svgGroupの親関係を更新します。\r\n     */\r\n    updateSVGGroupParent() {\r\n        if (this.isMaster) {\r\n            if (this.table.rows[this.cellY].svgGroup != this.table.svgGroup) {\r\n                this.table.rows[this.cellY].svgGroup.appendChild(this.svgGroup);\r\n            }\r\n        }\r\n        else {\r\n            this.table.svgHiddenGroup.appendChild(this.svgGroup);\r\n            this.svgText.textContent = \"\";\r\n        }\r\n    }\r\n    get topBorderRow() {\r\n        return this.table.borderRows[this.cellY];\r\n    }\r\n    get bottomBorderRow() {\r\n        return this.table.borderRows[this.cellY + 1];\r\n    }\r\n    get leftBorderColumn() {\r\n        return this.table.borderColumns[this.cellX];\r\n    }\r\n    get rightBorderColumn() {\r\n        return this.table.borderColumns[this.cellX + 1];\r\n    }\r\n    /**\r\n     * 枠の親関係を更新します。\r\n     */\r\n    updateBorderParent() {\r\n        if (this.isMaster || (this.topCell != null && this.topCell.isMaster)) {\r\n            if (this.topBorderRow.svgGroup != this.svgTopBorder.parentNode)\r\n                this.topBorderRow.svgGroup.appendChild(this.svgTopBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgTopBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgTopBorder);\r\n        }\r\n        if (this.isMaster || (this.leftCell != null && this.leftCell.isMaster)) {\r\n            if (this.leftBorderColumn.svgGroup != this.svgLeftBorder.parentNode)\r\n                this.leftBorderColumn.svgGroup.appendChild(this.svgLeftBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgLeftBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgLeftBorder);\r\n        }\r\n        if (this.isMaster || (this.rightCell != null && this.rightCell.isMaster)) {\r\n            if (this.rightBorderColumn.svgGroup != this.svgRightBorder.parentNode)\r\n                this.rightBorderColumn.svgGroup.appendChild(this.svgRightBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgRightBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgRightBorder);\r\n        }\r\n        if (this.isMaster || (this.bottomCell != null && this.bottomCell.isMaster)) {\r\n            if (this.bottomBorderRow.svgGroup != this.svgBottomBorder.parentNode)\r\n                this.bottomBorderRow.svgGroup.appendChild(this.svgBottomBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgBottomBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgBottomBorder);\r\n        }\r\n    }\r\n    /**\r\n     *セルのサイズを再計算します。\r\n     */\r\n    resize() {\r\n        SVGTextBox.sortText(this.svgText, this.horizontalAnchor, this._assurancevisibility);\r\n        const [w, h] = this.calculatedSizeUsingGroup();\r\n        if (this.width != w) {\r\n            this.width = w;\r\n        }\r\n        if (this.height != h) {\r\n            this.height = h;\r\n        }\r\n        if (this.width < this.calculatedWidthUsingText) {\r\n            this.width = this.calculatedWidthUsingText;\r\n        }\r\n        if (this.height < this.calculatedHeightUsingText) {\r\n            this.height = this.calculatedHeightUsingText;\r\n        }\r\n    }\r\n    /**\r\n     * テキストを再描画します。\r\n     */\r\n    locateSVGText() {\r\n        const innerRect = new vline_1.Rectangle();\r\n        innerRect.x = this.innerExtraPaddingLeft + this.paddingLeft;\r\n        innerRect.y = this.paddingTop;\r\n        innerRect.height = this.height - this.paddingTop - this.paddingBottom;\r\n        innerRect.width = this.width - this.innerExtraPaddingLeft - this.innerExtraPaddingRight - this.paddingLeft - this.paddingRight;\r\n        if (this.isLocated) {\r\n            SVGTextExtension.gtSetXY(this.svgText, innerRect, this.verticalAnchor, this.horizontalAnchor, enums_1.AutoSizeShapeToFitText.None);\r\n            //ObsoleteGraph.setXY(this.svgText, innerRect, this.verticalAnchor, this.horizontalAnchor);\r\n        }\r\n    }\r\n    /**\r\n     * 指定した方向の枠を取り除きます。\r\n     * @param dir\r\n     */\r\n    removeBorder(dir) {\r\n        /*\r\n        const border = this._borders[dir];\r\n        if (this.table.svgHiddenGroup.contains(border)) {\r\n            this.table.svgHiddenGroup.removeChild(border);\r\n        } else if (this.table.svgGroup.contains(border)) {\r\n            this.table.svgGroup.removeChild(border);\r\n        } else {\r\n            throw Error(\"error\");\r\n        }\r\n        */\r\n    }\r\n    /**\r\n     * このセルを取り除きます。\r\n     * @param isColumn\r\n     */\r\n    removeFromTable(isColumn) {\r\n        this.svgGroup.remove();\r\n        /*\r\n        if (this.table.svgGroup.contains(this.svgGroup)) {\r\n            this.table.svgGroup.removeChild(this.svgGroup);\r\n        } else if (this.table.svgHiddenGroup.contains(this.svgGroup)) {\r\n            this.table.svgHiddenGroup.removeChild(this.svgGroup);\r\n        } else {\r\n            throw Error(\"error\");\r\n        }\r\n        */\r\n        /*\r\n         if (isColumn) {\r\n             this.removeBorder(DirectionType.top);\r\n             if (this.table.svgGroup.contains(this.svgTopBorder)) {\r\n                 throw Error(\"err\");\r\n             }\r\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\r\n             if (this.leftCell == null) this.removeBorder(DirectionType.left);\r\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\r\n         } else {\r\n\r\n             this.removeBorder(DirectionType.left);\r\n             if (this.rightCell == null) this.removeBorder(DirectionType.right);\r\n             if (this.topCell == null) this.removeBorder(DirectionType.top);\r\n             if (this.bottomCell == null) this.removeBorder(DirectionType.bottom);\r\n         }\r\n         */\r\n    }\r\n    /**\r\n     * このセルが持つ枠の情報を更新します。\r\n     */\r\n    updateBorderAttributes() {\r\n        /*\r\n        if (this.leftCell != null && this.leftCell.svgRightBorder != this.svgLeftBorder) {\r\n            this.removeBorder(DirectionType.left);\r\n            this.svgLeftBorder = this.leftCell.svgRightBorder;\r\n        }\r\n\r\n        if (this.topCell != null && this.topCell.svgBottomBorder != this.svgTopBorder) {\r\n            this.removeBorder(DirectionType.top);\r\n            this.svgTopBorder = this.topCell.svgBottomBorder;\r\n        }\r\n\r\n        if (this.rightCell != null && this.rightCell.svgLeftBorder != this.svgRightBorder) {\r\n            this.rightCell.removeBorder(DirectionType.left);\r\n            this.rightCell.svgLeftBorder = this.svgRightBorder;\r\n        }\r\n\r\n        if (this.bottomCell != null && this.bottomCell.svgTopBorder != this.svgBottomBorder) {\r\n            this.bottomCell.removeBorder(DirectionType.top);\r\n            this.bottomCell.svgTopBorder = this.svgBottomBorder;\r\n        }\r\n        */\r\n        const topCellX = this.svgTopBorder.getAttribute(Cell.borderXName);\r\n        const topCellY = this.svgTopBorder.getAttribute(Cell.borderYName);\r\n        const topCellAttr = this.svgTopBorder.getAttribute(Cell.borderTypeName);\r\n        if (topCellX != `${this.cellX}`)\r\n            this.svgTopBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (topCellY != `${this.cellY}`)\r\n            this.svgTopBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (topCellAttr != `horizontal`)\r\n            this.svgTopBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\r\n        //this.topBorder.setAttribute(\"data-border\", \"top\");\r\n        const leftCellX = this.svgLeftBorder.getAttribute(Cell.borderXName);\r\n        const leftCellY = this.svgLeftBorder.getAttribute(Cell.borderYName);\r\n        const leftCellAttr = this.svgLeftBorder.getAttribute(Cell.borderTypeName);\r\n        if (leftCellX != `${this.cellX}`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (leftCellY != `${this.cellY}`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (leftCellAttr != `vertical`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderTypeName, \"vertical\");\r\n        const rightCellX = this.svgRightBorder.getAttribute(Cell.borderXName);\r\n        const rightCellY = this.svgRightBorder.getAttribute(Cell.borderYName);\r\n        const rightCellAttr = this.svgRightBorder.getAttribute(Cell.borderTypeName);\r\n        if (rightCellX != `${this.cellX + 1}`)\r\n            this.svgRightBorder.setAttribute(Cell.borderXName, `${this.cellX + 1}`);\r\n        if (rightCellY != `${this.cellY}`)\r\n            this.svgRightBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (rightCellAttr != `vertical`)\r\n            this.svgRightBorder.setAttribute(Cell.borderTypeName, \"vertical\");\r\n        const bottomCellX = this.svgBottomBorder.getAttribute(Cell.borderXName);\r\n        const bottomCellY = this.svgBottomBorder.getAttribute(Cell.borderYName);\r\n        const bottomCellAttr = this.svgBottomBorder.getAttribute(Cell.borderTypeName);\r\n        if (bottomCellX != `${this.cellX}`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (bottomCellY != `${this.cellY + 1}`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderYName, `${this.cellY + 1}`);\r\n        if (bottomCellAttr != `horizontal`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\r\n    }\r\n    // #endregion\r\n    // #region relocate\r\n    /**\r\n     * 上枠の位置を再計算します。\r\n     */\r\n    relocateTopBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgTopBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgTopBorder.x1.baseVal.value = this.x;\r\n                this.svgTopBorder.x2.baseVal.value = this.x + this.computeBorderLength2(DirectionType.top);\r\n                this.svgTopBorder.y1.baseVal.value = this.y;\r\n                this.svgTopBorder.y2.baseVal.value = this.svgTopBorder.y1.baseVal.value;\r\n            }\r\n            else if (this.topCell != null && this.topCell.isMaster) {\r\n                this.topCell.relocateBottomBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 左枠の位置を再計算します。\r\n     */\r\n    relocateLeftBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgLeftBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgLeftBorder.x1.baseVal.value = this.x;\r\n                this.svgLeftBorder.x2.baseVal.value = this.svgLeftBorder.x1.baseVal.value;\r\n                this.svgLeftBorder.y1.baseVal.value = this.y;\r\n                this.svgLeftBorder.y2.baseVal.value = this.y + this.computeBorderLength2(DirectionType.left);\r\n            }\r\n            else if (this.leftCell != null && this.leftCell.isMaster) {\r\n                this.leftCell.relocateRightBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 右枠の位置を再計算します。\r\n     */\r\n    relocateRightBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgRightBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgRightBorder.x1.baseVal.value = this.x + this.width;\r\n                this.svgRightBorder.x2.baseVal.value = this.svgRightBorder.x1.baseVal.value;\r\n                this.svgRightBorder.y1.baseVal.value = this.y;\r\n                this.svgRightBorder.y2.baseVal.value = this.y + this.computeBorderLength2(DirectionType.right);\r\n            }\r\n            else if (this.rightCell != null && this.rightCell.isMaster) {\r\n                this.rightCell.relocateLeftBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 下枠の位置を再計算します。\r\n     */\r\n    relocateBottomBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgBottomBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgBottomBorder.x1.baseVal.value = this.x;\r\n                this.svgBottomBorder.x2.baseVal.value = this.x + this.computeBorderLength2(DirectionType.bottom);\r\n                this.svgBottomBorder.y1.baseVal.value = this.y + this.height;\r\n                this.svgBottomBorder.y2.baseVal.value = this.svgBottomBorder.y1.baseVal.value;\r\n            }\r\n            else if (this.bottomCell != null && this.bottomCell.isMaster) {\r\n                this.bottomCell.relocateTopBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *セルの位置を再計算します。\r\n     */\r\n    relocation() {\r\n        if (!CommonFunctions.IsDescendantOfBody(this.svgGroup))\r\n            return;\r\n        this.relocateTopBorder();\r\n        this.relocateLeftBorder();\r\n        this.relocateRightBorder();\r\n        this.relocateBottomBorder();\r\n        this.locateSVGText();\r\n    }\r\n    // #endregion\r\n    // #region merge\r\n    /**\r\n     * 右のグループセルと結合します。\r\n     */\r\n    mergeRight() {\r\n        const range = this.getMergedRangeRight();\r\n        if (range != null) {\r\n            this.merge(range[0], range[1]);\r\n        }\r\n        else {\r\n            throw Error(\"Error\");\r\n        }\r\n    }\r\n    /**\r\n     * 下のグループセルと結合します。\r\n     */\r\n    mergeBottom() {\r\n        const range = this.getMergedRangeBottom();\r\n        if (range != null) {\r\n            this.merge(range[0], range[1]);\r\n        }\r\n        else {\r\n            throw Error(\"Error\");\r\n        }\r\n    }\r\n    /**\r\n     * このセルをマスターセルとした横セル数wかつ縦セル数hのグループセルを作成できるとき、Trueを返します。\r\n     * @param w\r\n     * @param h\r\n     */\r\n    canMerge(w, h) {\r\n        const range = this.table.getRangeCells(this.cellX, this.cellY, w, h);\r\n        for (let x = 0; x < w; x++) {\r\n            const topCell = range[0][x].topCell;\r\n            if (topCell != null) {\r\n                if (range[0][x].masterID == topCell.masterID)\r\n                    return false;\r\n            }\r\n            const bottomCell = range[h - 1][x].bottomCell;\r\n            if (bottomCell != null) {\r\n                if (range[h - 1][x].masterID == bottomCell.masterID)\r\n                    return false;\r\n            }\r\n        }\r\n        for (let y = 0; y < h; y++) {\r\n            const leftCell = range[y][0].leftCell;\r\n            if (leftCell != null) {\r\n                if (range[y][0].masterID == leftCell.masterID)\r\n                    return false;\r\n            }\r\n            const rightCell = range[y][w - 1].rightCell;\r\n            if (rightCell != null) {\r\n                if (range[y][w - 1].masterID == rightCell.masterID)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * このセルをマスターセルとした横セル数wかつ縦セル数hのグループセルを作成します。\r\n     * @param w\r\n     * @param h\r\n     */\r\n    merge(w, h) {\r\n        if (!this.isMaster)\r\n            throw Error(\"Error\");\r\n        const range = this.table.getRangeCellArray(this.cellX, this.cellY, w, h);\r\n        range.forEach((v) => { v.setMasterCellX(this.masterCellX); v.setMasterCellY(this.masterCellY); });\r\n        range.forEach((v) => { v.updateNodeRelations(); v.update(); });\r\n    }\r\n    /**\r\n     * このセルから見て右にあるグループセルとこのセルが属しているグループセルが結合できるとき、そのグループセルの左上のY座標と左下のY座標を返します。\r\n     * さもなければnullを返します。\r\n     */\r\n    getMergedRangeRight() {\r\n        if (!this.isMaster)\r\n            return null;\r\n        if (this.rightMasterCell != null) {\r\n            const b1 = this.cellY == this.rightMasterCell.cellY;\r\n            const b2 = this.GroupRowCount == this.rightMasterCell.GroupRowCount;\r\n            if (b1 && b2) {\r\n                return [this.GroupColumnCount + this.rightMasterCell.GroupColumnCount, this.GroupRowCount];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * このセルから見て下にあるグループセルとこのセルが属しているグループセルが結合できるとき、そのグループセルの左上のX座標と右上のX座標を返します。\r\n     * さもなければnullを返します。\r\n     */\r\n    getMergedRangeBottom() {\r\n        if (!this.isMaster)\r\n            return null;\r\n        if (this.bottomMasterCell != null) {\r\n            const b1 = this.cellX == this.bottomMasterCell.cellX;\r\n            const b2 = this.GroupColumnCount == this.bottomMasterCell.GroupColumnCount;\r\n            if (b1 && b2) {\r\n                return [this.GroupColumnCount, this.GroupRowCount + this.bottomMasterCell.GroupRowCount];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * 右のセルと結合できるときTrueを返します。\r\n     */\r\n    get canMergeRight() {\r\n        return this.getMergedRangeRight() != null;\r\n    }\r\n    /**\r\n     * 下のセルと結合できるときTrueを返します。\r\n     */\r\n    get canMergeBottom() {\r\n        return this.getMergedRangeBottom() != null;\r\n    }\r\n    // #endregion\r\n    // #region decompose\r\n    decomposeRow(upperRowCount) {\r\n        if (this.isMaster) {\r\n            const upperSide = this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, upperRowCount);\r\n            const lowerSide = this.table.getRangeCellArray(this.cellX, this.cellY + upperRowCount, this.GroupColumnCount, this.GroupRowCount - upperRowCount);\r\n            const lowerMaster = lowerSide[0];\r\n            lowerSide.forEach((v) => {\r\n                v.setMasterCellX(lowerMaster.cellX);\r\n                v.setMasterCellY(lowerMaster.cellY);\r\n            });\r\n            upperSide.forEach((v) => v.update());\r\n            lowerSide.forEach((v) => v.update());\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    decomposeColomn(leftColumnCount) {\r\n        if (this.isMaster) {\r\n            const leftSide = this.table.getRangeCellArray(this.cellX, this.cellY, leftColumnCount, this.GroupRowCount);\r\n            const rightSide = this.table.getRangeCellArray(this.cellX + leftColumnCount, this.cellY, this.GroupColumnCount - leftColumnCount, this.GroupRowCount);\r\n            const rightMaster = rightSide[0];\r\n            rightSide.forEach((v) => {\r\n                v.setMasterCellX(rightMaster.cellX);\r\n                v.setMasterCellY(rightMaster.cellY);\r\n            });\r\n            leftSide.forEach((v) => v.update());\r\n            rightSide.forEach((v) => v.update());\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n}\r\n// #endregion\r\n// #region field\r\n//private static readonly defaultBackgroundClassName: string = \"--default-background-class\";\r\n//\r\nCell.cellXName = \"data-cellX\";\r\nCell.cellYName = \"data-cellY\";\r\nCell.borderXName = \"data-borderX\";\r\nCell.borderYName = \"data-borderY\";\r\nCell.borderTypeName = \"data-borderType\";\r\nCell.masterIDName = \"data-masterID\";\r\nCell.masterDiffXName = \"data-masterDiffX\";\r\nCell.masterDiffYName = \"data-masterDiffY\";\r\nexports.Cell = Cell;\r\n//}\r\n//# sourceMappingURL=cell.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/table_helpers/column.js":
/*!***************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/table_helpers/column.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js\");\r\n//import {BorderRow} from \"./border_row\"\r\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\n/**\r\n * 表の列を表現するクラスです。\r\n */\r\nclass CellColumn {\r\n    constructor(_table, _x, _width = 30) {\r\n        this.table = _table;\r\n        this._svgGroup = SVG.createGroup(this.table.svgGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"cell_column\");\r\n        //this.table.svgGroup.appendChild(this._svgGroup);\r\n        this.cellX = _x;\r\n        this._svgGroup.setAttribute(CellColumn.rowWidthName, `${_width}`);\r\n        //this.width = this.getMaxWidth();\r\n    }\r\n    /**\r\n    列の単位セルのX座標を返します。\r\n    */\r\n    get cellX() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellXName));\r\n    }\r\n    set cellX(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellXName, `${v}`);\r\n        this.cells.forEach((w) => w.cellX = v);\r\n    }\r\n    //public defaultWidth : number | null = null;\r\n    /**\r\n    列の幅を返します。\r\n    */\r\n    get width() {\r\n        return Number(this._svgGroup.getAttribute(CellColumn.rowWidthName));\r\n    }\r\n    /**\r\n    列の幅を設定します。\r\n    */\r\n    set width(value) {\r\n        this._svgGroup.setAttribute(CellColumn.rowWidthName, `${value}`);\r\n        this.setWidthToCells();\r\n        /*\r\n        let b = false;\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (cell.isColumnSingleCell && cell.width != value) {\r\n                cell.width = value;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (!cell.isColumnSingleCell) {\r\n                cell.update();\r\n                //cell.resize();\r\n                b = true;\r\n            }\r\n        }\r\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\r\n        */\r\n    }\r\n    setWidthToCells() {\r\n        //const width = this.defaultWidth == null ? this.width : this.defaultWidth;\r\n        const width = this.width;\r\n        let b = false;\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (cell.isMasterCellOfColumnCountOne && cell.width != width) {\r\n                cell.width = width;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (!cell.isMasterCellOfColumnCountOne) {\r\n                cell.update();\r\n                //cell.resize();\r\n                b = true;\r\n            }\r\n        }\r\n        // TODO : implement the event of the below code.\r\n        //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\r\n    }\r\n    /**\r\n     * この列のセルの配列を返します。\r\n     */\r\n    get cells() {\r\n        const items = [];\r\n        for (let i = 0; i < this.table.rowCount; i++) {\r\n            //if(this.table.rows[i].cells.length <= this.cellX) throw new Error(\"error\");\r\n            items.push(this.table.rows[i].cells[this.cellX]);\r\n        }\r\n        return items;\r\n    }\r\n    get length() {\r\n        return this.cells.length;\r\n    }\r\n    /**\r\n     * この列に属しているセルの中で最大の横幅を返します。\r\n     */\r\n    getMaxWidth() {\r\n        let width = 0;\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (cell.isMasterCellOfColumnCountOne) {\r\n                if (width < cell.calculatedWidthUsingText)\r\n                    width = cell.calculatedWidthUsingText;\r\n                if (width < cell.width)\r\n                    width = cell.width;\r\n            }\r\n        }\r\n        return width;\r\n    }\r\n    /**\r\n     * この列を更新します。\r\n     */\r\n    /*\r\n     public update() {\r\n        this.setWidthToCells();\r\n        //this.width = this.getMaxWidth();\r\n    }\r\n    */\r\n    /**\r\n     * 列内のセルのサイズを再計算します。\r\n     */\r\n    resize() {\r\n        this.cells.forEach((v) => v.update());\r\n        this.setWidthToCells();\r\n        //this.width = (this.getMaxWidth());\r\n    }\r\n    /**\r\n     * セルの元々のサイズに合わせて列のサイズを調整します。\r\n     * @param allowShrink 現在の列の幅より短くなることを許す\r\n     */\r\n    fitWidthToOriginalCell(allowShrink) {\r\n        if (allowShrink) {\r\n            this.width = this.getMaxWidth();\r\n        }\r\n        else {\r\n            this.width = Math.max(this.width, this.getMaxWidth());\r\n        }\r\n    }\r\n    /**\r\n     * 列のX座標を設定します。\r\n     * @param posX\r\n     */\r\n    setX(posX) {\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            cell.x = posX;\r\n        }\r\n    }\r\n    /**\r\n     * この列の左の枠を配列で返します。\r\n     */\r\n    get leftBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgLeftBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgLeftBorder)\r\n                    r.push(v.svgLeftBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    /**\r\n     * この列の右の枠を配列で返します。\r\n     */\r\n    get rightBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgRightBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgRightBorder)\r\n                    r.push(v.svgRightBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    /**\r\n     * この列の上の枠を返します。\r\n     */\r\n    get topBorder() {\r\n        return this.cells[0].svgTopBorder;\r\n    }\r\n    /**\r\n     * この列の下の枠を返します。\r\n     */\r\n    get bottomBorder() {\r\n        const cells = this.cells;\r\n        return cells[cells.length - 1].svgBottomBorder;\r\n    }\r\n    get selfx() {\r\n        for (let i = 0; i < this.table.columnCount; i++) {\r\n            if (this.table.columns[i] == this) {\r\n                return i;\r\n            }\r\n        }\r\n        throw new Error(\"error\");\r\n    }\r\n    /**\r\n     * この列を取り除きます。\r\n     * @param isUnit\r\n     */\r\n    _dispose() {\r\n        /*\r\n        while (this.length > 0){\r\n            const x = this.length - 1;\r\n            this.cells[x].removeFromTable(false);\r\n            this.cells.splice(x, 1);\r\n        }\r\n        */\r\n        const x = this.selfx;\r\n        this.table.rows.forEach((v, i) => v._removeCell(x));\r\n        this._svgGroup.remove();\r\n        /*\r\n        if (isUnit) {\r\n            if (this.table.columns.length > 1) {\r\n                this.table.columns[this.cellX].cells.forEach((v) => {\r\n                    v.removeFromTable(true);\r\n                    this.table.cells[v.cellY].splice(this.cellX, 1);\r\n                });\r\n\r\n\r\n                this.table.columns.splice(this.cellX, 1);\r\n                this.table.columns.forEach((v, i) => v.cellX = i);\r\n                this.table.svgGroup.removeChild(this._svgGroup);\r\n                this.table.update();\r\n            } else if (this.table.columns.length == 1) {\r\n                while (this.table.rows.length > 0) {\r\n                    this.table.rows[this.table.rows.length - 1].remove(true);\r\n                }\r\n                if (this.table.columns.length == 1) this.table.columns.splice(0, 1);\r\n            } else {\r\n                throw Error(\"error\");\r\n            }\r\n        } else {\r\n            const [b, e] = this.groupColumnRange;\r\n            for (let x = e; x >= b; x--) {\r\n                this.table.columns[x].remove(true);\r\n            }\r\n        }\r\n        */\r\n    }\r\n    /**\r\n     * この列のセルの位置を再計算します。\r\n     */\r\n    relocation() {\r\n        this.cells.forEach((v) => v.relocation());\r\n    }\r\n    /**\r\n     * この列に属しているグループセルによって関係している列の範囲を返します。\r\n     */\r\n    get groupColumnRange() {\r\n        let range = this.cells[0].groupColumnRange;\r\n        this.cells.forEach((v) => {\r\n            if (range != null) {\r\n                range = cell_1.Cell.computeDisjunction(range, v.groupColumnRange);\r\n            }\r\n        });\r\n        if (range == null) {\r\n            throw Error(\"error\");\r\n        }\r\n        else {\r\n            return range;\r\n        }\r\n    }\r\n}\r\n//private readonly _cellX: number;\r\nCellColumn.rowWidthName = \"data-width\";\r\nexports.CellColumn = CellColumn;\r\n//}\r\n//# sourceMappingURL=column.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/table_helpers/column.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/objects/table_helpers/row.js":
/*!************************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/objects/table_helpers/row.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {    \r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"./node_modules/graph-table-svg/dist/objects/table_helpers/cell.js\");\r\nconst SVG = __webpack_require__(/*! ../../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\n/**\r\n * 表の行を表現するクラスです。\r\n */\r\nclass CellRow {\r\n    constructor(_table, _y, _height = 30) {\r\n        /*\r\n        public removeCell(i: number) {\r\n            this.cells[i].removeFromTable(false);\r\n            //this.cells.forEach((v) => v.removeFromTable(false));\r\n            this.cells.splice(i, 1);\r\n        }\r\n\r\n        */\r\n        this._cells = [];\r\n        this.table = _table;\r\n        this._svgGroup = SVG.createGroup(this.table.svgGroup);\r\n        this.svgGroup.setAttribute(\"name\", \"cell_row\");\r\n        this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgRowBorderGroup);\r\n        this.cellY = _y;\r\n        this._svgGroup.setAttribute(CellRow.columnHeightName, `${_height}`);\r\n        /*\r\n        for(let i=0;i<cellCount;i++){\r\n            this._cells.push(this.createCell(i, _y));\r\n        }\r\n        */\r\n        //this.height = this.getMaxHeight();\r\n    }\r\n    createCell(cellX, cellY) {\r\n        const cellClass = undefined; //this.table.defaultCellClass == null ? undefined : this.table.defaultCellClass;\r\n        const borderClass = undefined;\r\n        //this.table.defaultBorderClass == null ? undefined : this.table.defaultBorderClass;\r\n        const option = { cellClass: cellClass, borderClass: borderClass };\r\n        return new cell_1.Cell(this.table, cellX, cellY, option);\r\n    }\r\n    _insertCell(i) {\r\n        const cell = this.createCell(i, this.cellY);\r\n        this.cells.splice(i, 0, cell);\r\n    }\r\n    _appendCell(num = 1) {\r\n        for (let i = 0; i < num; i++) {\r\n            const cell = this.createCell(this.cells.length, this.cellY);\r\n            this.cells.push(cell);\r\n        }\r\n    }\r\n    get cells() {\r\n        return this._cells;\r\n    }\r\n    get length() {\r\n        return this.cells.length;\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    /**\r\n    列の単位セルのY座標を返します。\r\n    */\r\n    get cellY() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set cellY(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n        this.cells.forEach((w) => w.cellY = v);\r\n    }\r\n    /**\r\n    行の高さを返します。\r\n    */\r\n    get height() {\r\n        return Number(this._svgGroup.getAttribute(CellRow.columnHeightName));\r\n    }\r\n    /**\r\n    行の高さを設定します。\r\n    */\r\n    set height(value) {\r\n        this._svgGroup.setAttribute(CellRow.columnHeightName, `${value}`);\r\n        this.setHeightToCells();\r\n        /*\r\n        let b = false;\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (cell.isRowSingleCell && cell.height != value) {\r\n                cell.height = value;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (!cell.isRowSingleCell) {\r\n                cell.update();\r\n                //cell.resize();\r\n                b = true;\r\n            }\r\n        }\r\n        if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\r\n        */\r\n    }\r\n    /**\r\n     * この行のセル配列を返します。\r\n     */\r\n    /*\r\n     public get cells(): Cell[] {\r\n        return this.table.cells[this.cellY];\r\n    }\r\n    */\r\n    /**\r\n     * この行のセルの上にある枠の配列を返します。\r\n     */\r\n    get topBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgTopBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgTopBorder)\r\n                    r.push(v.svgTopBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    /**\r\n     * この行のセルの下にある枠の配列を返します。\r\n     */\r\n    get bottomBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgBottomBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgBottomBorder)\r\n                    r.push(v.svgBottomBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    /**\r\n     * この行のセルの左にある枠を返します。\r\n     */\r\n    get leftBorder() {\r\n        return this.cells[0].svgLeftBorder;\r\n    }\r\n    /**\r\n     * この行のセルの右にある枠を返します。\r\n     */\r\n    get rightBorder() {\r\n        const cells = this.cells;\r\n        return cells[cells.length - 1].svgRightBorder;\r\n    }\r\n    setHeightToCells() {\r\n        const height = this.height;\r\n        let b = false;\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (cell.isMasterCellOfRowCountOne && cell.height != height) {\r\n                cell.height = height;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (!cell.isMasterCellOfRowCountOne) {\r\n                cell.update();\r\n                //cell.resize();\r\n                b = true;\r\n            }\r\n        }\r\n        // TODO : implement the event of the below code.\r\n        //if (b && !this.table.isDrawing && this.table.isAutoResized) this.table.update();\r\n    }\r\n    /**\r\n     * この行を更新します。\r\n     */\r\n    /*\r\n     public update() {\r\n        this.setHeightToCells();\r\n        //this.height = this.getMaxHeight();\r\n    }\r\n    */\r\n    /**\r\n     * 行内のセルのサイズを再計算します。\r\n     */\r\n    resize() {\r\n        this.cells.forEach((v) => v.update());\r\n        this.setHeightToCells();\r\n        //this.height = this.getMaxHeight();\r\n    }\r\n    /**\r\n     * セルの元々のサイズに合わせて行のサイズを調整します。\r\n     * @param allowShrink 現在の行の幅より短くなることを許す\r\n     */\r\n    fitHeightToOriginalCell(allowShrink) {\r\n        if (allowShrink) {\r\n            this.height = this.getMaxHeight();\r\n        }\r\n        else {\r\n            this.height = Math.max(this.height, this.getMaxHeight());\r\n        }\r\n    }\r\n    /**\r\n     * 行内のセルのY座標を設定します。\r\n     *\r\n     */\r\n    setY(posY) {\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            cell.y = posY;\r\n        }\r\n    }\r\n    /**\r\n     * この行の最大の縦幅を持つセルの縦幅を返します。\r\n     */\r\n    getMaxHeight() {\r\n        let height = 0;\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (cell.isMasterCellOfRowCountOne) {\r\n                if (height < cell.calculatedHeightUsingText)\r\n                    height = cell.calculatedHeightUsingText;\r\n                if (height < cell.height)\r\n                    height = cell.height;\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n    get selfy() {\r\n        for (let i = 0; i < this.table.rowCount; i++) {\r\n            if (this.table.rows[i] == this) {\r\n                return i;\r\n            }\r\n        }\r\n        throw new Error(\"error\");\r\n    }\r\n    _dispose() {\r\n        while (this.length > 0) {\r\n            const x = this.length - 1;\r\n            this._removeCell(x);\r\n        }\r\n        this.svgGroup.remove();\r\n        //this.rows.splice(this.rows[i].selfy, 1);\r\n    }\r\n    _removeCell(i) {\r\n        this.cells[i].removeFromTable(false);\r\n        this.cells.splice(i, 1);\r\n    }\r\n    /**\r\n     * この行を取り除きます。\r\n     * @param isUnit\r\n     */\r\n    /*\r\n    public remove(isUnit: boolean = false) {\r\n        while (this.cells.length > 0) this.removeCell(this.cells.length - 1);\r\n        this.svgGroup.remove();\r\n        this.table.rows.splice(this.selfy, 1);\r\n    }\r\n    */\r\n    /*\r\n    public updateBorders() {\r\n        this.cells.forEach((v) => v.updateBorder());\r\n    }\r\n    */\r\n    /**\r\n     * この行の各セルを再配置します。\r\n     */\r\n    //public relocation() {\r\n    //    this.cells.forEach((v) => v.relocation());\r\n    //}\r\n    /**\r\n     * この行に属しているグループセルによって関係している行の範囲を返します。\r\n     */\r\n    get groupRowRange() {\r\n        let range = this.cells[0].groupRowRange;\r\n        this.cells.forEach((v) => {\r\n            if (range != null) {\r\n                range = cell_1.Cell.computeDisjunction(range, v.groupRowRange);\r\n            }\r\n        });\r\n        if (range == null) {\r\n            throw Error(\"error\");\r\n        }\r\n        else {\r\n            return range;\r\n        }\r\n    }\r\n}\r\nCellRow.columnHeightName = \"data-height\";\r\nexports.CellRow = CellRow;\r\n//}\r\n//# sourceMappingURL=row.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/objects/table_helpers/row.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/console.js":
/*!**************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/console.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst table_dictionary_1 = __webpack_require__(/*! ./table_dictionary */ \"./node_modules/graph-table-svg/dist/options/table_dictionary.js\");\r\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\n//import { CommonFunctions } from \"../common/common_functions\";\r\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./node_modules/graph-table-svg/dist/options/open_svg.js\");\r\nconst SVGTextBox = __webpack_require__(/*! ../interfaces/svg_textbox */ \"./node_modules/graph-table-svg/dist/interfaces/svg_textbox.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst SVG = __webpack_require__(/*! ../interfaces/svg */ \"./node_modules/graph-table-svg/dist/interfaces/svg.js\");\r\nconst CSS = __webpack_require__(/*! ../html/css */ \"./node_modules/graph-table-svg/dist/html/css.js\");\r\nconst VBAMacroModal = __webpack_require__(/*! ./vba_macro_modal */ \"./node_modules/graph-table-svg/dist/options/vba_macro_modal.js\");\r\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./node_modules/graph-table-svg/dist/options/svg_to_vba.js\");\r\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./node_modules/graph-table-svg/dist/html/gui_observer.js\");\r\nconst g_table_1 = __webpack_require__(/*! ../objects/g_table */ \"./node_modules/graph-table-svg/dist/objects/g_table.js\");\r\nconst g_graph_1 = __webpack_require__(/*! ../objects/g_graph */ \"./node_modules/graph-table-svg/dist/objects/g_graph.js\");\r\n//export namespace Console {\r\nclass ConsoleLineElement {\r\n    constructor(parent, type, title = \"\", option = {}) {\r\n        this.canvas = null;\r\n        this.vbaObjects = new Array();\r\n        this.mainObject = null;\r\n        this.canvasContainer = document.createElement(\"div\");\r\n        parent.appendChild(this.canvasContainer);\r\n        this.fieldSetElement = document.createElement(\"fieldset\");\r\n        this.canvasContainer.appendChild(this.fieldSetElement);\r\n        this.legendElement = document.createElement(\"legend\");\r\n        this.fieldSetElement.appendChild(this.legendElement);\r\n        this.title = title;\r\n        const createCanvas = type == \"table\" || type == \"graph\" || type == \"log\";\r\n        const createVBAButton = type == \"table\" || type == \"graph\" || type == \"log\";\r\n        if (createCanvas) {\r\n            this.canvas = ConsoleLineElement.addSVGSVGElement(this.fieldSetElement);\r\n            GUIObserver.observeSVGSVG(this.canvas);\r\n        }\r\n        if (option.mainElement !== undefined) {\r\n            if (option.mainElement instanceof HTMLElement) {\r\n                this.fieldSetElement.appendChild(option.mainElement);\r\n            }\r\n        }\r\n        /*\r\n        this.pngButton = document.createElement(\"button\");\r\n        this.pngButton.textContent = \"PNG\";\r\n        const pngFunc = () =>{\r\n            const _canvas = PNG.createPNGFromSVGSVGElement(this.canvas);\r\n            this.canvasContainer.appendChild(_canvas);\r\n\r\n        }\r\n        this.pngButton.onclick = pngFunc;\r\n        */\r\n        //this.canvasContainer.appendChild(this.pngButton);\r\n        //this.pngButton.setAttribute(\"hidden\", \"1\");\r\n        this.removeButton = document.createElement(\"button\");\r\n        this.removeButton.textContent = \"remove\";\r\n        this.fieldSetElement.appendChild(this.removeButton);\r\n        const removeFunc = () => {\r\n            this.fieldSetElement.remove();\r\n        };\r\n        this.removeButton.onclick = removeFunc;\r\n        this.macroButton = document.createElement(\"button\");\r\n        this.macroButton.textContent = \"VBA\";\r\n        if (createVBAButton) {\r\n            this.fieldSetElement.appendChild(this.macroButton);\r\n        }\r\n        const vbaFunc = () => {\r\n            VBAMacroModal.createMacroModal(svg_to_vba_1.SVGToVBA.create(this.vbaObjects));\r\n        };\r\n        this.macroButton.onclick = vbaFunc;\r\n        const createCSVButton = type == \"table\";\r\n        this.csvButton = document.createElement(\"button\");\r\n        this.csvButton.textContent = \"csv\";\r\n        if (createCSVButton) {\r\n            this.fieldSetElement.appendChild(this.csvButton);\r\n        }\r\n        const csvFunc = () => {\r\n            if (this.mainObject instanceof g_table_1.GTable) {\r\n                const str = this.mainObject.rows.map((v) => {\r\n                    return v.cells.map((w) => w.svgText.textContent).join(\",\");\r\n                }).join(\"\\n\");\r\n                textarea(str, this.title);\r\n            }\r\n        };\r\n        this.csvButton.onclick = csvFunc;\r\n    }\r\n    get title() {\r\n        return this.legendElement.textContent;\r\n    }\r\n    set title(value) {\r\n        this.legendElement.textContent = value;\r\n        this.legendElement.style.fontWeight = \"bold\";\r\n    }\r\n    addVBAObject(obj) {\r\n        this.vbaObjects.push(obj);\r\n        if (obj instanceof g_table_1.GTable || obj instanceof g_graph_1.GGraph) {\r\n            this.mainObject = obj;\r\n        }\r\n    }\r\n    static addSVGSVGElement(code) {\r\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        //const p = document.createElement(\"p\");\r\n        //code.appendChild(p);\r\n        //p.appendChild(svg);\r\n        code.appendChild(svg);\r\n        svg.setAttribute(\"style\", \"background:#e9e9e9;border:solid 1pt;padding:10px\");\r\n        //svg.setAttribute(\"style\", \"background:#e9e9e9;\");\r\n        //svg.setAttribute(\"width\", \"600px\");\r\n        //svg.setAttribute(\"height\", \"600px\");\r\n        svg.setAttribute(\"g-shrink\", \"true\");\r\n        if (svg instanceof SVGSVGElement) {\r\n            return svg;\r\n        }\r\n        else {\r\n            throw \"error\";\r\n        }\r\n    }\r\n}\r\nexports.ConsoleLineElement = ConsoleLineElement;\r\nfunction getCodeTag() {\r\n    const collection = document.getElementsByTagName(\"code\");\r\n    for (let i = 0; i < collection.length; i++) {\r\n        const item = collection.item(i);\r\n        if (item != null) {\r\n            const name = item.getAttribute(\"name\");\r\n            if (name == \"GraphTableSVG\") {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getOrCreateCodeElement() {\r\n    CSS.setGraphTableCSS();\r\n    const code = getCodeTag();\r\n    if (code != null) {\r\n        return code;\r\n    }\r\n    else {\r\n        const element = document.createElement(\"code\");\r\n        document.body.appendChild(element);\r\n        element.setAttribute(\"name\", \"GraphTableSVG\");\r\n        return element;\r\n    }\r\n}\r\n/*\r\nfunction initialize(): void {\r\n    const code = getCodeTag();\r\n    if (code == null) {\r\n        createCodeTag();\r\n    }\r\n}\r\n*/\r\nfunction table(item, title = \"\") {\r\n    if (item instanceof logic_table_1.LogicTable) {\r\n        const code = getOrCreateCodeElement();\r\n        const consoleLine = new ConsoleLineElement(code, \"table\", title);\r\n        //const svg = addSVGSVGElement(code);\r\n        const gtable = open_svg_1.createShape(consoleLine.canvas, \"g-table\");\r\n        gtable.constructFromLogicTable(item);\r\n        gtable.x = 0;\r\n        gtable.y = 0;\r\n        consoleLine.addVBAObject(gtable);\r\n        //consoleLine.addVBAObject(gtable);\r\n        //consoleLine.title = title;\r\n    }\r\n    else {\r\n        const tableDic = new table_dictionary_1.TableDictionary();\r\n        tableDic.construct(item);\r\n        const logicTable = tableDic.toLogicTable();\r\n        table(logicTable, title);\r\n    }\r\n}\r\nexports.table = table;\r\nfunction clear() {\r\n    const code = getOrCreateCodeElement();\r\n    code.innerHTML = \"\";\r\n}\r\nexports.clear = clear;\r\nfunction graph(item, title = \"\", canvasID = null) {\r\n    if (item instanceof logic_tree_1.LogicTree || item instanceof logic_tree_1.LogicGraph) {\r\n        if (canvasID != null) {\r\n            const ggraph = open_svg_1.createShape(canvasID, \"g-graph\");\r\n            ggraph.build(item);\r\n            return [ggraph, null];\r\n        }\r\n        else {\r\n            const code = getOrCreateCodeElement();\r\n            const consoleLine = new ConsoleLineElement(code, \"graph\", title);\r\n            //const svg = addSVGSVGElement(code);\r\n            const ggraph = open_svg_1.createShape(consoleLine.canvas, \"g-graph\");\r\n            ggraph.build(item);\r\n            consoleLine.addVBAObject(ggraph);\r\n            return [ggraph, consoleLine];\r\n        }\r\n        /*\r\n        if(item instanceof LogicGraph){\r\n        }else{\r\n            ggraph.constructFromLogicTree(item);\r\n        }\r\n        */\r\n    }\r\n    else {\r\n        const tableDic = new table_dictionary_1.TableDictionary();\r\n        tableDic.construct(item);\r\n        const logicGraph = tableDic.toLogicGraph();\r\n        return graph(logicGraph, title, canvasID);\r\n        //console.log(logicGraph);    \r\n    }\r\n}\r\nexports.graph = graph;\r\nfunction log(message, title = \"\") {\r\n    const code = getOrCreateCodeElement();\r\n    const consoleLine = new ConsoleLineElement(code, \"log\", title);\r\n    const textClass = DefaultClassNames.defaultTextClass;\r\n    const textElement = SVG.createText(textClass);\r\n    //const text = document.createElementNS('http://www.w3.org/2000/svg', \"text\");\r\n    //text.textContent = message;\r\n    consoleLine.canvas.appendChild(textElement);\r\n    SVGTextBox.setTextToSVGText(textElement, message, false);\r\n    textElement.setAttribute(\"x\", \"0\");\r\n    const b2 = SVGTextBox.getSize(textElement, true);\r\n    textElement.setAttribute(\"y\", b2.height.toString());\r\n    consoleLine.addVBAObject(textElement);\r\n    //table(message);\r\n    return consoleLine;\r\n}\r\nexports.log = log;\r\nfunction getRowCount(line, cols) {\r\n    return Math.ceil(line.length / cols);\r\n}\r\nfunction textarea(message, title = \"\", option) {\r\n    const code = getOrCreateCodeElement();\r\n    const textArea = document.createElement(\"textarea\");\r\n    textArea.textContent = message;\r\n    const lines = message.split(\"\\n\");\r\n    let maxCols = 0;\r\n    lines.forEach((v) => {\r\n        if (v.length > maxCols) {\r\n            maxCols = v.length;\r\n        }\r\n    });\r\n    const defaultCols = maxCols < 240 ? maxCols + 5 : 245;\r\n    const newOption = option === undefined ? {} : option;\r\n    textArea.cols = newOption.cols === undefined ? defaultCols : newOption.cols;\r\n    let rowCount = 0;\r\n    lines.forEach((v) => rowCount += getRowCount(v, textArea.cols));\r\n    textArea.rows = newOption.rows === undefined ? rowCount : newOption.rows;\r\n    const consoleLine = new ConsoleLineElement(code, \"textarea\", title, { mainElement: textArea });\r\n    consoleLine.title = title;\r\n    //const canvasContainer = document.createElement(\"div\");\r\n    //code.appendChild(canvasContainer);                \r\n    //consoleLine.canvasContainer.appendChild(textArea);\r\n    return consoleLine;\r\n}\r\nexports.textarea = textarea;\r\nfunction view(item) {\r\n    if (item instanceof logic_table_1.LogicTable) {\r\n        table(item);\r\n    }\r\n    else if (item instanceof logic_tree_1.LogicTree) {\r\n        graph(item);\r\n    }\r\n    else {\r\n        graph(item);\r\n    }\r\n}\r\nexports.view = view;\r\n//}\r\n//# sourceMappingURL=console.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/console.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/debug.js":
/*!************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/debug.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\n//export namespace Debug {\r\nfunction randomTreeArray(node_num, max_degree) {\r\n    const nodes = new Array(0);\r\n    const root = new logic_tree_1.LogicTree();\r\n    nodes.push(root);\r\n    while (nodes.length < node_num) {\r\n        var random = Math.floor(Math.random() * nodes.length);\r\n        const parent = nodes[random];\r\n        if (parent.children.length < max_degree) {\r\n            const child = new logic_tree_1.LogicTree();\r\n            parent.children.push(child);\r\n            nodes.push(child);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n/*\r\nfunction randomBinaryTreeArray(node_num : number) : BinaryLogicTree[] {\r\n    const nodes : BinaryLogicTree[] = new Array(0);\r\n    const root = new BinaryLogicTree();\r\n    nodes.push(root);\r\n\r\n    while(nodes.length < node_num){\r\n        var random = Math.floor( Math.random()*nodes.length );\r\n        var leftOrRight = Math.floor( Math.random()*2 );\r\n\r\n        const parent = nodes[random];\r\n\r\n        if(leftOrRight == 0 && parent.left == null){\r\n            const child = new BinaryLogicTree();\r\n            parent.left = child;\r\n            nodes.push(child);\r\n        }else if(leftOrRight == 1 && parent.right == null){\r\n            const child = new BinaryLogicTree();\r\n            parent.right = child;\r\n            nodes.push(child);\r\n\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n*/\r\nfunction randomTree(node_num, max_degree) {\r\n    return randomTreeArray(node_num, max_degree)[0];\r\n}\r\nexports.randomTree = randomTree;\r\nfunction randomBinaryTree(node_num) {\r\n    return randomTree(node_num, 2);\r\n}\r\nexports.randomBinaryTree = randomBinaryTree;\r\nconst labels = [\"a\", \"b\", \"c\", \"あ\", \"e\", \"f\", \"g\"];\r\nfunction randomTrie(node_num, max_degree) {\r\n    const nodes = randomTreeArray(node_num, max_degree);\r\n    for (let i = 1; i < nodes.length; i++) {\r\n        var randomLabelNumber = Math.floor(Math.random() * labels.length);\r\n        nodes[i].edgeOption.text = labels[randomLabelNumber];\r\n    }\r\n    return nodes[0];\r\n}\r\nexports.randomTrie = randomTrie;\r\nfunction randomLabeledTree(node_num, max_degree, max_string_length) {\r\n    const nodes = randomTreeArray(node_num, max_degree);\r\n    for (let i = 1; i < nodes.length; i++) {\r\n        var strLen = Math.floor(Math.random() * max_string_length);\r\n        let s = \"\";\r\n        for (let x = 0; x < strLen; x++) {\r\n            var randomLabelNumber = Math.floor(Math.random() * labels.length);\r\n            if (randomLabelNumber < 4) {\r\n                s += labels[randomLabelNumber];\r\n            }\r\n        }\r\n        nodes[i].edgeOption.text = s;\r\n    }\r\n    return nodes[0];\r\n}\r\nexports.randomLabeledTree = randomLabeledTree;\r\nfunction randomBinaryTrie(node_num) {\r\n    const node = randomTrie(node_num, 2);\r\n    return node;\r\n}\r\nexports.randomBinaryTrie = randomBinaryTrie;\r\n/*\r\nexport function randomTrie(node_num : number, max_degree : number) : LogicTree {\r\n    const nodes = randomTreeArray(node_num, max_degree);\r\n    for(let i=1;i<nodes.length;i++){\r\n        var randomLabelNumber = Math.floor( Math.random()* labels.length );\r\n        nodes[i].parentEdgeText = labels[randomLabelNumber];\r\n        \r\n    }\r\n    return nodes[0];\r\n}\r\n*/\r\n//}\r\n//# sourceMappingURL=debug.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/debug.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/html_table.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/html_table.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\n//export namespace HTMLFunctions {\r\nfunction createHTMLTable(e) {\r\n    const table = logic_table_1.LogicTable.constructHTMLLogicTable(e);\r\n    const tableTag = document.createElement(\"table\");\r\n    tableTag.setAttribute(\"border\", \"1\");\r\n    tableTag.setAttribute(\"cellspacing\", \"0\");\r\n    tableTag.setAttribute(\"bordercolor\", \"black\");\r\n    if (table != null) {\r\n        const cellConnectChecker = new Array();\r\n        for (let y = 0; y < table.rowCount; y++) {\r\n            cellConnectChecker.push(new Array(table.columnCount));\r\n            for (let x = 0; x < table.columnCount; x++) {\r\n                cellConnectChecker[y][x] = true;\r\n            }\r\n        }\r\n        for (let y = 0; y < table.rowCount; y++) {\r\n            const tr = document.createElement(\"tr\");\r\n            tableTag.appendChild(tr);\r\n            for (let x = 0; x < table.columnCount; x++) {\r\n                if (cellConnectChecker[y][x]) {\r\n                    const td = document.createElement(\"td\");\r\n                    const cell = table.cells[y][x];\r\n                    if (cell.connectedRowCount > 1) {\r\n                        td.setAttribute(\"rowspan\", cell.connectedRowCount.toString());\r\n                    }\r\n                    if (cell.connectedColumnCount > 1) {\r\n                        td.setAttribute(\"columnspan\", cell.connectedColumnCount.toString());\r\n                    }\r\n                    for (let ty = 0; ty < cell.connectedRowCount; ty++) {\r\n                        for (let tx = 0; tx < cell.connectedColumnCount; tx++) {\r\n                            if (tx != 0 || ty != 0) {\r\n                                cellConnectChecker[ty + y][tx + x] = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    const tTexts = cell.tTexts;\r\n                    //td.style.borderTopStyle = \"3px solid red\";\r\n                    if (tTexts != null) {\r\n                        tTexts.forEach((v) => {\r\n                            td.appendChild(v);\r\n                        });\r\n                    }\r\n                    else {\r\n                        const text = cell.text;\r\n                        if (typeof text == \"string\")\r\n                            td.innerHTML = text;\r\n                    }\r\n                    tr.appendChild(td);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tableTag;\r\n}\r\nexports.createHTMLTable = createHTMLTable;\r\n//}\r\n//# sourceMappingURL=html_table.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/html_table.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/index.js":
/*!************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"./node_modules/graph-table-svg/dist/options/open_svg.js\");\r\nexports.openSVG = open_svg_1.openSVG;\r\nexports.openHTML = open_svg_1.openHTML;\r\nexports.openCustomElement = open_svg_1.openCustomElement;\r\nexports.lazyOpenSVG = open_svg_1.lazyOpenSVG;\r\nexports.createShape = open_svg_1.createShape;\r\nexports.clearSVG = open_svg_1.clearSVG;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/index.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/open_svg.js":
/*!***************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/open_svg.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AttributeNames = __webpack_require__(/*! ../common/attribute_names */ \"./node_modules/graph-table-svg/dist/common/attribute_names.js\");\r\n//import * as StyleNames from \"../common/style_names\"\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"./node_modules/graph-table-svg/dist/common/enums.js\");\r\nconst HTMLFunctions = __webpack_require__(/*! ../html/html_functions */ \"./node_modules/graph-table-svg/dist/html/html_functions.js\");\r\nconst HTMLTable = __webpack_require__(/*! ./html_table */ \"./node_modules/graph-table-svg/dist/options/html_table.js\");\r\nconst GUIObserver = __webpack_require__(/*! ../html/gui_observer */ \"./node_modules/graph-table-svg/dist/html/gui_observer.js\");\r\nconst g_object_1 = __webpack_require__(/*! ../objects/g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst g_callout_1 = __webpack_require__(/*! ../objects/g_callout */ \"./node_modules/graph-table-svg/dist/objects/g_callout.js\");\r\nconst g_arrow_callout_1 = __webpack_require__(/*! ../objects/g_arrow_callout */ \"./node_modules/graph-table-svg/dist/objects/g_arrow_callout.js\");\r\nconst g_ellipse_1 = __webpack_require__(/*! ../objects/g_ellipse */ \"./node_modules/graph-table-svg/dist/objects/g_ellipse.js\");\r\nconst g_rect_1 = __webpack_require__(/*! ../objects/g_rect */ \"./node_modules/graph-table-svg/dist/objects/g_rect.js\");\r\n//import { GVertex } from \"../object/g_vertex\"\r\nconst g_textbox_1 = __webpack_require__(/*! ../objects/g_textbox */ \"./node_modules/graph-table-svg/dist/objects/g_textbox.js\");\r\nconst g_edge_1 = __webpack_require__(/*! ../objects/g_edge */ \"./node_modules/graph-table-svg/dist/objects/g_edge.js\");\r\nconst g_table_1 = __webpack_require__(/*! ../objects/g_table */ \"./node_modules/graph-table-svg/dist/objects/g_table.js\");\r\nconst g_graph_1 = __webpack_require__(/*! ../objects/g_graph */ \"./node_modules/graph-table-svg/dist/objects/g_graph.js\");\r\nconst g_rect_button_1 = __webpack_require__(/*! ../objects/g_rect_button */ \"./node_modules/graph-table-svg/dist/objects/g_rect_button.js\");\r\nconst g_circle_1 = __webpack_require__(/*! ../objects/g_circle */ \"./node_modules/graph-table-svg/dist/objects/g_circle.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\n//export namespace openSVGFunctions {\r\n//}\r\nfunction isGCustomElement(element) {\r\n    const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\r\n    if (gObjectTypeAttr != null) {\r\n        const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\r\n        return gObjectType != null;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction openCustomElement(id) {\r\n    if (typeof id == \"string\") {\r\n        const item = document.getElementById(id);\r\n        if (item instanceof SVGElement) {\r\n            return openCustomElement(item);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        const element = id;\r\n        //const shapeType = GraphTableSVG.ShapeObjectType.toShapeObjectType(element.nodeName);\r\n        const gObjectTypeAttr = element.getAttribute(AttributeNames.customElement);\r\n        if (gObjectTypeAttr != null) {\r\n            const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\r\n            if (gObjectType != null) {\r\n                return createCustomElement(element, gObjectType);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            const type = enums_1.ShapeObjectType.toShapeObjectType(element.nodeName);\r\n            if (type != null) {\r\n                return createCustomElement(element, type);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.openCustomElement = openCustomElement;\r\nfunction createCustomElement(e, type) {\r\n    const parent = e.parentElement;\r\n    if (parent instanceof SVGElement) {\r\n        let r;\r\n        e.removeAttribute(AttributeNames.customElement);\r\n        if (type == enums_1.ShapeObjectType.Callout) {\r\n            const option = g_callout_1.GCallout.constructAttributes(e, true);\r\n            r = new g_callout_1.GCallout(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.ArrowCallout) {\r\n            const option = g_arrow_callout_1.GArrowCallout.constructAttributes(e, true);\r\n            r = new g_arrow_callout_1.GArrowCallout(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Ellipse) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_ellipse_1.GEllipse(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Circle) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_circle_1.GCircle(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Rect) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_rect_1.GRect(parent, option);\r\n            //throw Error(\"error\");\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Edge) {\r\n            const option = g_edge_1.GEdge.constructAttributes(e, true);\r\n            r = new g_edge_1.GEdge(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Graph) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_graph_1.GGraph(parent, option);\r\n            //(<GGraph>r).relocate();\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Table) {\r\n            const option = g_table_1.GTable.constructAttributes(e, true);\r\n            r = new g_table_1.GTable(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.RectButton) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_rect_button_1.GRectButton(parent, option);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        //属性の移動と元オブジェクトの削除\r\n        const attrs = ElementExtension.gtGetAttributes(e);\r\n        HTMLFunctions.getChildren(e).forEach((v) => r.svgGroup.appendChild(v));\r\n        e.remove();\r\n        attrs.forEach((v) => {\r\n            var items = v.name.split(\":\");\r\n            if (items.length == 2 && items[0] == \"surface\") {\r\n                if (r.svgSurface != null) {\r\n                    r.svgSurface.setAttribute(items[1], v.value);\r\n                }\r\n            }\r\n            else {\r\n                r.svgGroup.setAttribute(v.name, v.value);\r\n            }\r\n        });\r\n        if (r instanceof g_graph_1.GGraph) {\r\n            r.relocate();\r\n        }\r\n        return r;\r\n    }\r\n    else {\r\n        throw Error(\"error!\");\r\n    }\r\n}\r\nlet timerInterval = 100;\r\nfunction lazyOpenSVG() {\r\n    const p = document.getElementsByTagName(\"svg\");\r\n    const svgElements = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        const svgNode = p.item(i);\r\n        if (svgNode instanceof SVGSVGElement)\r\n            svgElements.push(svgNode);\r\n    }\r\n    svgElements.forEach((svgsvg) => lazyElementDic.push(svgsvg));\r\n    if (lazyElementDic.length > 0)\r\n        setTimeout(observelazyElementTimer, timerInterval);\r\n}\r\nexports.lazyOpenSVG = lazyOpenSVG;\r\nlet lazyElementDic = [];\r\nfunction observelazyElementTimer() {\r\n    for (let i = 0; i < lazyElementDic.length; i++) {\r\n        const element = lazyElementDic[i];\r\n        if (HTMLFunctions.isInsideElement(element)) {\r\n            openSVG(element);\r\n            lazyElementDic.splice(i, 1);\r\n            i = -1;\r\n        }\r\n    }\r\n    if (lazyElementDic.length > 0)\r\n        setTimeout(observelazyElementTimer, timerInterval);\r\n}\r\nfunction clearSVG(id) {\r\n    const box = document.getElementById(id);\r\n    box.innerHTML = \"\";\r\n}\r\nexports.clearSVG = clearSVG;\r\nfunction openSVG(inputItem = null, output = []) {\r\n    if (typeof inputItem == \"string\") {\r\n        const item = document.getElementById(inputItem);\r\n        if (item != null && item instanceof SVGSVGElement) {\r\n            return openSVG(item, output);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    else if (inputItem === null) {\r\n        const p = document.getElementsByTagName(\"svg\");\r\n        const svgElements = [];\r\n        for (let i = 0; i < p.length; i++) {\r\n            const svgNode = p.item(i);\r\n            if (svgNode instanceof SVGSVGElement)\r\n                svgElements.push(svgNode);\r\n        }\r\n        svgElements.forEach((svgsvg) => openSVG(svgsvg, output));\r\n        return output;\r\n    }\r\n    else if (inputItem instanceof SVGSVGElement) {\r\n        const svgsvg = inputItem;\r\n        HTMLFunctions.getDescendants(svgsvg).forEach(v => {\r\n            const shapeType = enums_1.ShapeObjectType.toShapeObjectType(v.nodeName);\r\n            if (shapeType != null) {\r\n                toSVGUnknownElement(v);\r\n            }\r\n        });\r\n        const startTime = performance.now();\r\n        HTMLFunctions.getDescendantsByPostorder(svgsvg).forEach((v) => {\r\n            if (v instanceof SVGElement) {\r\n                if (isGCustomElement(v)) {\r\n                    const p = openCustomElement(v);\r\n                    if (p != null) {\r\n                        output.push(p);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        const endTime = performance.now();\r\n        const time = endTime - startTime;\r\n        //console.log(\"create \" + svgsvg.id + \" : \" + time + \"ms\");\r\n        GUIObserver.observeSVGSVG(svgsvg);\r\n    }\r\n    else {\r\n        throw Error(\"errror\");\r\n    }\r\n    return output;\r\n}\r\nexports.openSVG = openSVG;\r\nfunction createShape(parent, type, option = {}) {\r\n    let _parent;\r\n    if (parent instanceof g_object_1.GObject) {\r\n        _parent = parent.svgGroup;\r\n    }\r\n    else if (parent instanceof SVGElement) {\r\n        _parent = parent;\r\n    }\r\n    else {\r\n        _parent = document.getElementById(parent);\r\n    }\r\n    switch (type) {\r\n        case enums_1.ShapeObjectType.Callout: return new g_callout_1.GCallout(_parent, option);\r\n        case enums_1.ShapeObjectType.ArrowCallout: return new g_arrow_callout_1.GArrowCallout(_parent, option);\r\n        case enums_1.ShapeObjectType.Ellipse: return new g_ellipse_1.GEllipse(_parent, option);\r\n        case enums_1.ShapeObjectType.Rect: return new g_rect_1.GRect(_parent, option);\r\n        case enums_1.ShapeObjectType.Edge: return new g_edge_1.GEdge(_parent, option);\r\n        case enums_1.ShapeObjectType.Graph: return new g_graph_1.GGraph(_parent, option);\r\n        case enums_1.ShapeObjectType.Table: return new g_table_1.GTable(_parent, option);\r\n        case enums_1.ShapeObjectType.RectButton: return new g_rect_button_1.GRectButton(_parent, option);\r\n        case enums_1.ShapeObjectType.Circle: return new g_circle_1.GCircle(_parent, option);\r\n    }\r\n    throw Error(\"error\");\r\n}\r\nexports.createShape = createShape;\r\nfunction toSVGUnknownElement(e) {\r\n    const type = enums_1.ShapeObjectType.toShapeObjectTypeOrCustomTag(e.nodeName);\r\n    if (type == null) {\r\n    }\r\n    else {\r\n        const ns = document.createElementNS('http://www.w3.org/2000/svg', \"g\");\r\n        ns.setAttribute(AttributeNames.customElement, e.nodeName);\r\n        for (let i = 0; i < e.attributes.length; i++) {\r\n            const attr = e.attributes.item(i);\r\n            ns.setAttribute(attr.name, attr.value);\r\n        }\r\n        ns.innerHTML = e.innerHTML;\r\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\r\n        const p = e.parentElement;\r\n        if (p != null) {\r\n            p.insertBefore(ns, e);\r\n            e.remove();\r\n        }\r\n        const children = HTMLFunctions.getChildren(ns);\r\n        children.forEach((v) => toSVGUnknownElement(v));\r\n    }\r\n}\r\nfunction toDivElement(e) {\r\n    //const type = e.nodeName == \"G-TABLE\" ? \"g-table\" : e.nodeName == \"ROW\" ? \"row\" : e.nodeName == \"CELL\" ? \"cell\" : e.nodeName == \"T\" ? \"t\" : null;\r\n    const type = e.nodeName == \"G-TABLE\" ? \"g-table\" : e.nodeName == \"ROW\" ? \"row\" : e.nodeName == \"CELL\" ? \"cell\" : null;\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        const ns = document.createElement(\"div\");\r\n        ns.setAttribute(AttributeNames.customElement, type);\r\n        for (let i = 0; i < e.attributes.length; i++) {\r\n            const attr = e.attributes.item(i);\r\n            ns.setAttribute(attr.name, attr.value);\r\n        }\r\n        ns.innerHTML = e.innerHTML;\r\n        //HTMLFunctions.getChildren(e).forEach((v)=>ns.appendChild(v));\r\n        const p = e.parentElement;\r\n        if (p != null) {\r\n            p.insertBefore(ns, e);\r\n            e.remove();\r\n        }\r\n        const children = HTMLFunctions.getChildren(ns);\r\n        children.forEach((v) => toDivElement(v));\r\n        return ns;\r\n    }\r\n}\r\nfunction isSVGElement(e) {\r\n    if (e.parentElement == null) {\r\n        return false;\r\n    }\r\n    else {\r\n        if (e.parentElement instanceof SVGSVGElement) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isSVGElement(e.parentElement);\r\n        }\r\n    }\r\n}\r\nfunction openHTML(id = null) {\r\n    if (id == null) {\r\n        const p = document.getElementsByTagName(\"g-table\");\r\n        const svgElements = [];\r\n        for (let i = 0; i < p.length; i++) {\r\n            const svgNode = p.item(i);\r\n            if (svgNode != null) {\r\n                if (!isSVGElement(svgNode) && svgNode instanceof HTMLElement)\r\n                    svgElements.push(svgNode);\r\n            }\r\n        }\r\n        svgElements.forEach((e) => openHTML(e));\r\n    }\r\n    else if (typeof (id) == \"string\") {\r\n        const e = document.getElementById(id);\r\n        if (e instanceof HTMLElement) {\r\n            openHTML(e);\r\n        }\r\n    }\r\n    else {\r\n        const newE = toDivElement(id);\r\n        if (newE != null) {\r\n            const table = HTMLTable.createHTMLTable(newE);\r\n            newE.insertAdjacentElement('beforebegin', table);\r\n            newE.remove();\r\n        }\r\n    }\r\n}\r\nexports.openHTML = openHTML;\r\n//# sourceMappingURL=open_svg.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/open_svg.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/svg_to_vba.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/svg_to_vba.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\nconst g_object_1 = __webpack_require__(/*! ../objects/g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\nconst g_table_1 = __webpack_require__(/*! ../objects/g_table */ \"./node_modules/graph-table-svg/dist/objects/g_table.js\");\r\nconst g_graph_1 = __webpack_require__(/*! ../objects/g_graph */ \"./node_modules/graph-table-svg/dist/objects/g_graph.js\");\r\nconst vba_functions_1 = __webpack_require__(/*! ../common/vba_functions */ \"./node_modules/graph-table-svg/dist/common/vba_functions.js\");\r\nconst ElementExtension = __webpack_require__(/*! ../interfaces/element_extension */ \"./node_modules/graph-table-svg/dist/interfaces/element_extension.js\");\r\nconst Extensions = __webpack_require__(/*! ../interfaces/extensions */ \"./node_modules/graph-table-svg/dist/interfaces/extensions.js\");\r\nconst SVGTextExtension = __webpack_require__(/*! ../interfaces/svg_text_extension */ \"./node_modules/graph-table-svg/dist/interfaces/svg_text_extension.js\");\r\nclass SVGToVBA {\r\n    /**\r\n     * 入力要素をPowerpoint上で作成するVBAコードを作成します。\r\n     * @param items\r\n     */\r\n    static create(items) {\r\n        //const id = 0;\r\n        if (items instanceof Array) {\r\n            const count = SVGToVBA.count(items);\r\n            const s = new Array(0);\r\n            s.push(`Sub create()`);\r\n            s.push(` Dim createdSlide As slide`);\r\n            s.push(` Set createdSlide = ActivePresentation.Slides.Add(1, ppLayoutBlank)`);\r\n            for (let i = 0; i < count; i++) {\r\n                s.push(`Call create${i}(createdSlide)`);\r\n            }\r\n            s.push(`MsgBox \"created\"`);\r\n            s.push(`End Sub`);\r\n            let id = 0;\r\n            for (let i = 0; i < items.length; i++) {\r\n                const item = items[i];\r\n                if (item instanceof g_table_1.GTable) {\r\n                    //const lines = item.createVBACode2(id++, \"createdSlide\");\r\n                    const lines = item.createVBACode2(id, \"createdSlide\");\r\n                    lines.forEach((v) => s.push(v));\r\n                    id++;\r\n                }\r\n                else if (item instanceof SVGPathElement) {\r\n                    //const lines = SVGToVBA.createVBACodeOfSVGPath(item, id++);\r\n                    const lines = SVGToVBA.createVBACodeOfSVGPath(item, id);\r\n                    lines.forEach((v) => s.push(v));\r\n                    id++;\r\n                }\r\n                else if (item instanceof SVGTextElement) {\r\n                    //const lines = SVGToVBA.createVBACodeOfTextElement(item, id++);\r\n                    const lines = SVGToVBA.createVBACodeOfTextElement(item, id);\r\n                    lines.forEach((v) => s.push(v));\r\n                    id++;\r\n                }\r\n                else if (item instanceof g_graph_1.GGraph) {\r\n                    const lines = item.createVBACode(id);\r\n                    lines.forEach((v) => s.push(v));\r\n                    id += item.VBAObjectNum;\r\n                }\r\n                else if (item instanceof g_object_1.GObject) {\r\n                    const lines = item.createVBACode(id);\r\n                    lines.forEach((v) => s.push(v));\r\n                    id += item.VBAObjectNum;\r\n                }\r\n            }\r\n            s.push(SVGToVBA.cellFunctionCode);\r\n            const r = vba_functions_1.VBATranslateFunctions.joinLines(s);\r\n            return r;\r\n        }\r\n        else {\r\n            return SVGToVBA.create([items]);\r\n        }\r\n    }\r\n    static count(items) {\r\n        //const id = 0;\r\n        if (items instanceof Array) {\r\n            let c = 0;\r\n            for (let i = 0; i < items.length; i++) {\r\n                const item = items[i];\r\n                if (item instanceof g_table_1.GTable) {\r\n                    c++;\r\n                }\r\n                else if (item instanceof SVGPathElement) {\r\n                    c++;\r\n                }\r\n                else if (item instanceof SVGTextElement) {\r\n                    c++;\r\n                }\r\n                else if (item instanceof g_graph_1.GGraph) {\r\n                    c += item.VBAObjectNum;\r\n                }\r\n                else if (item instanceof g_object_1.GObject) {\r\n                    c += item.VBAObjectNum;\r\n                }\r\n            }\r\n            return c;\r\n        }\r\n        else {\r\n            return SVGToVBA.count([items]);\r\n        }\r\n    }\r\n    static createVBACodeOfSVGPath(path, id) {\r\n        const lines = new Array(0);\r\n        const pos = Extensions.getPathLocations(path);\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        lines.push(` Dim edges${id}(${pos.length - 1}) As Shape`);\r\n        for (let i = 0; i < pos.length - 1; i++) {\r\n            lines.push(` Set edges${id}(${i}) = shapes_.AddConnector(msoConnectorStraight, ${pos[i][0]}, ${pos[i][1]}, ${pos[i + 1][0]}, ${pos[i + 1][1]})`);\r\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(ElementExtension.getPropertyStyleValueWithDefault(path, \"stroke\", \"gray\"));\r\n            const strokeWidth = parseInt(ElementExtension.getPropertyStyleValueWithDefault(path, \"stroke-width\", \"4\"));\r\n            const visible = ElementExtension.getPropertyStyleValueWithDefault(path, \"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n            lines.push(` Call EditLine(edges${id}(${i}).Line, ${lineColor}, msoLineSolid, ${0}, ${strokeWidth}, ${visible})`);\r\n        }\r\n        lines.push(`End Sub`);\r\n        return lines;\r\n    }\r\n    static createVBACodeOfTextElement(element, id) {\r\n        const lines = new Array(0);\r\n        const sub = [];\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        lines.push(` Dim txt As Shape`);\r\n        lines.push(` Set txt = shapes_.AddTextbox(msoTextOrientationHorizontal, ${SVGTextExtension.getX(element)}, ${SVGTextExtension.getY(element)}, 0, 0)`);\r\n        const fontSize = parseInt(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-size\", \"24\"));\r\n        const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-family\", \"MS PGothic\"));\r\n        const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(ElementExtension.getPropertyStyleValueWithDefault(element, \"font-weight\", \"none\"));\r\n        lines.push([` Call EditTextFrame(txt.TextFrame, ${0}, ${0}, ${0}, ${0}, false, ppAutoSizeShapeToFitText)`]);\r\n        vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(sub, element, `txt.TextFrame.TextRange`);\r\n        sub.forEach((v) => lines.push(v[0]));\r\n        lines.push([` Call EditTextEffect(txt.TextEffect, ${fontSize}, \"${fontFamily}\")`]);\r\n        lines.push(`End Sub`);\r\n        return lines;\r\n    }\r\n}\r\nSVGToVBA.cellFunctionCode = `\r\nSub EditTable(table_ As table, cellInfo_() As Variant)\r\n    Dim x As Integer\r\n    Dim y As Integer\r\n    \r\n    For x = 1 To UBound(cellInfo_, 1)\r\n        For y = 1 To UBound(cellInfo_, 2)\r\n         Call EditCell(table_.cell(x, y), CStr(cellInfo_(x, y)(0)))\r\n        Next\r\n    Next\r\nEnd Sub\r\n\r\nSub EditCell(cell_ As cell, text_ As String, backColor As Variant)\r\n    cell_.Shape.TextFrame.TextRange.text = text_\r\n    cell_.Shape.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellFont(frame_ As TextFrame, fontSize As Double, fontName As String, color As Variant, fontBold As Integer)\r\n    frame_.TextRange.Font.Size = fontSize\r\n    frame_.TextRange.Font.name = fontName\r\n    frame_.TextRange.Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    frame_.TextRange.Font.Bold = fontBold\r\nEnd Sub\r\n\r\n\r\n\r\n\r\nSub EditRow(row_ As Row, height As Integer)\r\n    row_.height = height\r\nEnd Sub\r\nSub EditColumn(column_ As Column, width As Integer)\r\n    column_.width = width\r\nEnd Sub\r\n\r\nSub EditCellTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextRange(range_ As TextRange, text As String)\r\n    range_.text = text\r\nEnd Sub\r\nSub EditTextRangeSub(range_ As TextRange, subBeg As Integer, subLen As Integer, script As String, color As Variant, fontName As String, fontSize As Double, fontBold As Integer)\r\n    range_.Characters(subBeg, subLen).Font.color.RGB = RGB(CInt(color(0)), CInt(color(1)), CInt(color(2)))\r\n    range_.Characters(subBeg, subLen).Font.Size = fontSize\r\n    range_.Characters(subBeg, subLen).Font.name = fontName\r\n    range_.Characters(subBeg, subLen).Font.Bold = fontBold\r\n    If script = \"subscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Subscript = True\r\n    End If\r\n    If script = \"superscript\" Then\r\n    range_.Characters(subBeg, subLen).Font.Superscript = True\r\n    End If\r\nEnd Sub\r\n\r\n\r\n\r\nSub EditShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\nSub EditCellBorder(line_ As LineFormat, foreColor As Variant, weight As Integer, transparent As Double)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.weight = weight\r\n    line_.Transparency = transparent\r\nEnd Sub\r\n\r\nSub EditConnector(connector_ As ConnectorFormat, begShape As Shape, endShape As Shape, begPos As Integer, endPos As Integer)\r\n    Call connector_.BeginConnect(begShape, begPos)\r\n    Call connector_.EndConnect(endShape, endPos)\r\nEnd Sub\r\n\r\nSub EditTextFrame(frame_ As TextFrame, marginTop As Double, marginBottom As Double, marginLeft As Double, marginRight As Double, wordWrap As Boolean, autoSize As Integer)\r\n    frame_.autoSize = autoSize\r\n    frame_.wordWrap = wordWrap\r\n    frame_.marginLeft = marginLeft\r\n    frame_.marginRight = marginRight\r\n    frame_.marginTop = marginTop\r\n    frame_.marginBottom = marginBottom\r\nEnd Sub\r\nSub EditAnchor(frame_ As TextFrame, vAnchor As Integer, hAnchor As Integer)\r\n    frame_.VerticalAnchor = vAnchor\r\n    frame_.TextRange.ParagraphFormat.Alignment = hAnchor\r\nEnd Sub\r\n\r\nSub EditTextEffect(effect_ As TextEffectFormat, fontSize As Double, fontName As String)\r\n effect_.fontSize = fontSize\r\n effect_.fontName = fontName\r\nEnd Sub\r\n\r\nSub EditVertexShape(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\nSub EditLine(line_ As LineFormat, foreColor As Variant, dashStyle As Integer, transparent As Double, weight As Integer, visible As Integer)\r\n    line_.foreColor.RGB = RGB(CInt(foreColor(0)), CInt(foreColor(1)), CInt(foreColor(2)))\r\n    line_.dashStyle = dashStyle\r\n    line_.Transparency = transparent\r\n    line_.weight = weight\r\n    line_.visible = visible\r\nEnd Sub\r\n\r\nSub EditCallOut(shape_ As Shape, name As String, visible As Integer, backColor As Variant)\r\n    shape_.name = name\r\n    shape_.Fill.visible = visible\r\n    shape_.Fill.ForeColor.RGB = RGB(CInt(backColor(0)), CInt(backColor(1)), CInt(backColor(2)))\r\nEnd Sub\r\n\r\n`;\r\nexports.SVGToVBA = SVGToVBA;\r\n//}\r\n//# sourceMappingURL=svg_to_vba.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/svg_to_vba.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/table_dictionary.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/table_dictionary.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// tslint:disable-next-line: no-namespace\r\nconst logic_tree_1 = __webpack_require__(/*! ../logics/logic_tree */ \"./node_modules/graph-table-svg/dist/logics/logic_tree.js\");\r\nconst logic_table_1 = __webpack_require__(/*! ../logics/logic_table */ \"./node_modules/graph-table-svg/dist/logics/logic_table.js\");\r\nconst DefaultClassNames = __webpack_require__(/*! ../common/default_class_names */ \"./node_modules/graph-table-svg/dist/common/default_class_names.js\");\r\nconst logic_text_1 = __webpack_require__(/*! ../logics/logic_text */ \"./node_modules/graph-table-svg/dist/logics/logic_text.js\");\r\nclass TableDictionary {\r\n    // columnValues: Map<string, (string|undefined)[]>= new Map();\r\n    // itemCount : number = 0;\r\n    constructor() {\r\n        this.columnMapper = new Map();\r\n        this.rows = new Array();\r\n        this.objects = new Array();\r\n        this.columnMapper.set(TableDictionary.IndexName, 0);\r\n        // this.columnValues.set(\"index\", []);\r\n    }\r\n    construct(item) {\r\n        if (item instanceof Array) {\r\n            item.forEach((v) => {\r\n                this.add(v);\r\n            });\r\n        }\r\n        else {\r\n            this.add(item);\r\n        }\r\n    }\r\n    addValue(i, key, value) {\r\n        const column = this.columnMapper.get(key);\r\n        if (column === undefined) {\r\n            this.columnMapper.set(key, this.columnMapper.size);\r\n        }\r\n        this.rows[i].set(key, value);\r\n    }\r\n    add(item) {\r\n        this.rows.push(new Map());\r\n        this.objects.push(item);\r\n        const x = this.rows.length - 1;\r\n        this.addValue(x, TableDictionary.IndexName, x.toString());\r\n        if (item instanceof Array) {\r\n            for (let i = 0; i < item.length; i++) {\r\n                const cell = item[i];\r\n                if (cell != undefined) {\r\n                    this.addValue(x, i.toString(), cell);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\r\n                this.addValue(x, TableDictionary.ValueName, item.toString());\r\n            }\r\n            else if (typeof item === \"object\") {\r\n                Object.keys(item).forEach((key) => {\r\n                    const value = item[key];\r\n                    this.addValue(x, key.toString(), value);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    toLogicTable() {\r\n        const table = new logic_table_1.LogicTable({ columnCount: this.columnMapper.size, rowCount: this.rows.length + 1 });\r\n        this.columnMapper.forEach((value, key) => {\r\n            const logicText = new logic_text_1.LogicText();\r\n            logicText.class = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\r\n            //table.cells[0][value].textClass = DefaultClassNames.defaultConsoleColumnTitleCellTextClass;\r\n            table.cells[0][value].backgroundClass = DefaultClassNames.defaultConsoleColumnTitleCellBackgroundClass;\r\n            if (key == TableDictionary.IndexName) {\r\n                logicText.textContent = \"(index)\";\r\n            }\r\n            else if (key == TableDictionary.ValueName) {\r\n                logicText.textContent = \"(value)\";\r\n            }\r\n            else {\r\n                logicText.textContent = key;\r\n            }\r\n            table.cells[0][value].text = logicText;\r\n        });\r\n        this.rows.forEach((map, index) => {\r\n            const tableIndex = index + 1;\r\n            for (let i = 0; i < this.columnMapper.size; i++) {\r\n                table.cells[tableIndex][i].text.textContent = \"undefined\";\r\n                table.cells[tableIndex][i].text.textContent = DefaultClassNames.defaultConsoleColumnTitleCellUndefinedTextClass;\r\n            }\r\n            map.forEach((value, key) => {\r\n                const columnIndex = this.columnMapper.get(key);\r\n                if (columnIndex != undefined) {\r\n                    const cell = this.rows[index].get(key);\r\n                    if (cell == null) {\r\n                        table.cells[tableIndex][columnIndex].text.textContent = \"null\";\r\n                    }\r\n                    else if (cell != undefined) {\r\n                        table.cells[tableIndex][columnIndex].text.textContent = cell.toString();\r\n                        table.cells[tableIndex][columnIndex].text.class = DefaultClassNames.defaultTextClass;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        return table;\r\n    }\r\n    createNode(item, graph, dic) {\r\n        if (typeof item === \"object\") {\r\n            let node = dic.get(item);\r\n            if (node !== undefined) {\r\n                return node;\r\n            }\r\n            else {\r\n                node = graph.addNode();\r\n                if (item !== undefined && item != null) {\r\n                    dic.set(item, node);\r\n                    Object.keys(item).forEach((key) => {\r\n                        const value = item[key];\r\n                        const child = this.createNode(value, graph, dic);\r\n                        const edge = graph.createEdge();\r\n                        edge.endNodeIndex = graph.getIndex(child);\r\n                        edge.text = key.toString();\r\n                        node.addEdge(edge);\r\n                    });\r\n                }\r\n                else {\r\n                    node.text = \"null\";\r\n                }\r\n                return node;\r\n            }\r\n        }\r\n        else {\r\n            const node = graph.addNode();\r\n            if (typeof item === \"undefined\") {\r\n                node.text = \"undefined\";\r\n            }\r\n            else {\r\n                node.text = item.toString();\r\n            }\r\n            return node;\r\n        }\r\n    }\r\n    toLogicGraph() {\r\n        const dic = new Map();\r\n        const graph = new logic_tree_1.LogicGraph();\r\n        this.rows.forEach((v, i) => {\r\n            const obj = this.objects[i];\r\n            this.createNode(obj, graph, dic);\r\n        });\r\n        return graph;\r\n    }\r\n}\r\nTableDictionary.IndexName = \"___GraphTableSVG_Console_Index\";\r\nTableDictionary.ValueName = \"___GraphTableSVG_Console_Value\";\r\nexports.TableDictionary = TableDictionary;\r\n//# sourceMappingURL=table_dictionary.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/table_dictionary.js?");

/***/ }),

/***/ "./node_modules/graph-table-svg/dist/options/vba_macro_modal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graph-table-svg/dist/options/vba_macro_modal.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//namespace GraphTableSVG {\r\n//import { Padding, Rectangle } from \"../common/vline\";\r\nconst svg_to_vba_1 = __webpack_require__(/*! ./svg_to_vba */ \"./node_modules/graph-table-svg/dist/options/svg_to_vba.js\");\r\nconst g_object_1 = __webpack_require__(/*! ../objects/g_object */ \"./node_modules/graph-table-svg/dist/objects/g_object.js\");\r\n//export namespace VBAMacroModal {\r\nfunction showMacroModal(id) {\r\n    if (id instanceof g_object_1.GObject) {\r\n        const p = svg_to_vba_1.SVGToVBA.create(id);\r\n        createMacroModal(p);\r\n    }\r\n    else {\r\n    }\r\n}\r\nexports.showMacroModal = showMacroModal;\r\n/**\r\n * マクロ用のモーダルを画面に生成します。\r\n * @param vbaCode モーダルに表示する貼り付けるVBAマクロ\r\n */\r\nfunction createMacroModal(vbaCode) {\r\n    if (vbaCode instanceof g_object_1.GObject) {\r\n        const p = svg_to_vba_1.SVGToVBA.create(vbaCode);\r\n        createMacroModal(p);\r\n    }\r\n    else {\r\n        const mainDiv = document.createElement(\"div\");\r\n        mainDiv.id = \"macro-modal\";\r\n        mainDiv.innerHTML = `\r\n使い方（Powerpoint 2013）<br>\r\n    新規ファイル<br>\r\n    →表示→マクロ→作成<br>\r\n    →生成したコードをユーザーフォームに貼り付ける<br>\r\n    →F5 or ユーザーフォームを実行<br>\r\n    →木が貼られたスライドが１ページ目に挿入される<br>\r\n    ※サイズの大きすぎる木はマクロ実行時にエラーが出ます。\r\n    <br>\r\n    <textarea id=\"codeBox\" rows=\"8\" cols=\"100\" style=\"overflow:auto;\"></textarea>\r\n`;\r\n        const button = document.createElement(\"button\");\r\n        button.setAttribute(\"class\", \"btn\");\r\n        button.textContent = \"クリップボードにコピー\";\r\n        button.onclick = () => {\r\n            copyAndCloseMacroModal();\r\n        };\r\n        mainDiv.appendChild(button);\r\n        mainDiv.style.position = \"fixed\";\r\n        mainDiv.style.zIndex = \"16\";\r\n        mainDiv.style.width = \"900px\";\r\n        mainDiv.style.height = \"400px\";\r\n        mainDiv.style.left = `${((window.outerWidth - parseInt(mainDiv.style.width)) / 2)}px`;\r\n        mainDiv.style.top = `${((window.outerHeight - parseInt(mainDiv.style.height)) / 2)}px`;\r\n        mainDiv.style.display = \"inline\";\r\n        mainDiv.style.backgroundColor = \"#ffffff\";\r\n        document.body.appendChild(mainDiv);\r\n        const cnt = document.getElementById(\"codeBox\");\r\n        cnt.value = vbaCode;\r\n        const bgDiv = document.createElement(\"div\");\r\n        document.body.appendChild(bgDiv);\r\n        bgDiv.style.width = \"100%\";\r\n        bgDiv.style.height = \"100%\";\r\n        bgDiv.style.backgroundColor = \"rgba(0,0,0,0.5)\";\r\n        bgDiv.style.position = \"fixed\";\r\n        bgDiv.style.top = \"0\";\r\n        bgDiv.style.left = \"0\";\r\n        bgDiv.id = \"modal-bg\";\r\n        bgDiv.style.zIndex = \"5\";\r\n        bgDiv.style.display = \"inline\";\r\n        bgDiv.onclick = removeMacroModal;\r\n        //$(\"body\").append('<div id=\"modal-bg\" style=\"z-index:5\"></div>');\r\n    }\r\n}\r\nexports.createMacroModal = createMacroModal;\r\n/**\r\n * マクロ用モーダルを取り除きます。\r\n */\r\nfunction removeMacroModal() {\r\n    const div1 = document.getElementById(\"macro-modal\");\r\n    const div2 = document.getElementById(\"modal-bg\");\r\n    if (div1 != null)\r\n        document.body.removeChild(div1);\r\n    if (div2 != null)\r\n        document.body.removeChild(div2);\r\n}\r\nexports.removeMacroModal = removeMacroModal;\r\n/**\r\n * マクロ用モーダルのテキストをクリップボードにコピーしてマクロ用モーダルを取り除きます。\r\n */\r\nfunction copyAndCloseMacroModal() {\r\n    const cnt = document.getElementById(\"codeBox\");\r\n    cnt.select();\r\n    window.document.execCommand('copy');\r\n    alert('クリップボードにコピーしました。');\r\n    removeMacroModal();\r\n}\r\nexports.copyAndCloseMacroModal = copyAndCloseMacroModal;\r\n//}\r\n//# sourceMappingURL=vba_macro_modal.js.map\n\n//# sourceURL=webpack://Sutoring/./node_modules/graph-table-svg/dist/options/vba_macro_modal.js?");

/***/ }),

/***/ "./src/arrays/index.ts":
/*!*****************************!*\
  !*** ./src/arrays/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SuffixArray = __webpack_require__(/*! ./suffix_array */ \"./src/arrays/suffix_array.ts\");\r\nexports.SuffixArray = SuffixArray;\r\nconst LCPArray = __webpack_require__(/*! ./lcp_array */ \"./src/arrays/lcp_array.ts\");\r\nexports.LCPArray = LCPArray;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/arrays/index.ts?");

/***/ }),

/***/ "./src/arrays/lcp_array.ts":
/*!*********************************!*\
  !*** ./src/arrays/lcp_array.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst SuffixArray = __webpack_require__(/*! ./suffix_array */ \"./src/arrays/suffix_array.ts\");\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nfunction lcp(text1, text2) {\r\n    const max = text1.length < text2.length ? text2.length : text1.length;\r\n    for (let i = 0; i < max; i++) {\r\n        if (text1[i] != text2[i])\r\n            return i;\r\n    }\r\n    return max;\r\n}\r\nexports.lcp = lcp;\r\nfunction construct(text) {\r\n    const sa = SuffixArray.construct(text);\r\n    const lcpArray = sa.map((_, i) => {\r\n        if (i == 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return lcp(text.substr(sa[i]), text.substr(sa[i - 1]));\r\n        }\r\n    });\r\n    return lcpArray;\r\n}\r\nexports.construct = construct;\r\nfunction createLCPArrayLine(text, cellClass) {\r\n    const arr = construct(text);\r\n    const name = \"LCP\";\r\n    return graph_table_svg_1.Logics.toLogicCellLine(name, arr, cellClass);\r\n}\r\nexports.createLCPArrayLine = createLCPArrayLine;\r\nfunction constructLCPTable(text, option = { zeroBased: true, withSA: true, withLCP: true, withBWT: false }) {\r\n    return SuffixArray.constructSATable(text, option);\r\n}\r\nexports.constructLCPTable = constructLCPTable;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/arrays/lcp_array.ts?");

/***/ }),

/***/ "./src/arrays/suffix_array.ts":
/*!************************************!*\
  !*** ./src/arrays/suffix_array.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nconst LCPArray = __webpack_require__(/*! ./lcp_array */ \"./src/arrays/lcp_array.ts\");\r\nconst BWT = __webpack_require__(/*! ../permutations/bwt */ \"./src/permutations/bwt.ts\");\r\nfunction construct(str, zero_based = true) {\r\n    const arr = new Array(str.length);\r\n    for (let i = 0; i < str.length; i++) {\r\n        arr[i] = i;\r\n    }\r\n    const func = function (item1, item2) {\r\n        for (let i = 0; i <= str.length; i++) {\r\n            if (item1 + i >= str.length || item2 + i >= str.length)\r\n                break;\r\n            if (str.charAt(item1 + i) < str.charAt(item2 + i)) {\r\n                return -1;\r\n            }\r\n            else if (str.charAt(item1 + i) > str.charAt(item2 + i)) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (item1 == item2) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return item1 < item2 ? 1 : -1;\r\n        }\r\n    };\r\n    arr.sort(func);\r\n    if (zero_based) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return arr.map((v) => v + 1);\r\n    }\r\n}\r\nexports.construct = construct;\r\nfunction createSuffixArrayTableLine(text, zero_based = true, cellClass) {\r\n    const arr = construct(text, zero_based);\r\n    const name = \"SA\";\r\n    return graph_table_svg_1.Logics.toLogicCellLine(name, arr, cellClass);\r\n}\r\nexports.createSuffixArrayTableLine = createSuffixArrayTableLine;\r\nfunction createSortedSuffixes(text) {\r\n    const sa = construct(text);\r\n    return sa.map((v) => text.substr(v));\r\n}\r\nexports.createSortedSuffixes = createSortedSuffixes;\r\nfunction createSortedSuffixesTableLine(text, cellClass = { horizontalAnchor: \"left\" }) {\r\n    const suffixes = createSortedSuffixes(text);\r\n    const name = \"Suffix\";\r\n    return graph_table_svg_1.Logics.toLogicCellLine(name, suffixes, cellClass);\r\n}\r\nexports.createSortedSuffixesTableLine = createSortedSuffixesTableLine;\r\nfunction constructSATable(text, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: false, withIndex: true }) {\r\n    if (option.zeroBased == undefined)\r\n        option.zeroBased = true;\r\n    if (option.withSA == undefined)\r\n        option.withSA = true;\r\n    if (option.withLCP == undefined)\r\n        option.withLCP = false;\r\n    if (option.withBWT == undefined)\r\n        option.withBWT = false;\r\n    if (option.withIndex == undefined)\r\n        option.withIndex = true;\r\n    const arrays = new Array(0);\r\n    if (option.withIndex) {\r\n        arrays.push(graph_table_svg_1.Logics.getIndexArrayTableLine(text.length, option.zeroBased));\r\n    }\r\n    if (option.withSA) {\r\n        arrays.push(createSuffixArrayTableLine(text, option.zeroBased));\r\n    }\r\n    if (option.withLCP) {\r\n        arrays.push(LCPArray.createLCPArrayLine(text));\r\n    }\r\n    if (option.withBWT) {\r\n        arrays.push(BWT.createBWTTableLine(text));\r\n    }\r\n    arrays.push(createSortedSuffixesTableLine(text));\r\n    return graph_table_svg_1.Logics.buildLogicTable(arrays, { isRowLines: false });\r\n}\r\nexports.constructSATable = constructSATable;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/arrays/suffix_array.ts?");

/***/ }),

/***/ "./src/debug/debug.ts":
/*!****************************!*\
  !*** ./src/debug/debug.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isEqual(array1, array2) {\r\n    if (array1.length != array2.length) {\r\n        return false;\r\n    }\r\n    else {\r\n        for (let i = 0; i < array1.length; i++) {\r\n            if (array1[i] != array2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.isEqual = isEqual;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/debug/debug.ts?");

/***/ }),

/***/ "./src/factorizations/index.ts":
/*!*************************************!*\
  !*** ./src/factorizations/index.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LZ77WithSelfReference = __webpack_require__(/*! ./lz77_with_self_reference */ \"./src/factorizations/lz77_with_self_reference.ts\");\r\nexports.LZ77WithSelfReference = LZ77WithSelfReference;\r\nconst LZ78 = __webpack_require__(/*! ./lz78 */ \"./src/factorizations/lz78.ts\");\r\nexports.LZ78 = LZ78;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/factorizations/index.ts?");

/***/ }),

/***/ "./src/factorizations/lz77_with_self_reference.ts":
/*!********************************************************!*\
  !*** ./src/factorizations/lz77_with_self_reference.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction lce(text, pos1, pos2) {\r\n    let t = 0;\r\n    while (true) {\r\n        let i = pos1 + t;\r\n        let j = pos2 + t;\r\n        if (i >= text.length || j >= text.length) {\r\n            return t;\r\n        }\r\n        else {\r\n            if (text[i] == text[j]) {\r\n                t++;\r\n            }\r\n            else {\r\n                return t;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction find(text, pos) {\r\n    let len = 0;\r\n    let referencePos = -1;\r\n    for (let i = 0; i < pos; i++) {\r\n        const len2 = lce(text, i, pos);\r\n        if (len2 > len) {\r\n            referencePos = i;\r\n            len = len2;\r\n        }\r\n    }\r\n    if (len == 0) {\r\n        return text[pos];\r\n    }\r\n    else {\r\n        return { position: referencePos, length: len };\r\n    }\r\n}\r\nfunction factorize(text) {\r\n    const factors = compress(text);\r\n    return factors.map((v) => {\r\n        if (typeof (v) == \"string\") {\r\n            return v;\r\n        }\r\n        else {\r\n            return text.substr(v.position, v.length);\r\n        }\r\n    });\r\n}\r\nexports.factorize = factorize;\r\nfunction compress(text) {\r\n    const r = new Array();\r\n    let i = 0;\r\n    while (i < text.length) {\r\n        console.log(i);\r\n        const f = find(text, i);\r\n        r.push(f);\r\n        if (typeof (f) == \"string\") {\r\n            i += 1;\r\n        }\r\n        else {\r\n            if (f.length == 0)\r\n                throw new Error(\"error\");\r\n            i += f.length;\r\n        }\r\n    }\r\n    return r;\r\n}\r\nexports.compress = compress;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/factorizations/lz77_with_self_reference.ts?");

/***/ }),

/***/ "./src/factorizations/lz78.ts":
/*!************************************!*\
  !*** ./src/factorizations/lz78.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nfunction preprocess(text) {\r\n    let nodeCount = 0;\r\n    const root = { id: nodeCount++, children: new Map() };\r\n    let currentNode = root;\r\n    let factors = new Array();\r\n    const nodes = [root];\r\n    for (let i = 0; i < text.length; i++) {\r\n        const char = text[i];\r\n        if (currentNode.children.has(char)) {\r\n            currentNode = currentNode.children.get(char);\r\n        }\r\n        else {\r\n            factors.push({ id: currentNode.id, nextChar: char });\r\n            const newNode = { id: nodeCount++, children: new Map() };\r\n            currentNode.children.set(char, newNode);\r\n            currentNode = root;\r\n            nodes.push(newNode);\r\n        }\r\n    }\r\n    if (currentNode != root) {\r\n        factors.push({ id: currentNode.id, nextChar: \"\" });\r\n        const newNode = { id: nodeCount++, children: new Map() };\r\n        currentNode.children.set(\"\", newNode);\r\n        currentNode = root;\r\n        nodes.push(newNode);\r\n    }\r\n    return [factors, nodes];\r\n}\r\nfunction extract(factors) {\r\n    const r = new Array();\r\n    factors.forEach((f, i) => {\r\n        if (f.id == 0) {\r\n            r.push(f.nextChar);\r\n        }\r\n        else {\r\n            const str = r[f.id - 1] + f.nextChar;\r\n            r.push(str);\r\n        }\r\n    });\r\n    return r;\r\n}\r\nfunction factorize(text) {\r\n    const p = preprocess(text);\r\n    const parsedStrings = extract(p[0]);\r\n    return parsedStrings;\r\n}\r\nexports.factorize = factorize;\r\nfunction compress(text) {\r\n    const p = preprocess(text);\r\n    return p[0];\r\n}\r\nexports.compress = compress;\r\nfunction constructLZ78Table(text) {\r\n    const comp = compress(text);\r\n    const indexLine = graph_table_svg_1.Logics.getIndexArrayTableLine(comp.length);\r\n    const idLine = graph_table_svg_1.Logics.toLogicCellLine(\"id\", comp.map((v, i) => v.id));\r\n    const characterLine = graph_table_svg_1.Logics.toLogicCellLine(\"character\", comp.map((v, i) => v.nextChar));\r\n    return graph_table_svg_1.Logics.buildLogicTable([indexLine, idLine, characterLine], { isRowLines: true });\r\n}\r\nexports.constructLZ78Table = constructLZ78Table;\r\nfunction constructLZ78Trie(text) {\r\n    const nodes = preprocess(text)[1];\r\n    const graphNodes = nodes.map((v) => new graph_table_svg_1.Logics.LogicTree());\r\n    nodes.forEach((v, i) => {\r\n        graphNodes[v.id].vertexOption.text = (v.id).toString();\r\n        graphNodes[v.id].vertexOption.textClass = { fontSize: \"18px\" };\r\n        v.children.forEach((value, key) => {\r\n            const child = graphNodes[value.id];\r\n            child.edgeOption.text = key;\r\n            graphNodes[v.id].children.push(child);\r\n        });\r\n    });\r\n    return graphNodes[0];\r\n}\r\nexports.constructLZ78Trie = constructLZ78Trie;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/factorizations/lz78.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nexports.Console = graph_table_svg_1.Console;\r\nconst Debug = __webpack_require__(/*! ./debug/debug */ \"./src/debug/debug.ts\");\r\nexports.Debug = Debug;\r\nconst Arrays = __webpack_require__(/*! ./arrays/index */ \"./src/arrays/index.ts\");\r\nexports.Arrays = Arrays;\r\nconst Sequences = __webpack_require__(/*! ./sequences/index */ \"./src/sequences/index.ts\");\r\nexports.Sequences = Sequences;\r\nconst Permutations = __webpack_require__(/*! ./permutations/index */ \"./src/permutations/index.ts\");\r\nexports.Permutations = Permutations;\r\nconst Factorizations = __webpack_require__(/*! ./factorizations/index */ \"./src/factorizations/index.ts\");\r\nexports.Factorizations = Factorizations;\r\nconst Trees = __webpack_require__(/*! ./trees/index */ \"./src/trees/index.ts\");\r\nexports.Trees = Trees;\r\nconst Substrings = __webpack_require__(/*! ./substrings/index */ \"./src/substrings/index.ts\");\r\nexports.Substrings = Substrings;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/index.ts?");

/***/ }),

/***/ "./src/permutations/bwt.ts":
/*!*********************************!*\
  !*** ./src/permutations/bwt.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nconst SuffixArray = __webpack_require__(/*! ../arrays/suffix_array */ \"./src/arrays/suffix_array.ts\");\r\nconst LCPArray = __webpack_require__(/*! ../arrays/lcp_array */ \"./src/arrays/lcp_array.ts\");\r\nfunction createCircularString(text, nth) {\r\n    return text.substr(nth) + text.substr(0, nth);\r\n}\r\nfunction createCircularStrings(text) {\r\n    const r = Array.from(Array(text.length).keys()).map((i) => createCircularString(text, i));\r\n    return r;\r\n}\r\nfunction createCircularSuffixArray(text, zeroBased = true) {\r\n    const r = Array.from(Array(text.length).keys());\r\n    r.sort((a, b) => {\r\n        return compare(text, a, b);\r\n    });\r\n    if (zeroBased) {\r\n        return r;\r\n    }\r\n    else {\r\n        return r.map((v) => v + 1);\r\n    }\r\n}\r\nexports.createCircularSuffixArray = createCircularSuffixArray;\r\nfunction createSortedCircularStrings(text) {\r\n    const csa = createCircularSuffixArray(text);\r\n    return csa.map((i) => createCircularString(text, i));\r\n}\r\nfunction compare(text, ith, jth) {\r\n    const ithStr = createCircularString(text, ith);\r\n    const jthStr = createCircularString(text, jth);\r\n    if (ithStr == jthStr) {\r\n        return ith - jth;\r\n    }\r\n    else {\r\n        if (ithStr < jthStr) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n}\r\nfunction createBWTIndexes(text, zeroBased = true) {\r\n    const csa = createCircularSuffixArray(text);\r\n    return csa.map((v) => {\r\n        if (v == 0) {\r\n            return text.length - 1 + (zeroBased ? 0 : 1);\r\n        }\r\n        else {\r\n            return v - 1 + (zeroBased ? 0 : 1);\r\n        }\r\n    });\r\n}\r\nexports.createBWTIndexes = createBWTIndexes;\r\nfunction construct(text) {\r\n    return createBWTIndexes(text).map((v) => text[v]).join(\"\");\r\n}\r\nexports.construct = construct;\r\nfunction createBWTTableLine(text, cellClass) {\r\n    const bwt = construct(text);\r\n    const arr = Array.from(Array(text.length).keys()).map((i) => bwt[i]);\r\n    console.log(arr);\r\n    console.log(bwt);\r\n    const name = \"BWT\";\r\n    return graph_table_svg_1.Logics.toLogicCellLine(name, arr, cellClass);\r\n}\r\nexports.createBWTTableLine = createBWTTableLine;\r\nfunction createFArray(text) {\r\n    return createSortedCircularStrings(text).map((v) => v[0]);\r\n}\r\nexports.createFArray = createFArray;\r\nfunction createLArray(text) {\r\n    return createSortedCircularStrings(text).map((v) => v[v.length - 1]);\r\n}\r\nexports.createLArray = createLArray;\r\nfunction createSortedMiddleCircularStrings(text) {\r\n    return createSortedCircularStrings(text).map((v) => v.substr(1, v.length - 2));\r\n}\r\nexports.createSortedMiddleCircularStrings = createSortedMiddleCircularStrings;\r\nfunction rank(text, ith) {\r\n    const c = text[ith];\r\n    let _rank = 0;\r\n    for (let i = 0; i < ith; i++) {\r\n        if (c == text[i])\r\n            _rank++;\r\n    }\r\n    return _rank;\r\n}\r\nconst bwtColors = [\"black\", \"red\", \"orange\", \"blue\", \"green\", \"purple\", \"gray\", \"slateblue\", \"saddlebrown\", \"olive\", \"aqua\"];\r\nfunction createFArrayLine(text, isColored = false, cellClass = { horizontalAnchor: \"center\" }) {\r\n    const titleCell = new graph_table_svg_1.Logics.LogicCell();\r\n    titleCell.text.textContent = \"F\";\r\n    titleCell.cellClass = cellClass;\r\n    const suffixes = createFArray(text);\r\n    const csa = createCircularSuffixArray(text);\r\n    const cells = csa.map((v, i) => {\r\n        const _rank = rank(text, v);\r\n        const cell = new graph_table_svg_1.Logics.LogicCell();\r\n        cell.cellClass = cellClass;\r\n        cell.text.textContent = suffixes[i];\r\n        if (isColored) {\r\n            const color = bwtColors[_rank % bwtColors.length];\r\n            cell.text.style = { fill: color };\r\n        }\r\n        return cell;\r\n    });\r\n    return [titleCell].concat(cells);\r\n}\r\nexports.createFArrayLine = createFArrayLine;\r\nfunction createLArrayLine(text, isColored = false, cellClass = { horizontalAnchor: \"center\" }) {\r\n    const titleCell = new graph_table_svg_1.Logics.LogicCell();\r\n    titleCell.text.textContent = \"L\";\r\n    titleCell.cellClass = cellClass;\r\n    const suffixes = createLArray(text);\r\n    const csa = createBWTIndexes(text);\r\n    const cells = csa.map((v, i) => {\r\n        const _rank = rank(text, v);\r\n        const cell = new graph_table_svg_1.Logics.LogicCell();\r\n        cell.cellClass = cellClass;\r\n        cell.text.textContent = suffixes[i];\r\n        if (isColored) {\r\n            const color = bwtColors[_rank % bwtColors.length];\r\n            cell.text.style = { fill: color };\r\n        }\r\n        return cell;\r\n    });\r\n    return [titleCell].concat(cells);\r\n}\r\nexports.createLArrayLine = createLArrayLine;\r\nfunction createSortedMiddleCircularStringsLine(text, isColored = false, cellClass = { horizontalAnchor: \"center\" }) {\r\n    const titleCell = new graph_table_svg_1.Logics.LogicCell();\r\n    titleCell.text.textContent = \"\";\r\n    titleCell.cellClass = cellClass;\r\n    const suffixes = createSortedMiddleCircularStrings(text);\r\n    const csa = createCircularSuffixArray(text);\r\n    const cells = csa.map((v, i) => {\r\n        const cell = new graph_table_svg_1.Logics.LogicCell();\r\n        if (isColored) {\r\n            const spans = new Array();\r\n            for (let i = 1; i < text.length - 1; i++) {\r\n                const p = (v + i) % text.length;\r\n                const _rank = rank(text, p);\r\n                const span = new graph_table_svg_1.Logics.LogicTSpan();\r\n                span.textContent = text[p];\r\n                const color = bwtColors[_rank % bwtColors.length];\r\n                span.style = { fill: color };\r\n                spans.push(span);\r\n            }\r\n            cell.text = new graph_table_svg_1.Logics.LogicText(spans);\r\n        }\r\n        else {\r\n            cell.text.textContent = suffixes[i];\r\n            cell.cellClass = cellClass;\r\n        }\r\n        return cell;\r\n    });\r\n    return [titleCell].concat(cells);\r\n}\r\nexports.createSortedMiddleCircularStringsLine = createSortedMiddleCircularStringsLine;\r\nfunction constructBWTTable(text, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: true }) {\r\n    return SuffixArray.constructSATable(text, option);\r\n}\r\nexports.constructBWTTable = constructBWTTable;\r\nfunction constructBWTTable2(text, isColored, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: true }) {\r\n    if (option.zeroBased == undefined)\r\n        option.zeroBased = true;\r\n    if (option.withSA == undefined)\r\n        option.withSA = true;\r\n    if (option.withLCP == undefined)\r\n        option.withLCP = false;\r\n    if (option.withIndex == undefined)\r\n        option.withIndex = true;\r\n    const arrays = new Array(0);\r\n    if (option.withIndex) {\r\n        arrays.push(graph_table_svg_1.Logics.getIndexArrayTableLine(text.length, option.zeroBased));\r\n    }\r\n    if (option.withSA) {\r\n        arrays.push(SuffixArray.createSuffixArrayTableLine(text, option.zeroBased));\r\n    }\r\n    if (option.withLCP) {\r\n        arrays.push(LCPArray.createLCPArrayLine(text));\r\n    }\r\n    arrays.push(createFArrayLine(text, isColored));\r\n    arrays.push(createSortedMiddleCircularStringsLine(text, isColored));\r\n    arrays.push(createLArrayLine(text, isColored));\r\n    return graph_table_svg_1.Logics.buildLogicTable(arrays, { isRowLines: false });\r\n}\r\nexports.constructBWTTable2 = constructBWTTable2;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/permutations/bwt.ts?");

/***/ }),

/***/ "./src/permutations/index.ts":
/*!***********************************!*\
  !*** ./src/permutations/index.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BWT = __webpack_require__(/*! ./bwt */ \"./src/permutations/bwt.ts\");\r\nexports.BWT = BWT;\r\nconst RLBWT = __webpack_require__(/*! ./rlbwt */ \"./src/permutations/rlbwt.ts\");\r\nexports.RLBWT = RLBWT;\r\nconst SAonRLBWT = __webpack_require__(/*! ./sa_on_rlbwt */ \"./src/permutations/sa_on_rlbwt.ts\");\r\nexports.SAonRLBWT = SAonRLBWT;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/permutations/index.ts?");

/***/ }),

/***/ "./src/permutations/rlbwt.ts":
/*!***********************************!*\
  !*** ./src/permutations/rlbwt.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BWT = __webpack_require__(/*! ./bwt */ \"./src/permutations/bwt.ts\");\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nconst SuffixArray = __webpack_require__(/*! ../arrays/suffix_array */ \"./src/arrays/suffix_array.ts\");\r\nconst LCPArray = __webpack_require__(/*! ../arrays/lcp_array */ \"./src/arrays/lcp_array.ts\");\r\nfunction runLengthEncode(text) {\r\n    if (text.length == 0) {\r\n        return new Array();\r\n    }\r\n    else {\r\n        const r = new Array();\r\n        let m = 1;\r\n        let c = text[0];\r\n        for (let i = 1; i < text.length; i++) {\r\n            if (text[i] != c) {\r\n                r.push({ char: c, length: m });\r\n                m = 1;\r\n                c = text[i];\r\n            }\r\n            else {\r\n                m++;\r\n            }\r\n        }\r\n        if (m >= 1) {\r\n            r.push({ char: c, length: m });\r\n        }\r\n        return r;\r\n    }\r\n}\r\nexports.runLengthEncode = runLengthEncode;\r\nfunction construct(text) {\r\n    const bwt = BWT.construct(text);\r\n    return runLengthEncode(bwt);\r\n}\r\nexports.construct = construct;\r\nfunction createLRunStartingPositions(text) {\r\n    const bwt = BWT.createLArray(text);\r\n    const r = new Array();\r\n    r.push(0);\r\n    for (let i = 1; i < text.length; i++) {\r\n        if (bwt[i] != bwt[i - 1]) {\r\n            r.push(i);\r\n        }\r\n    }\r\n    return r;\r\n}\r\nexports.createLRunStartingPositions = createLRunStartingPositions;\r\nfunction createLRunEndingPositions(text) {\r\n    const lruns = createLRunStartingPositions(text);\r\n    const r = new Array();\r\n    for (let i = 1; i < lruns.length; i++) {\r\n        r.push(lruns[i] - 1);\r\n    }\r\n    r.push(text.length - 1);\r\n    return r;\r\n}\r\nexports.createLRunEndingPositions = createLRunEndingPositions;\r\nfunction createFRunStartPositions(text) {\r\n    const bwt = BWT.createLArray(text);\r\n    const lruns = createLRunStartingPositions(text);\r\n    const infos = lruns.map((v, i) => {\r\n        if (i + 1 == lruns.length) {\r\n            return [v, bwt.length - lruns[i]];\r\n        }\r\n        else {\r\n            const width = lruns[i + 1] - lruns[i];\r\n            return [v, width];\r\n        }\r\n    });\r\n    infos.sort((a, b) => {\r\n        if (bwt[a[0]] != bwt[b[0]]) {\r\n            return bwt[a[0]] < bwt[b[0]] ? -1 : 1;\r\n        }\r\n        else {\r\n            return a[0] < b[0] ? -1 : 1;\r\n        }\r\n    });\r\n    const r = new Array(0);\r\n    r.push(0);\r\n    for (let i = 0; i < infos.length; i++) {\r\n        const prev = r[r.length - 1];\r\n        r.push(infos[i][1] + prev);\r\n    }\r\n    return r;\r\n}\r\nexports.createFRunStartPositions = createFRunStartPositions;\r\nfunction createLArrayLine(text, isColored = false, cellClass = { horizontalAnchor: \"center\" }) {\r\n    const line = BWT.createLArrayLine(text, isColored, cellClass);\r\n    const lruns = createLRunStartingPositions(text);\r\n    lruns.push(text.length);\r\n    for (let i = 0; i < lruns.length; i++) {\r\n        const begin = lruns[i];\r\n        const end = lruns[i + 1] - 1;\r\n        for (let j = begin; j < end; j++) {\r\n            line[j + 1].bottomBorderClass = null;\r\n        }\r\n    }\r\n    return line;\r\n}\r\nexports.createLArrayLine = createLArrayLine;\r\nfunction createFArrayLine(text, isColored = false, cellClass = { horizontalAnchor: \"center\" }) {\r\n    const line = BWT.createFArrayLine(text, isColored, cellClass);\r\n    const fruns = createFRunStartPositions(text);\r\n    fruns.push(text.length);\r\n    for (let i = 0; i < fruns.length; i++) {\r\n        const begin = fruns[i];\r\n        const end = fruns[i + 1] - 1;\r\n        for (let j = begin; j < end; j++) {\r\n            line[j + 1].bottomBorderClass = null;\r\n        }\r\n    }\r\n    return line;\r\n}\r\nexports.createFArrayLine = createFArrayLine;\r\nfunction constructRLBWTTable(text, isColored, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: true }) {\r\n    if (option.zeroBased == undefined)\r\n        option.zeroBased = true;\r\n    if (option.withSA == undefined)\r\n        option.withSA = true;\r\n    if (option.withLCP == undefined)\r\n        option.withLCP = false;\r\n    if (option.withIndex == undefined)\r\n        option.withIndex = true;\r\n    const arrays = new Array(0);\r\n    if (option.withIndex) {\r\n        arrays.push(graph_table_svg_1.Logics.getIndexArrayTableLine(text.length, option.zeroBased));\r\n    }\r\n    if (option.withSA) {\r\n        arrays.push(SuffixArray.createSuffixArrayTableLine(text, option.zeroBased));\r\n    }\r\n    if (option.withLCP) {\r\n        arrays.push(LCPArray.createLCPArrayLine(text));\r\n    }\r\n    arrays.push(createFArrayLine(text, isColored));\r\n    arrays.push(BWT.createSortedMiddleCircularStringsLine(text, isColored));\r\n    arrays.push(createLArrayLine(text, isColored));\r\n    return graph_table_svg_1.Logics.buildLogicTable(arrays, { isRowLines: false });\r\n}\r\nexports.constructRLBWTTable = constructRLBWTTable;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/permutations/rlbwt.ts?");

/***/ }),

/***/ "./src/permutations/sa_on_rlbwt.ts":
/*!*****************************************!*\
  !*** ./src/permutations/sa_on_rlbwt.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BWT = __webpack_require__(/*! ./bwt */ \"./src/permutations/bwt.ts\");\r\nconst LCP = __webpack_require__(/*! ../arrays/lcp_array */ \"./src/arrays/lcp_array.ts\");\r\nconst RLBWT = __webpack_require__(/*! ./rlbwt */ \"./src/permutations/rlbwt.ts\");\r\nfunction createSortedLRunStartingPositionsBySuffixArray(text) {\r\n    const lruns = RLBWT.createLRunStartingPositions(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    lruns.sort((a, b) => {\r\n        return sa[a] < sa[b] ? -1 : 1;\r\n    });\r\n    return lruns;\r\n}\r\nfunction createSortedLRunEndingPositionsBySuffixArray(text) {\r\n    const lruns = RLBWT.createLRunEndingPositions(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    lruns.sort((a, b) => {\r\n        return sa[a] < sa[b] ? -1 : 1;\r\n    });\r\n    return lruns;\r\n}\r\nfunction createSampledSuffixArrayForEndingPositions(text) {\r\n    const sortedLRuns = createSortedLRunEndingPositionsBySuffixArray(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    return sortedLRuns.map((v) => sa[v]);\r\n}\r\nfunction createSampledSuffixArrayForStartingPositions(text) {\r\n    const sortedLRuns = createSortedLRunStartingPositionsBySuffixArray(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    return sortedLRuns.map((v) => sa[v]);\r\n}\r\nfunction createSampledLCPArrayForEndingPositions(text) {\r\n    const sortedLRuns = createSortedLRunEndingPositionsBySuffixArray(text);\r\n    const lcpArray = LCP.construct(text);\r\n    return sortedLRuns.map((v) => {\r\n        if (v == text.length - 1) {\r\n            return lcpArray[0];\r\n        }\r\n        else {\r\n            return lcpArray[v + 1];\r\n        }\r\n    });\r\n}\r\nfunction createDifferentialSampledSuffixArrayForEndingPositions(text) {\r\n    const sortedLRuns = createSortedLRunEndingPositionsBySuffixArray(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    return sortedLRuns.map((v) => {\r\n        if (v == text.length - 1) {\r\n            return sa[v] - sa[0];\r\n        }\r\n        else {\r\n            return sa[v] - sa[v + 1];\r\n        }\r\n    });\r\n}\r\nfunction createDifferentialSampledSuffixArrayForStartingPositions(text) {\r\n    const sortedLRuns = createSortedLRunStartingPositionsBySuffixArray(text);\r\n    const sa = BWT.createCircularSuffixArray(text);\r\n    return sortedLRuns.map((v) => {\r\n        if (v == 0) {\r\n            return sa[text.length - 1] - sa[v];\r\n        }\r\n        else {\r\n            return sa[v - 1] - sa[v];\r\n        }\r\n    });\r\n}\r\nfunction pred(value, array) {\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i] > value) {\r\n            return i - 1;\r\n        }\r\n    }\r\n    return array.length - 1;\r\n}\r\nfunction computeNextSuffixArrayValue(ithSAValue, sampledSuffixArrayForEndingPositions, differentialSampledSuffixArrayForEndingPositions) {\r\n    const x = pred(ithSAValue, sampledSuffixArrayForEndingPositions);\r\n    if (x == -1) {\r\n        throw Error(\"Error\");\r\n    }\r\n    else {\r\n        return ithSAValue - differentialSampledSuffixArrayForEndingPositions[x];\r\n    }\r\n}\r\nfunction computeNextLCPValue(ithSAValue, sampledSuffixArrayForEndingPositions, sampledLCPArrayForEndingPositions) {\r\n    const x = pred(ithSAValue, sampledSuffixArrayForEndingPositions);\r\n    if (x == -1) {\r\n        throw Error(\"Error\");\r\n    }\r\n    else {\r\n        const d = ithSAValue - sampledSuffixArrayForEndingPositions[x];\r\n        return sampledLCPArrayForEndingPositions[x] - d;\r\n    }\r\n}\r\nfunction computePreviousSuffixArrayValue(ithSAValue, sampledSuffixArrayForStartingPositions, differentialSampledSuffixArrayForStartingPositions) {\r\n    const x = pred(ithSAValue, sampledSuffixArrayForStartingPositions);\r\n    if (x == -1) {\r\n        throw Error(\"Error\");\r\n    }\r\n    else {\r\n        return ithSAValue + differentialSampledSuffixArrayForStartingPositions[x];\r\n    }\r\n}\r\nfunction createSuffixArray(text) {\r\n    const sampledSuffixArrayForEndingPositions = createSampledSuffixArrayForEndingPositions(text);\r\n    const differentialSampledSuffixArrayForEndingPositions = createDifferentialSampledSuffixArrayForEndingPositions(text);\r\n    const firstSAValue = BWT.createCircularSuffixArray(text)[0];\r\n    let p = firstSAValue;\r\n    const r = new Array();\r\n    r.push(p);\r\n    for (let i = 1; i < text.length; i++) {\r\n        p = computeNextSuffixArrayValue(p, sampledSuffixArrayForEndingPositions, differentialSampledSuffixArrayForEndingPositions);\r\n        r.push(p);\r\n    }\r\n    return r;\r\n}\r\nexports.createSuffixArray = createSuffixArray;\r\nfunction createLCPArray(text) {\r\n    const sampledSuffixArrayForEndingPositions = createSampledSuffixArrayForEndingPositions(text);\r\n    const differentialSampledSuffixArrayForEndingPositions = createDifferentialSampledSuffixArrayForEndingPositions(text);\r\n    const sampledLCPArrayForEndingPositions = createSampledLCPArrayForEndingPositions(text);\r\n    const firstSAValue = BWT.createCircularSuffixArray(text)[0];\r\n    let p = firstSAValue;\r\n    const r = new Array();\r\n    const secondLCPValue = computeNextLCPValue(firstSAValue, sampledSuffixArrayForEndingPositions, sampledLCPArrayForEndingPositions);\r\n    r.push(0);\r\n    r.push(secondLCPValue);\r\n    for (let i = 1; i < text.length - 1; i++) {\r\n        p = computeNextSuffixArrayValue(p, sampledSuffixArrayForEndingPositions, differentialSampledSuffixArrayForEndingPositions);\r\n        const lcp = computeNextLCPValue(p, sampledSuffixArrayForEndingPositions, sampledLCPArrayForEndingPositions);\r\n        r.push(lcp);\r\n    }\r\n    return r;\r\n}\r\nexports.createLCPArray = createLCPArray;\r\nfunction createSuffixArrayFromBack(text) {\r\n    const sampledSuffixArrayForStartingPositions = createSampledSuffixArrayForStartingPositions(text);\r\n    const differentialSampledSuffixArrayForStartingPositions = createDifferentialSampledSuffixArrayForStartingPositions(text);\r\n    const lastSAValue = BWT.createCircularSuffixArray(text)[text.length - 1];\r\n    let p = lastSAValue;\r\n    const r = new Array(text.length);\r\n    r[text.length - 1] = p;\r\n    for (let i = text.length - 2; i >= 0; i--) {\r\n        p = computePreviousSuffixArrayValue(p, sampledSuffixArrayForStartingPositions, differentialSampledSuffixArrayForStartingPositions);\r\n        r[i] = p;\r\n    }\r\n    return r;\r\n}\r\nexports.createSuffixArrayFromBack = createSuffixArrayFromBack;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/permutations/sa_on_rlbwt.ts?");

/***/ }),

/***/ "./src/sequences/fibonacci_sequence.ts":
/*!*********************************************!*\
  !*** ./src/sequences/fibonacci_sequence.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fibArray = new Map();\r\nfunction createIthSequence(ith) {\r\n    if (ith == 0) {\r\n        if (!fibArray.has(ith)) {\r\n            fibArray.set(ith, \"\");\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n    else if (ith == 1) {\r\n        if (!fibArray.has(ith)) {\r\n            fibArray.set(ith, \"b\");\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n    else if (ith == 2) {\r\n        if (!fibArray.has(ith)) {\r\n            fibArray.set(ith, \"a\");\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n    else {\r\n        if (!fibArray.has(ith)) {\r\n            const str = createIthSequence(ith - 1) + createIthSequence(ith - 2);\r\n            fibArray.set(ith, str);\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n}\r\nexports.createIthSequence = createIthSequence;\r\nfunction create(length) {\r\n    let i = 2;\r\n    while (true) {\r\n        const str = createIthSequence(i++);\r\n        if (str.length > length) {\r\n            return str.substr(0, length);\r\n        }\r\n    }\r\n}\r\nexports.create = create;\r\nfunction getWord(ith) {\r\n    let i = 0;\r\n    while (true) {\r\n        const str = createIthSequence(i++);\r\n        if (i == ith) {\r\n            return str;\r\n        }\r\n        else {\r\n            i++;\r\n        }\r\n    }\r\n}\r\nexports.getWord = getWord;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/sequences/fibonacci_sequence.ts?");

/***/ }),

/***/ "./src/sequences/index.ts":
/*!********************************!*\
  !*** ./src/sequences/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst FibonacciSequence = __webpack_require__(/*! ./fibonacci_sequence */ \"./src/sequences/fibonacci_sequence.ts\");\r\nexports.FibonacciSequence = FibonacciSequence;\r\nconst ThueMorseSequence = __webpack_require__(/*! ./thue_morse_sequence */ \"./src/sequences/thue_morse_sequence.ts\");\r\nexports.ThueMorseSequence = ThueMorseSequence;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/sequences/index.ts?");

/***/ }),

/***/ "./src/sequences/thue_morse_sequence.ts":
/*!**********************************************!*\
  !*** ./src/sequences/thue_morse_sequence.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fibArray = new Map();\r\nfunction rev(str) {\r\n    let r = \"\";\r\n    for (let i = 0; i < str.length; i++) {\r\n        if (str[i] == \"0\") {\r\n            r += \"1\";\r\n        }\r\n        else {\r\n            r += \"0\";\r\n        }\r\n    }\r\n    return r;\r\n}\r\nfunction createIthSequence(ith) {\r\n    if (ith == 0) {\r\n        if (!fibArray.has(ith)) {\r\n            fibArray.set(ith, \"\");\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n    else if (ith == 1) {\r\n        if (!fibArray.has(ith)) {\r\n            fibArray.set(ith, \"0\");\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n    else {\r\n        if (!fibArray.has(ith)) {\r\n            const str = createIthSequence(ith - 1) + rev(createIthSequence(ith - 1));\r\n            fibArray.set(ith, str);\r\n        }\r\n        return fibArray.get(ith);\r\n    }\r\n}\r\nexports.createIthSequence = createIthSequence;\r\nfunction create(len) {\r\n    let i = 1;\r\n    while (true) {\r\n        const str = createIthSequence(i);\r\n        if (str.length < len) {\r\n            i++;\r\n        }\r\n        else {\r\n            return str.substr(0, len);\r\n        }\r\n    }\r\n}\r\nexports.create = create;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/sequences/thue_morse_sequence.ts?");

/***/ }),

/***/ "./src/substrings/distinct_substrings.ts":
/*!***********************************************!*\
  !*** ./src/substrings/distinct_substrings.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction sort(strings) {\r\n    strings.sort((a, b) => {\r\n        if (a < b)\r\n            return -1;\r\n        if (a > b)\r\n            return 1;\r\n        return 0;\r\n    });\r\n}\r\nexports.sort = sort;\r\nfunction enumerate(text) {\r\n    const map = createOccurrenceMap(text);\r\n    const r = new Array(0);\r\n    map.forEach((value, key) => {\r\n        r.push(key);\r\n    });\r\n    sort(r);\r\n    return r;\r\n}\r\nexports.enumerate = enumerate;\r\nfunction createOccurrenceMap(text) {\r\n    let map = new Map();\r\n    for (let i = 0; i < text.length; i++) {\r\n        for (let len = 1; len <= text.length - i; len++) {\r\n            const substr = text.substr(i, len);\r\n            if (map.has(substr)) {\r\n                const occs = map.get(substr);\r\n                occs.push(i);\r\n                map.set(substr, occs);\r\n            }\r\n            else {\r\n                map.set(substr, [i]);\r\n            }\r\n        }\r\n    }\r\n    return map;\r\n}\r\nexports.createOccurrenceMap = createOccurrenceMap;\r\nfunction enumerateWithInfo(text) {\r\n    const arr = [];\r\n    createOccurrenceMap(text).forEach((occs, substr) => {\r\n        arr.push({ substring: substr, occurrences: occs });\r\n    });\r\n    arr.sort((a, b) => {\r\n        if (a < b)\r\n            return -1;\r\n        if (a > b)\r\n            return 1;\r\n        return 0;\r\n    });\r\n    return arr;\r\n}\r\nexports.enumerateWithInfo = enumerateWithInfo;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/substrings/distinct_substrings.ts?");

/***/ }),

/***/ "./src/substrings/index.ts":
/*!*********************************!*\
  !*** ./src/substrings/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst MinimalUniqueSubstrings = __webpack_require__(/*! ./minimal_unique_substrings */ \"./src/substrings/minimal_unique_substrings.ts\");\r\nexports.MinimalUniqueSubstrings = MinimalUniqueSubstrings;\r\nconst DistinctSubstrings = __webpack_require__(/*! ./distinct_substrings */ \"./src/substrings/distinct_substrings.ts\");\r\nexports.DistinctSubstrings = DistinctSubstrings;\r\nconst MaximalRepeats = __webpack_require__(/*! ./maximal_repeats */ \"./src/substrings/maximal_repeats.ts\");\r\nexports.MaximalRepeats = MaximalRepeats;\r\nconst MinimalRepeats = __webpack_require__(/*! ./minimal_repeats */ \"./src/substrings/minimal_repeats.ts\");\r\nexports.MinimalRepeats = MinimalRepeats;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/substrings/index.ts?");

/***/ }),

/***/ "./src/substrings/maximal_repeats.ts":
/*!*******************************************!*\
  !*** ./src/substrings/maximal_repeats.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DistinctSubstrings = __webpack_require__(/*! ./distinct_substrings */ \"./src/substrings/distinct_substrings.ts\");\r\nfunction getAlphabet(text) {\r\n    const checker = new Set();\r\n    for (let i = 0; i < text.length; i++) {\r\n        checker.add(text[i]);\r\n    }\r\n    return checker;\r\n}\r\nexports.getAlphabet = getAlphabet;\r\nfunction enumerate(text) {\r\n    const map = DistinctSubstrings.createOccurrenceMap(text);\r\n    const substrSet = new Set();\r\n    const characters = getAlphabet(text);\r\n    map.forEach((occs, substr) => {\r\n        let bLeft = true;\r\n        let bRight = true;\r\n        characters.forEach((c) => {\r\n            const right = substr + c;\r\n            const rightOcc = map.get(right);\r\n            const left = c + substr;\r\n            const leftOcc = map.get(left);\r\n            if (rightOcc !== undefined && rightOcc.length == occs.length) {\r\n                bRight = false;\r\n            }\r\n            if (leftOcc !== undefined && leftOcc.length == occs.length) {\r\n                bLeft = false;\r\n            }\r\n        });\r\n        if (bLeft && bRight && occs.length != 1) {\r\n            substrSet.add(substr);\r\n        }\r\n    });\r\n    const r = new Array(0);\r\n    substrSet.forEach((substr) => {\r\n        r.push(substr);\r\n    });\r\n    DistinctSubstrings.sort(r);\r\n    return r;\r\n}\r\nexports.enumerate = enumerate;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/substrings/maximal_repeats.ts?");

/***/ }),

/***/ "./src/substrings/minimal_repeats.ts":
/*!*******************************************!*\
  !*** ./src/substrings/minimal_repeats.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DistinctSubstrings = __webpack_require__(/*! ./distinct_substrings */ \"./src/substrings/distinct_substrings.ts\");\r\nconst MaximalRepeats = __webpack_require__(/*! ./maximal_repeats */ \"./src/substrings/maximal_repeats.ts\");\r\nfunction enumerate(text) {\r\n    const map = DistinctSubstrings.createOccurrenceMap(text);\r\n    const substrSet = new Set();\r\n    const characters = MaximalRepeats.getAlphabet(text);\r\n    map.forEach((occs, substr) => {\r\n        let bLeft = true;\r\n        let bRight = true;\r\n        characters.forEach((c) => {\r\n            const right = substr.substr(0, substr.length - 1);\r\n            const rightOcc = map.get(right);\r\n            const left = substr.substr(1, substr.length - 1);\r\n            const leftOcc = map.get(left);\r\n            if (rightOcc !== undefined && rightOcc.length == occs.length) {\r\n                bRight = false;\r\n            }\r\n            if (leftOcc !== undefined && leftOcc.length == occs.length) {\r\n                bLeft = false;\r\n            }\r\n        });\r\n        if (bLeft && bRight) {\r\n            substrSet.add(substr);\r\n        }\r\n    });\r\n    const r = new Array(0);\r\n    substrSet.forEach((substr) => {\r\n        r.push(substr);\r\n    });\r\n    DistinctSubstrings.sort(r);\r\n    return r;\r\n}\r\nexports.enumerate = enumerate;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/substrings/minimal_repeats.ts?");

/***/ }),

/***/ "./src/substrings/minimal_unique_substrings.ts":
/*!*****************************************************!*\
  !*** ./src/substrings/minimal_unique_substrings.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DistinctSubstrings = __webpack_require__(/*! ./distinct_substrings */ \"./src/substrings/distinct_substrings.ts\");\r\nfunction enumerate(text) {\r\n    const map = DistinctSubstrings.createOccurrenceMap(text);\r\n    const r = new Array(0);\r\n    map.forEach((occs, substr) => {\r\n        if (occs.length == 1) {\r\n            if (substr.length == 1) {\r\n                r.push(substr);\r\n            }\r\n            else {\r\n                const left = substr.substr(1);\r\n                const right = substr.substr(0, substr.length - 1);\r\n                if (map.get(left).length > 1 && map.get(right).length > 1) {\r\n                    r.push(substr);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    DistinctSubstrings.sort(r);\r\n    return r;\r\n}\r\nexports.enumerate = enumerate;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/substrings/minimal_unique_substrings.ts?");

/***/ }),

/***/ "./src/trees/compact_trie.ts":
/*!***********************************!*\
  !*** ./src/trees/compact_trie.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Trie = __webpack_require__(/*! ./trie */ \"./src/trees/trie.ts\");\r\nfunction construct(texts) {\r\n    const root = Trie.construct(texts);\r\n    while (true) {\r\n        let b = false;\r\n        const nodes = root.getOrderedNodes();\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            for (let x = 0; x < node.children.length; x++) {\r\n                const b1 = compact(node.children[x], node);\r\n                if (b1) {\r\n                    b = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (b)\r\n                break;\r\n        }\r\n        if (!b) {\r\n            break;\r\n        }\r\n    }\r\n    return root;\r\n}\r\nexports.construct = construct;\r\nfunction compact(node, parent) {\r\n    if (node.children.length == 1) {\r\n        const p = parent.children.findIndex((v) => { return v == node; });\r\n        if (p >= 0) {\r\n            const newChild = node.children[0];\r\n            const newText = node.textContent + newChild.textContent;\r\n            parent.children[p] = newChild;\r\n            newChild.textContent = newText;\r\n            return true;\r\n        }\r\n        else {\r\n            throw Error(\"error\");\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nexports.compact = compact;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/trees/compact_trie.ts?");

/***/ }),

/***/ "./src/trees/index.ts":
/*!****************************!*\
  !*** ./src/trees/index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Trie = __webpack_require__(/*! ./trie */ \"./src/trees/trie.ts\");\r\nexports.Trie = Trie;\r\nconst SuffixTrie = __webpack_require__(/*! ./suffix_trie */ \"./src/trees/suffix_trie.ts\");\r\nexports.SuffixTrie = SuffixTrie;\r\nconst SuffixTree = __webpack_require__(/*! ./suffix_tree */ \"./src/trees/suffix_tree.ts\");\r\nexports.SuffixTree = SuffixTree;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/trees/index.ts?");

/***/ }),

/***/ "./src/trees/suffix_tree.ts":
/*!**********************************!*\
  !*** ./src/trees/suffix_tree.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CompactTrie = __webpack_require__(/*! ./compact_trie */ \"./src/trees/compact_trie.ts\");\r\nconst SuffixTrie = __webpack_require__(/*! ./suffix_trie */ \"./src/trees/suffix_trie.ts\");\r\nfunction construct(text) {\r\n    const tree = CompactTrie.construct(SuffixTrie.enumerateSuffixes(text));\r\n    return tree;\r\n}\r\nexports.construct = construct;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/trees/suffix_tree.ts?");

/***/ }),

/***/ "./src/trees/suffix_trie.ts":
/*!**********************************!*\
  !*** ./src/trees/suffix_trie.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Trie = __webpack_require__(/*! ./trie */ \"./src/trees/trie.ts\");\r\nfunction enumerateSuffixes(text) {\r\n    const texts = new Array();\r\n    for (let i = 0; i < text.length; i++) {\r\n        texts.push(text.substr(i));\r\n    }\r\n    return texts;\r\n}\r\nexports.enumerateSuffixes = enumerateSuffixes;\r\nfunction construct(text) {\r\n    return Trie.construct(enumerateSuffixes(text));\r\n}\r\nexports.construct = construct;\r\n\n\n//# sourceURL=webpack://Sutoring/./src/trees/suffix_trie.ts?");

/***/ }),

/***/ "./src/trees/trie.ts":
/*!***************************!*\
  !*** ./src/trees/trie.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_svg_1 = __webpack_require__(/*! graph-table-svg */ \"./node_modules/graph-table-svg/dist/index.js\");\r\nfunction construct(texts) {\r\n    const root = new graph_table_svg_1.Logics.LogicTree();\r\n    texts.forEach((v) => {\r\n        add(root, v);\r\n    });\r\n    return root;\r\n}\r\nexports.construct = construct;\r\nfunction add(root, text) {\r\n    let node = root;\r\n    for (let i = 0; i < text.length; i++) {\r\n        node = addOrGetChild(node, text[i]);\r\n    }\r\n    return node;\r\n}\r\nfunction addOrGetChild(node, char) {\r\n    let k = 0;\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (child.edgeOption.text == char) {\r\n            return child;\r\n        }\r\n        else {\r\n            if (char < child.edgeOption.text) {\r\n            }\r\n            else {\r\n                const newNode = new graph_table_svg_1.Logics.LogicTree();\r\n                newNode.edgeOption.text = char;\r\n                node.children.splice(i, 0, newNode);\r\n                return newNode;\r\n            }\r\n        }\r\n    }\r\n    const newNode = new graph_table_svg_1.Logics.LogicTree();\r\n    newNode.edgeOption.text = char;\r\n    node.children.splice(node.children.length, 0, newNode);\r\n    return newNode;\r\n}\r\n\n\n//# sourceURL=webpack://Sutoring/./src/trees/trie.ts?");

/***/ })

/******/ });