var Sutoring =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../GraphTableSVG/src/basic/common/color.ts":
/*!**************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/color.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Color;\r\n(function (Color) {\r\n    const colorNameArray = new Array(\"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\");\r\n    let colorDic;\r\n    const rValue = new Array(\"F0\", \"FA\", \"00\", \"7F\", \"F0\", \"F5\", \"FF\", \"00\", \"FF\", \"00\", \"8A\", \"A5\", \"DE\", \"5F\", \"7F\", \"D2\", \"FF\", \"64\", \"FF\", \"DC\", \"00\", \"00\", \"00\", \"B8\", \"A9\", \"00\", \"BD\", \"8B\", \"55\", \"FF\", \"99\", \"8B\", \"E9\", \"8F\", \"48\", \"2F\", \"00\", \"94\", \"FF\", \"00\", \"69\", \"1E\", \"B2\", \"FF\", \"22\", \"FF\", \"DC\", \"F8\", \"FF\", \"DA\", \"80\", \"00\", \"AD\", \"F0\", \"FF\", \"CD\", \"4B\", \"FF\", \"F0\", \"E6\", \"FF\", \"7C\", \"FF\", \"AD\", \"F0\", \"E0\", \"FA\", \"90\", \"D3\", \"FF\", \"FF\", \"20\", \"87\", \"77\", \"B0\", \"FF\", \"00\", \"32\", \"FA\", \"FF\", \"80\", \"66\", \"00\", \"BA\", \"93\", \"3C\", \"7B\", \"00\", \"48\", \"C7\", \"19\", \"F5\", \"FF\", \"FF\", \"FF\", \"00\", \"FD\", \"80\", \"6B\", \"FF\", \"FF\", \"DA\", \"EE\", \"98\", \"AF\", \"DB\", \"FF\", \"FF\", \"CD\", \"FF\", \"DD\", \"B0\", \"80\", \"FF\", \"BC\", \"41\", \"8B\", \"FA\", \"F4\", \"2E\", \"FF\", \"A0\", \"C0\", \"87\", \"6A\", \"70\", \"FF\", \"00\", \"46\", \"D2\", \"00\", \"D8\", \"FF\", \"40\", \"EE\", \"F5\", \"FF\", \"F5\", \"FF\", \"9A\");\r\n    const gValue = new Array(\"F8\", \"EB\", \"FF\", \"FF\", \"FF\", \"F5\", \"E4\", \"00\", \"EB\", \"00\", \"2B\", \"2A\", \"B8\", \"9E\", \"FF\", \"69\", \"7F\", \"95\", \"F8\", \"14\", \"FF\", \"00\", \"8B\", \"86\", \"A9\", \"64\", \"B7\", \"00\", \"6B\", \"8C\", \"32\", \"00\", \"96\", \"BC\", \"3D\", \"4F\", \"CE\", \"00\", \"14\", \"BF\", \"69\", \"90\", \"22\", \"FA\", \"8B\", \"00\", \"DC\", \"F8\", \"D7\", \"A5\", \"80\", \"80\", \"FF\", \"FF\", \"69\", \"5C\", \"00\", \"FF\", \"E6\", \"E6\", \"F0\", \"FC\", \"FA\", \"D8\", \"80\", \"FF\", \"FA\", \"EE\", \"D3\", \"B6\", \"A0\", \"B2\", \"CE\", \"88\", \"C4\", \"FF\", \"FF\", \"CD\", \"F0\", \"00\", \"00\", \"CD\", \"00\", \"55\", \"70\", \"B3\", \"68\", \"FA\", \"D1\", \"15\", \"19\", \"FF\", \"E4\", \"E4\", \"DE\", \"00\", \"F5\", \"80\", \"8E\", \"A5\", \"45\", \"70\", \"E8\", \"FB\", \"EE\", \"70\", \"EF\", \"DA\", \"85\", \"C0\", \"A0\", \"E0\", \"00\", \"00\", \"8F\", \"69\", \"45\", \"80\", \"A4\", \"8B\", \"F5\", \"52\", \"C0\", \"CE\", \"5A\", \"80\", \"FA\", \"FF\", \"82\", \"B4\", \"80\", \"BF\", \"63\", \"E0\", \"82\", \"DE\", \"FF\", \"F5\", \"FF\", \"CD\");\r\n    const bValue = new Array(\"FF\", \"D7\", \"FF\", \"D4\", \"FF\", \"DC\", \"C4\", \"00\", \"CD\", \"FF\", \"E2\", \"2A\", \"87\", \"A0\", \"00\", \"1E\", \"50\", \"ED\", \"DC\", \"3C\", \"FF\", \"8B\", \"8B\", \"0B\", \"A9\", \"00\", \"6B\", \"8B\", \"2F\", \"00\", \"CC\", \"00\", \"7A\", \"8F\", \"8B\", \"4F\", \"D1\", \"D3\", \"93\", \"FF\", \"69\", \"FF\", \"22\", \"F0\", \"22\", \"FF\", \"DC\", \"FF\", \"00\", \"20\", \"80\", \"00\", \"2F\", \"F0\", \"B4\", \"5C\", \"82\", \"F0\", \"8C\", \"FA\", \"F5\", \"00\", \"CD\", \"E6\", \"80\", \"FF\", \"D2\", \"90\", \"D3\", \"C1\", \"7A\", \"AA\", \"FA\", \"99\", \"DE\", \"E0\", \"00\", \"32\", \"E6\", \"FF\", \"00\", \"AA\", \"CD\", \"D3\", \"DB\", \"71\", \"EE\", \"9A\", \"CC\", \"85\", \"70\", \"FA\", \"E1\", \"B5\", \"AD\", \"80\", \"E6\", \"00\", \"23\", \"00\", \"00\", \"D6\", \"AA\", \"98\", \"EE\", \"93\", \"D5\", \"B9\", \"3F\", \"CB\", \"DD\", \"E6\", \"80\", \"00\", \"8F\", \"E1\", \"13\", \"72\", \"60\", \"57\", \"EE\", \"2D\", \"C0\", \"EB\", \"CD\", \"90\", \"FA\", \"7F\", \"B4\", \"8C\", \"80\", \"D8\", \"47\", \"D0\", \"EE\", \"B3\", \"FF\", \"F5\", \"00\", \"32\");\r\n    function createHexCodeFromColorName(colorName) {\r\n        if (!colorDic) {\r\n            colorDic = {};\r\n            for (let i = 0; i < colorNameArray.length; i++) {\r\n                colorDic[colorNameArray[i]] = i;\r\n            }\r\n        }\r\n        if (colorName in colorDic) {\r\n            const i = colorDic[colorName];\r\n            return rValue[i] + gValue[i] + bValue[i];\r\n        }\r\n        else {\r\n            return colorName;\r\n        }\r\n    }\r\n    Color.createHexCodeFromColorName = createHexCodeFromColorName;\r\n    function createHexFromColorName(colorName) {\r\n        if (!colorDic) {\r\n            colorDic = {};\r\n            for (let i = 0; i < colorNameArray.length; i++) {\r\n                colorDic[colorNameArray[i]] = i;\r\n            }\r\n        }\r\n        if (colorName in colorDic) {\r\n            const i = colorDic[colorName];\r\n            return { r: parseInt(rValue[i], 16), g: parseInt(gValue[i], 16), b: parseInt(bValue[i], 16) };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    Color.createHexFromColorName = createHexFromColorName;\r\n    function createRGBCodeFromColorName(colorName) {\r\n        colorName = createHexCodeFromColorName(colorName);\r\n        if (colorName.substr(0, 3) === \"rgb\") {\r\n            return colorName;\r\n        }\r\n        else {\r\n            if (colorNameArray.length === 6) {\r\n                const r = colorName.substr(0, 2);\r\n                const g = colorName.substr(2, 2);\r\n                const b = colorName.substr(4, 2);\r\n                return `rgb(${parseInt(r, 16)}, ${parseInt(g, 16)}, ${parseInt(b, 16)})`;\r\n            }\r\n            else {\r\n                return `rgb(${80}, ${80}, ${80})`;\r\n            }\r\n        }\r\n    }\r\n    Color.createRGBCodeFromColorName = createRGBCodeFromColorName;\r\n    function createRGBFromColorName(str) {\r\n        const v = createHexFromColorName(str);\r\n        const def = { r: 80, g: 80, b: 80 };\r\n        if (v != null) {\r\n            return v;\r\n        }\r\n        else {\r\n            if (str.substr(0, 3) === \"rgb\") {\r\n                str = str.replace(\"rgb(\", \"\");\r\n                str = str.replace(\")\", \"\");\r\n                const values = str.split(\",\");\r\n                if (values.length === 3) {\r\n                    return { b: parseInt(values[2], undefined), g: parseInt(values[1], undefined),\r\n                        r: parseInt(values[0], undefined) };\r\n                }\r\n                else {\r\n                    return def;\r\n                }\r\n            }\r\n            else if (str.length === 6) {\r\n                const r = str.substr(0, 2);\r\n                const g = str.substr(2, 2);\r\n                const b = str.substr(4, 2);\r\n                return { g: parseInt(g, undefined), b: parseInt(b, undefined), r: parseInt(r, undefined) };\r\n            }\r\n            else {\r\n                return def;\r\n            }\r\n        }\r\n    }\r\n    Color.createRGBFromColorName = createRGBFromColorName;\r\n})(Color = exports.Color || (exports.Color = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/color.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/common/common_functions.ts":
/*!*************************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/common_functions.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CSS = __webpack_require__(/*! ../svghtml/css */ \"../GraphTableSVG/src/basic/svghtml/css.ts\");\r\nvar CommonFunctions;\r\n(function (CommonFunctions) {\r\n    function IsDescendantOfBody(node) {\r\n        const parent = node.parentNode;\r\n        if (parent == null) {\r\n            return false;\r\n        }\r\n        else if (parent == document.body) {\r\n            return true;\r\n        }\r\n        else {\r\n            return CommonFunctions.IsDescendantOfBody(parent);\r\n        }\r\n    }\r\n    CommonFunctions.IsDescendantOfBody = IsDescendantOfBody;\r\n    function paddingLeft(text, length, leftChar) {\r\n        while (text.length < length) {\r\n            text = leftChar + text;\r\n        }\r\n        return text;\r\n    }\r\n    CommonFunctions.paddingLeft = paddingLeft;\r\n    const CSSName = \"___GraphTableCSS\";\r\n    let createdGraphTableCSS = false;\r\n    function setGraphTableCSS() {\r\n        if (createdGraphTableCSS)\r\n            return;\r\n        const item = document.head.getElementsByClassName(CSSName);\r\n        if (item.length > 0) {\r\n            document.head.removeChild(item[0]);\r\n        }\r\n        var blankStyle = document.createElement('style');\r\n        blankStyle.innerHTML = CSS.Common.createCSS();\r\n        blankStyle.type = \"text/css\";\r\n        blankStyle.setAttribute(\"class\", CSSName);\r\n        const head = document.getElementsByTagName('head');\r\n        const fstItem = head.item(0).firstChild;\r\n        if (fstItem == null) {\r\n            head.item(0).appendChild(blankStyle);\r\n        }\r\n        else {\r\n            head.item(0).insertBefore(blankStyle, fstItem);\r\n        }\r\n        createdGraphTableCSS = true;\r\n    }\r\n    CommonFunctions.setGraphTableCSS = setGraphTableCSS;\r\n    function getGraphTableCSS() {\r\n        const item = document.getElementById(CSSName);\r\n        return item;\r\n    }\r\n    CommonFunctions.getGraphTableCSS = getGraphTableCSS;\r\n    function parseUnit(text) {\r\n        let str1 = \"\", str2 = \"\";\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (isNaN(text[i]) && text[i] != \".\") {\r\n                str2 += text[i];\r\n            }\r\n            else {\r\n                str1 += text[i];\r\n            }\r\n        }\r\n        return [Number(str1), str2];\r\n    }\r\n    CommonFunctions.parseUnit = parseUnit;\r\n    function toPX(value) {\r\n        const [val, unit] = parseUnit(value);\r\n        if (unit == \"px\") {\r\n            return val;\r\n        }\r\n        else if (unit == \"em\") {\r\n            return val * 16;\r\n        }\r\n        else if (unit == \"pt\") {\r\n            return (val / 72) * 96;\r\n        }\r\n        else {\r\n            return val;\r\n        }\r\n    }\r\n    CommonFunctions.toPX = toPX;\r\n    function bezierLocation([px1, py1], [px2, py2], [px3, py3], t) {\r\n        const x = px1 * (1 - t) * (1 - t) + 2 * px2 * t * (1 - t) + px3 * t * t;\r\n        const y = py1 * (1 - t) * (1 - t) + 2 * py2 * t * (1 - t) + py3 * t * t;\r\n        return [x, y];\r\n    }\r\n    CommonFunctions.bezierLocation = bezierLocation;\r\n})(CommonFunctions = exports.CommonFunctions || (exports.CommonFunctions = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/common_functions.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/common/custtome_attributes.ts":
/*!****************************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/custtome_attributes.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CustomAttributeNames;\r\n(function (CustomAttributeNames) {\r\n    let Style;\r\n    (function (Style) {\r\n        Style.autoSizeShapeToFitText = \"--autosize-shape-to-fit-text\";\r\n        Style.beginConnectorType = \"--begin-connector-type\";\r\n        Style.endConnectorType = \"--end-connector-type\";\r\n        Style.markerStart = \"--marker-start\";\r\n        Style.markerEnd = \"--marker-end\";\r\n        Style.vertexXInterval = \"--vertex-x-interval\";\r\n        Style.vertexYInterval = \"--vertex-y-interval\";\r\n        Style.defaultRadius = \"--default-radius\";\r\n        Style.defaultWidth = \"--default-width\";\r\n        Style.defaultHeight = \"--default-height\";\r\n        Style.defaultSurfaceType = \"--default-surface-type\";\r\n        Style.paddingTop = \"--padding-top\";\r\n        Style.paddingLeft = \"--padding-left\";\r\n        Style.paddingRight = \"--padding-right\";\r\n        Style.paddingBottom = \"--padding-bottom\";\r\n        Style.marginTop = \"--margin-top\";\r\n        Style.marginLeft = \"--margin-left\";\r\n        Style.marginRight = \"--margin-right\";\r\n        Style.marginBottom = \"--margin-bottom\";\r\n        Style.VerticalAnchor = \"--vertical-anchor\";\r\n        Style.HorizontalAnchor = \"--horizontal-anchor\";\r\n        Style.PathTextAlignment = \"--path-text-alignment\";\r\n        Style.msoDashStyleName = \"--stroke-style\";\r\n        Style.relocateName = \"--relocate\";\r\n        Style.prohibitionOutOfRange = \"--prohibition-out-of-range\";\r\n    })(Style = CustomAttributeNames.Style || (CustomAttributeNames.Style = {}));\r\n    let StyleValue;\r\n    (function (StyleValue) {\r\n        StyleValue.defaultTextClass = \"___text-default\";\r\n        StyleValue.defaultCellClass = \"___cell-default\";\r\n        StyleValue.defaultSurfaceClass = \"___surface-default\";\r\n        StyleValue.defaultPathSurfaceClass = \"___path-surface-default\";\r\n        StyleValue.defaultEdgePathClass = \"___default-edge-path\";\r\n        StyleValue.defaultTextboxPathClass = \"___default-textbox-path\";\r\n        StyleValue.defaultCellBackgroungClass = \"___cell-background-default\";\r\n        StyleValue.defaultCellBorderClass = \"___cell-border-default\";\r\n        StyleValue.defaultRectButtonSurfaceClass = \"___rect-button-surface-default\";\r\n        StyleValue.defaultRectButtonClass = \"___rect-button-surface-default\";\r\n        StyleValue.defaultEdgeClass = \"__default-edge\";\r\n        StyleValue.defaultVertexClass = \"__default-vertex\";\r\n        StyleValue.defaultConsoleColumnTitleCellClass = \"___column_title_cell\";\r\n        StyleValue.defaultConsoleColumnTitleCellTextClass = \"___column_title_text_cell\";\r\n        StyleValue.defaultConsoleColumnTitleCellUndefinedTextClass = \"___column_title_undefined_text_cell\";\r\n        StyleValue.defaultConsoleColumnTitleCellBackgroundClass = \"___column_title_background_cell\";\r\n    })(StyleValue = CustomAttributeNames.StyleValue || (CustomAttributeNames.StyleValue = {}));\r\n    CustomAttributeNames.beginNodeName = \"data-begin-node\";\r\n    CustomAttributeNames.endNodeName = \"data-end-node\";\r\n    CustomAttributeNames.isAppropriatelyReverseTextMode = \"data-appropriately-reverse-text\";\r\n    CustomAttributeNames.controlPointName = \"data-control-point\";\r\n    CustomAttributeNames.connectPositionChangedEventName = \"connect_position_changed\";\r\n    CustomAttributeNames.resizeName = \"resized\";\r\n    CustomAttributeNames.vertexCreatedEventName = \"vertex_created\";\r\n    CustomAttributeNames.objectCreatedEventName = \"object_created\";\r\n    CustomAttributeNames.GroupAttribute = \"data-type\";\r\n    CustomAttributeNames.objectIDName = \"data-objectID\";\r\n    CustomAttributeNames.customElement = \"data-custom\";\r\n    CustomAttributeNames.cellEmphasisCellClass = \"___cell-emphasis\";\r\n    CustomAttributeNames.cellEmphasisBorderClass = \"___border-emphasis\";\r\n    CustomAttributeNames.cellTemporaryBorderClass = \"___temporary-class\";\r\n    CustomAttributeNames.defaultCircleRadius = 15;\r\n})(CustomAttributeNames = exports.CustomAttributeNames || (exports.CustomAttributeNames = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/custtome_attributes.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/common/enums.ts":
/*!**************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/enums.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ./custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nvar VertexOrder;\r\n(function (VertexOrder) {\r\n    VertexOrder[VertexOrder[\"Preorder\"] = 0] = \"Preorder\";\r\n    VertexOrder[VertexOrder[\"Postorder\"] = 1] = \"Postorder\";\r\n})(VertexOrder = exports.VertexOrder || (exports.VertexOrder = {}));\r\nvar ShapeObjectType;\r\n(function (ShapeObjectType) {\r\n    ShapeObjectType.Callout = \"g-callout\";\r\n    ShapeObjectType.ArrowCallout = \"g-arrow-callout\";\r\n    ShapeObjectType.Ellipse = \"g-ellipse\";\r\n    ShapeObjectType.Rect = \"g-rect\";\r\n    ShapeObjectType.Edge = \"g-edge\";\r\n    ShapeObjectType.Graph = \"g-graph\";\r\n    ShapeObjectType.Table = \"g-table\";\r\n    ShapeObjectType.Object = \"g-object\";\r\n    ShapeObjectType.PathTextBox = \"g-path-textbox\";\r\n    ShapeObjectType.RectButton = \"g-rect-button\";\r\n    const typeDic = {\r\n        \"g-callout\": true,\r\n        \"g-arrow-callout\": true,\r\n        \"g-ellipse\": true,\r\n        \"g-rect\": true,\r\n        \"g-edge\": true,\r\n        \"g-graph\": true,\r\n        \"g-table\": true,\r\n        \"g-object\": true,\r\n        \"g-path-textbox\": true,\r\n        \"g-rect-button\": true\r\n    };\r\n    const customTypeDic = {\r\n        \"row\": true,\r\n        \"cell\": true,\r\n        \"t\": true\r\n    };\r\n    function toShapeObjectType(value) {\r\n        if (value in typeDic) {\r\n            return value;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    ShapeObjectType.toShapeObjectType = toShapeObjectType;\r\n    function toShapeObjectTypeOrCustomTag(value) {\r\n        const value1 = toShapeObjectType(value);\r\n        if (value1 != null) {\r\n            return value1;\r\n        }\r\n        else {\r\n            if (value in customTypeDic) {\r\n                return value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    ShapeObjectType.toShapeObjectTypeOrCustomTag = toShapeObjectTypeOrCustomTag;\r\n})(ShapeObjectType = exports.ShapeObjectType || (exports.ShapeObjectType = {}));\r\nvar PathTextAlighnment;\r\n(function (PathTextAlighnment) {\r\n    PathTextAlighnment.regularInterval = \"regularInterval\";\r\n    PathTextAlighnment.begin = \"begin\";\r\n    PathTextAlighnment.end = \"end\";\r\n    PathTextAlighnment.center = \"center\";\r\n    const typeDic = {\r\n        \"none\": \"none\",\r\n        \"begin\": \"begin\",\r\n        \"end\": \"end\",\r\n        \"center\": \"center\",\r\n        \"regularInterval\": \"regularInterval\",\r\n    };\r\n    function toPathTextAlighnment(value) {\r\n        if (value in typeDic) {\r\n            return typeDic[value];\r\n        }\r\n        else {\r\n            return \"none\";\r\n        }\r\n    }\r\n    PathTextAlighnment.toPathTextAlighnment = toPathTextAlighnment;\r\n})(PathTextAlighnment = exports.PathTextAlighnment || (exports.PathTextAlighnment = {}));\r\nvar msoDashStyle;\r\n(function (msoDashStyle) {\r\n    msoDashStyle.msoLineDash = \"msoLineDash\";\r\n    msoDashStyle.msoLineDashDot = \"msoLineDashDot\";\r\n    msoDashStyle.msoLineDashDotDot = \"msoLineDashDotDot\";\r\n    msoDashStyle.msoLineLongDash = \"msoLineLongDash\";\r\n    msoDashStyle.msoLineLongDashDot = \"msoLineLongDashDot\";\r\n    msoDashStyle.msoLineRoundDot = \"msoLineRoundDot\";\r\n    msoDashStyle.msoLineSolid = \"msoLineSolid\";\r\n    msoDashStyle.msoLineSquareDot = \"msoLineSquareDot\";\r\n    msoDashStyle.dashArrayDic = {\r\n        \"msoLineDash\": [4, 3],\r\n        \"msoLineDashDot\": [4, 3, 1, 3],\r\n        \"msoLineDashDotDot\": [3, 1, 1, 1, 1, 1],\r\n        \"msoLineLongDash\": [9, 3],\r\n        \"msoLineLongDashDot\": [9, 3, 1, 3],\r\n        \"msoLineRoundDot\": [0.25, 2],\r\n        \"msoLineSolid\": [],\r\n        \"msoLineSquareDot\": [1, 1]\r\n    };\r\n    const lineCapDic = {\r\n        \"msoLineDash\": \"butt\",\r\n        \"msoLineDashDot\": \"butt\",\r\n        \"msoLineDashDotDot\": \"butt\",\r\n        \"msoLineLongDash\": \"butt\",\r\n        \"msoLineLongDashDot\": \"butt\",\r\n        \"msoLineRoundDot\": \"round\",\r\n        \"msoLineSolid\": \"butt\",\r\n        \"msoLineSquareDot\": \"butt\"\r\n    };\r\n    const typeDic = {\r\n        \"msoLineDash\": msoDashStyle.msoLineDash,\r\n        \"msoLineDashDot\": msoDashStyle.msoLineDashDot,\r\n        \"msoLineDashDotDot\": msoDashStyle.msoLineDashDotDot,\r\n        \"msoLineLongDash\": msoDashStyle.msoLineLongDash,\r\n        \"msoLineLongDashDot\": msoDashStyle.msoLineLongDashDot,\r\n        \"msoLineRoundDot\": msoDashStyle.msoLineRoundDot,\r\n        \"msoLineSquareDot\": msoDashStyle.msoLineSquareDot,\r\n        \"msoLineSolid\": msoDashStyle.msoLineSolid\r\n    };\r\n    function toMSODashStyle(value) {\r\n        if (value in typeDic) {\r\n            return typeDic[value];\r\n        }\r\n        else {\r\n            return msoDashStyle.msoLineSolid;\r\n        }\r\n    }\r\n    msoDashStyle.toMSODashStyle = toMSODashStyle;\r\n    function computeDashArray(type, width) {\r\n        const r = [];\r\n        for (let i = 0; i < msoDashStyle.dashArrayDic[type].length; i++) {\r\n            r.push(msoDashStyle.dashArrayDic[type][i] * width);\r\n        }\r\n        return r.join(\",\");\r\n    }\r\n    function setCpmoutedDashArray(svgLine) {\r\n        const type = svgLine.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.msoDashStyleName);\r\n        if (type == null) {\r\n        }\r\n        else if (toMSODashStyle(type) != null) {\r\n            const width = svgLine.getPropertyStyleNumberValue(\"stroke-width\", 2);\r\n            svgLine.setPropertyStyleValue(\"stroke-dasharray\", computeDashArray(toMSODashStyle(type), width));\r\n            svgLine.setPropertyStyleValue(\"stroke-linecap\", lineCapDic[type]);\r\n        }\r\n    }\r\n    msoDashStyle.setCpmoutedDashArray = setCpmoutedDashArray;\r\n    function getLineType(svgLine) {\r\n        const typeName = svgLine.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.msoDashStyleName);\r\n        if (typeName != null) {\r\n            const type = toMSODashStyle(typeName);\r\n            if (type != null) {\r\n                return type;\r\n            }\r\n        }\r\n        const dashArray = svgLine.getPropertyStyleValue(\"stroke-dasharray\");\r\n        if (dashArray != null) {\r\n            return msoDashStyle.msoLineDash;\r\n        }\r\n        else {\r\n            return msoDashStyle.msoLineSolid;\r\n        }\r\n    }\r\n    msoDashStyle.getLineType = getLineType;\r\n})(msoDashStyle = exports.msoDashStyle || (exports.msoDashStyle = {}));\r\nvar Direction;\r\n(function (Direction) {\r\n    function toDirection(value) {\r\n        if (value == \"up\") {\r\n            return \"up\";\r\n        }\r\n        else if (value == \"left\") {\r\n            return \"left\";\r\n        }\r\n        else if (value == \"right\") {\r\n            return \"right\";\r\n        }\r\n        else {\r\n            return \"down\";\r\n        }\r\n    }\r\n    Direction.toDirection = toDirection;\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nvar ConnectorPosition;\r\n(function (ConnectorPosition) {\r\n    ConnectorPosition.Top = \"top\";\r\n    ConnectorPosition.TopLeft = \"topleft\";\r\n    ConnectorPosition.Left = \"left\";\r\n    ConnectorPosition.BottomLeft = \"bottomleft\";\r\n    ConnectorPosition.Bottom = \"bottom\";\r\n    ConnectorPosition.BottomRight = \"bottomright\";\r\n    ConnectorPosition.Right = \"right\";\r\n    ConnectorPosition.TopRight = \"topright\";\r\n    ConnectorPosition.Auto = \"auto\";\r\n    function ToConnectorPosition(str) {\r\n        if (str == null) {\r\n            return ConnectorPosition.Auto;\r\n        }\r\n        else {\r\n            return str;\r\n        }\r\n    }\r\n    ConnectorPosition.ToConnectorPosition = ToConnectorPosition;\r\n    function ToVBAConnectorPosition(shapeType, str) {\r\n        if (shapeType == \"circle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"topleft\": return 2;\r\n                case \"left\": return 3;\r\n                case \"bottomleft\": return 4;\r\n                case \"bottom\": return 5;\r\n                case \"bottomright\": return 6;\r\n                case \"right\": return 7;\r\n                case \"topright\": return 8;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else if (shapeType == \"rectangle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"left\": return 2;\r\n                case \"bottom\": return 3;\r\n                case \"right\": return 4;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    ConnectorPosition.ToVBAConnectorPosition = ToVBAConnectorPosition;\r\n    function ToVBAConnectorPosition2(shapeType, str) {\r\n        if (shapeType == \"msoShapeOval\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"topleft\": return 2;\r\n                case \"left\": return 3;\r\n                case \"bottomleft\": return 4;\r\n                case \"bottom\": return 5;\r\n                case \"bottomright\": return 6;\r\n                case \"right\": return 7;\r\n                case \"topright\": return 8;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else if (shapeType == \"msoShapeRectangle\") {\r\n            switch (str) {\r\n                case \"top\": return 1;\r\n                case \"left\": return 2;\r\n                case \"bottom\": return 3;\r\n                case \"right\": return 4;\r\n                case \"auto\": return 9;\r\n                default: return 1;\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    ConnectorPosition.ToVBAConnectorPosition2 = ToVBAConnectorPosition2;\r\n})(ConnectorPosition = exports.ConnectorPosition || (exports.ConnectorPosition = {}));\r\nvar VerticalAnchor;\r\n(function (VerticalAnchor) {\r\n    VerticalAnchor.Top = \"top\";\r\n    VerticalAnchor.Middle = \"middle\";\r\n    VerticalAnchor.Bottom = \"bottom\";\r\n    function toVerticalAnchor(value) {\r\n        if (value == \"top\") {\r\n            return \"top\";\r\n        }\r\n        else if (value == \"bottom\") {\r\n            return \"bottom\";\r\n        }\r\n        else {\r\n            return \"middle\";\r\n        }\r\n    }\r\n    VerticalAnchor.toVerticalAnchor = toVerticalAnchor;\r\n})(VerticalAnchor = exports.VerticalAnchor || (exports.VerticalAnchor = {}));\r\nvar HorizontalAnchor;\r\n(function (HorizontalAnchor) {\r\n    HorizontalAnchor.Left = \"left\";\r\n    HorizontalAnchor.Center = \"center\";\r\n    HorizontalAnchor.Right = \"right\";\r\n    function toHorizontalAnchor(value) {\r\n        if (value == \"left\") {\r\n            return \"left\";\r\n        }\r\n        else if (value == \"right\") {\r\n            return \"right\";\r\n        }\r\n        else {\r\n            return \"center\";\r\n        }\r\n    }\r\n    HorizontalAnchor.toHorizontalAnchor = toHorizontalAnchor;\r\n})(HorizontalAnchor = exports.HorizontalAnchor || (exports.HorizontalAnchor = {}));\r\nfunction parsePXString(item) {\r\n    if (item == null) {\r\n        return 0;\r\n    }\r\n    else {\r\n        if (item.length == 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return parseInt(item);\r\n        }\r\n    }\r\n}\r\nexports.parsePXString = parsePXString;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/enums.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/common/vba_functions.ts":
/*!**********************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/vba_functions.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst color_1 = __webpack_require__(/*! ./color */ \"../GraphTableSVG/src/basic/common/color.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ./common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nfunction parseInteger(value) {\r\n    if (value == \"\") {\r\n        return 1;\r\n    }\r\n    else {\r\n        return parseInt(value);\r\n    }\r\n}\r\nexports.parseInteger = parseInteger;\r\nfunction visible(value) {\r\n    if (value == \"hidden\") {\r\n        return 1.0;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nexports.visible = visible;\r\nclass VBATranslateFunctions {\r\n    static grouping80(codes) {\r\n        let r = [];\r\n        const result = [];\r\n        codes.forEach(function (x, i, arr) {\r\n            if (r.length + x.length >= 80) {\r\n                result.push(VBATranslateFunctions.joinLines(r));\r\n                r = [];\r\n            }\r\n            x.forEach((v) => r.push(v));\r\n        });\r\n        if (r.length > 0) {\r\n            result.push(VBATranslateFunctions.joinLines(r));\r\n            r = [];\r\n        }\r\n        return result;\r\n    }\r\n    static splitCode(codes, subArg, callArg, id) {\r\n        const functions = [];\r\n        const p = VBATranslateFunctions.grouping80(codes);\r\n        p.forEach(function (x, i, arr) {\r\n            functions.push(`Call SubFunction${id}_${i}(${callArg})`);\r\n            const begin = `Sub SubFunction${id}_${i}(${subArg})`;\r\n            const end = `End Sub`;\r\n            p[i] = VBATranslateFunctions.joinLines([begin, x, end]);\r\n        });\r\n        return [VBATranslateFunctions.joinLines(functions), VBATranslateFunctions.joinLines(p)];\r\n    }\r\n    static ToFontBold(bold) {\r\n        if (bold == \"bold\") {\r\n            return \"msotrue\";\r\n        }\r\n        else {\r\n            return \"msofalse\";\r\n        }\r\n    }\r\n    static ToVerticalAnchor(value) {\r\n        switch (value) {\r\n            case \"top\": return \"msoAnchorTop\";\r\n            case \"middle\": return \"msoAnchorMiddle\";\r\n            case \"bottom\": return \"msoAnchorBottom\";\r\n            default: return \"msoAnchorTop\";\r\n        }\r\n    }\r\n    static ToHorizontalAnchor(value) {\r\n        switch (value) {\r\n            case \"left\": return \"ppAlignLeft\";\r\n            case \"center\": return \"ppAlignCenter\";\r\n            case \"right\": return \"ppAlignRight\";\r\n            default: return \"ppAlignLeft\";\r\n        }\r\n    }\r\n    static createStringFunction(item) {\r\n        return item.length == 0 ? `\"\"` : `\"` + item + `\"`;\r\n    }\r\n    static createArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += items[i];\r\n            if (i + 1 != items.length) {\r\n                s += `, `;\r\n            }\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static createStringArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += `\"${items[i]}\"`;\r\n            if (i + 1 != items.length) {\r\n                s += `, `;\r\n            }\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static createJagArrayFunction(items) {\r\n        let s = ``;\r\n        for (let i = 0; i < items.length; i++) {\r\n            s += VBATranslateFunctions.createArrayFunction(items[i]);\r\n            if (i + 1 != items.length)\r\n                s += `, `;\r\n        }\r\n        return `Array(${s})`;\r\n    }\r\n    static joinLines(lines) {\r\n        let s = ``;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            s += lines[i];\r\n            if (i + 1 != lines.length)\r\n                s += `\\n`;\r\n        }\r\n        return s;\r\n    }\r\n    static colorToVBA(color) {\r\n        color = color_1.Color.createRGBCodeFromColorName(color);\r\n        if (color.indexOf(\"rgb\") != -1) {\r\n            return color.replace(\"rgb\", \"Array\");\r\n        }\r\n        else {\r\n            return \"Array(0, 0, 0)\";\r\n        }\r\n    }\r\n    static ToVBAFont(font) {\r\n        font = font.replace(/\"/g, \"\");\r\n        font = font.replace(/'/g, \"\");\r\n        return font;\r\n    }\r\n    static TranslateSVGTextElement(sub, item, range) {\r\n        const text = item.textContent == null ? \"\" : item.textContent;\r\n        sub.push([`${range}.text = \"${item.textContent}\"`]);\r\n        if (item.children.length > 0) {\r\n            let pos = 1;\r\n            for (let i = 0; i < item.children.length; i++) {\r\n                const child = item.children.item(i);\r\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\r\n                    const css = getComputedStyle(child);\r\n                    const childColor = color_1.Color.createRGBFromColorName(css.fill == null ? \"black\" : css.fill);\r\n                    const fontName = this.getFont(css);\r\n                    const fontSize = common_functions_1.CommonFunctions.toPX(css.fontSize == null ? \"14pt\" : css.fontSize);\r\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n                    const len = child.textContent.length;\r\n                    let f = child.getAttribute(\"data-script\");\r\n                    if (f == null) {\r\n                        f = \"\";\r\n                    }\r\n                    sub.push([`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\r\n                    pos += len;\r\n                }\r\n            }\r\n        }\r\n        else if (item.textContent != null && item.textContent.length > 0) {\r\n            const css = getComputedStyle(item);\r\n            if (css.fontSize == null)\r\n                throw Error(\"error\");\r\n            if (css.fill == null)\r\n                throw Error(\"error\");\r\n            const color = color_1.Color.createRGBFromColorName(css.fill);\r\n            const fontName = this.getFont(css);\r\n            const fontSize = common_functions_1.CommonFunctions.toPX(css.fontSize);\r\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n            sub.push([`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`]);\r\n        }\r\n    }\r\n    static getFont(css) {\r\n        if (css.fontFamily == null)\r\n            throw Error(\"error\");\r\n        const arr = css.fontFamily.split(\",\");\r\n        if (arr.length > 0) {\r\n            let name = arr[0];\r\n            name = name.replace(/\\\"/g, \"\");\r\n            name = name.replace(/\\'/g, \"\");\r\n            return name;\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    static TranslateSVGTextElement2(item, range) {\r\n        const lines = [];\r\n        const text = item.textContent == null ? \"\" : item.textContent;\r\n        lines.push(`${range}.text = \"${item.textContent}\"`);\r\n        if (item.children.length > 0) {\r\n            let pos = 1;\r\n            for (let i = 0; i < item.children.length; i++) {\r\n                const child = item.children.item(i);\r\n                if (child != null && child.textContent != null && child.textContent.length > 0) {\r\n                    const css = getComputedStyle(child);\r\n                    if (css.fontSize == null)\r\n                        throw Error(\"error\");\r\n                    if (css.fill == null)\r\n                        throw Error(\"error\");\r\n                    const childColor = color_1.Color.createRGBFromColorName(css.fill);\r\n                    const fontName = this.getFont(css);\r\n                    const fontSize = common_functions_1.CommonFunctions.toPX(css.fontSize);\r\n                    const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n                    const len = child.textContent.length;\r\n                    let f = child.getAttribute(\"data-script\");\r\n                    if (f == null) {\r\n                        f = \"\";\r\n                    }\r\n                    lines.push(`Call EditTextRangeSub(${range},${pos}, ${len}, \"${f}\", Array(${childColor.r}, ${childColor.g}, ${childColor.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\r\n                    pos += len;\r\n                }\r\n            }\r\n        }\r\n        else if (item.textContent != null && item.textContent.length > 0) {\r\n            const css = getComputedStyle(item);\r\n            if (css.fontSize == null)\r\n                throw Error(\"error\");\r\n            if (css.fill == null)\r\n                throw Error(\"error\");\r\n            const color = color_1.Color.createRGBFromColorName(css.fill);\r\n            const fontName = this.getFont(css);\r\n            const fontSize = common_functions_1.CommonFunctions.toPX(css.fontSize);\r\n            const fontBold = Number(css.fontWeight) == 400 ? 0 : 1;\r\n            lines.push(`Call EditTextRangeSub(${range},${1}, ${item.textContent.length}, \"\", Array(${color.r}, ${color.g}, ${color.b}), \"${fontName}\", ${fontSize}, ${fontBold} )`);\r\n        }\r\n        return lines;\r\n    }\r\n}\r\nexports.VBATranslateFunctions = VBATranslateFunctions;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/vba_functions.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/common/vline.ts":
/*!**************************************************!*\
  !*** ../GraphTableSVG/src/basic/common/vline.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass VLine {\r\n    constructor(x1, y1, x2, y2) {\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n    }\r\n    get smallPoint() {\r\n        if (this.x1 < this.x2) {\r\n            return [this.x1, this.y1];\r\n        }\r\n        else {\r\n            return [this.x2, this.y2];\r\n        }\r\n    }\r\n    get largePoint() {\r\n        if (this.x1 < this.x2) {\r\n            return [this.x2, this.y2];\r\n        }\r\n        else {\r\n            return [this.x1, this.y1];\r\n        }\r\n    }\r\n    contains(x, y) {\r\n        const lineY = this.getY(x);\r\n        if (lineY == null) {\r\n            return x < this.x1;\r\n        }\r\n        else {\r\n            return y < lineY;\r\n        }\r\n    }\r\n    getY(x) {\r\n        const intercept = this.intercept;\r\n        if (intercept == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.slope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return (this.slope * x) + intercept;\r\n            }\r\n        }\r\n    }\r\n    get slope() {\r\n        const [x1, y1] = this.smallPoint;\r\n        const [x2, y2] = this.largePoint;\r\n        if (x2 - x1 == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return (y2 - y1) / (x2 - x1);\r\n        }\r\n    }\r\n    get intercept() {\r\n        const [x1, y1] = this.smallPoint;\r\n        const [x2, y2] = this.largePoint;\r\n        if (this.slope == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return y1 - x1 * this.slope;\r\n        }\r\n    }\r\n    get inverseSlope() {\r\n        if (this.slope == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.slope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return -1 / this.slope;\r\n            }\r\n        }\r\n    }\r\n    inverseIntercept(x, y) {\r\n        if (this.slope == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (this.inverseSlope == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return y - (this.inverseSlope * x);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.VLine = VLine;\r\nclass Padding {\r\n    constructor(top = 0, left = 0, right = 0, bottom = 0) {\r\n        this.top = top;\r\n        this.left = left;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n    }\r\n}\r\nexports.Padding = Padding;\r\nclass Size {\r\n    constructor(width = 0, height = 0) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n}\r\nexports.Size = Size;\r\nclass Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n    addOffset(x, y) {\r\n        this.x += x;\r\n        this.y += y;\r\n    }\r\n    static merge(rects) {\r\n        if (rects.length > 0) {\r\n            let x1 = rects[0].x;\r\n            let y1 = rects[0].y;\r\n            let x2 = rects[0].right;\r\n            let y2 = rects[0].bottom;\r\n            rects.forEach((v) => {\r\n                if (x1 > v.x)\r\n                    x1 = v.x;\r\n                if (y1 > v.y)\r\n                    y1 = v.y;\r\n                if (x2 < v.right)\r\n                    x2 = v.right;\r\n                if (y2 < v.bottom)\r\n                    y2 = v.bottom;\r\n            });\r\n            const rect = new Rectangle();\r\n            rect.x = x1;\r\n            rect.y = y1;\r\n            rect.width = x2 - x1;\r\n            rect.height = y2 - y1;\r\n            return rect;\r\n        }\r\n        else {\r\n            return new Rectangle(0, 0, 0, 0);\r\n        }\r\n    }\r\n}\r\nexports.Rectangle = Rectangle;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/common/vline.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/css.ts":
/*!*************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/css.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nvar Common;\r\n(function (Common) {\r\n    function createCSS() {\r\n        const r = `\r\n            .${custtome_attributes_1.CustomAttributeNames.cellEmphasisCellClass}{\r\n            fill : yellow !important;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.cellEmphasisBorderClass}{\r\n            stroke : red !important;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellClass}{\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.paddingTop} : 5px;\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.paddingLeft} : 5px;\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.paddingRight} : 5px;\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.paddingBottom} : 5px;\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.VerticalAnchor} : ${enums_1.VerticalAnchor.Middle};\r\n                ${custtome_attributes_1.CustomAttributeNames.Style.HorizontalAnchor} : ${enums_1.HorizontalAnchor.Center};\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextClass}{\r\n                fill : black;\r\n                font-size: 18px;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBackgroungClass}{\r\n                fill : white;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBorderClass}{\r\n                stroke : black;\r\n            }\r\n\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : white;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultPathSurfaceClass}{\r\n                stroke: black;\r\n                stroke-width: 1px;\r\n                fill : transparent;\r\n            }\r\n\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultEdgePathClass}{\r\n                stroke: black;\r\n                fill: none;\r\n                stroke-width: 1px;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextboxPathClass}{\r\n                stroke: black;\r\n                fill: white;\r\n                stroke-width: 1px;\r\n            }\r\n\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultRectButtonSurfaceClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultRectButtonSurfaceClass}[disabled]{\r\n                fill: #aaaaaa; \r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultRectButtonSurfaceClass}:not([disabled]):hover{\r\n                fill:#A4C6FF; \r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultRectButtonSurfaceClass}:not([disabled]):active{\r\n                fill:#8EB8FF; \r\n            }\r\n\r\n            .___column_title_cellaa{\r\n                --default-text-class : table-text;\r\n                --default-background-class : background;    \r\n                --horizontal-anchor: center;\r\n                --vertical-anchor: middle;\r\n                --padding-top: 0px;\r\n                --padding-left: 0px;\r\n                --padding-right: 0px;\r\n                --padding-bottom: 0px;\r\n            }\r\n\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellTextClass} {\r\n                fill : black;\r\n                font-size: 18px;\r\n                font-weight: bold;\r\n            }\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellUndefinedTextClass} {\r\n                fill : pink;\r\n                font-size: 18px;\r\n                font-style: italic;\r\n            }\r\n\r\n            .${custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellBackgroundClass}{\r\n                fill: #8EB8FF; \r\n                stroke: black;\r\n            }\r\n\r\n\r\n            g[data-type=\"g-rect-button\"] > rect {\r\n                stroke-width: 1px;\r\n                transition-duration: 0.2s;\r\n            }\r\n\r\n            g[data-type=\"g-rect-button\"] > rect[disabled]{\r\n                stroke-width: 1px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > rect:not([disabled]):hover {\r\n                stroke-width: 3px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > rect:not([disabled]):active {\r\n                stroke-width: 1px;\r\n            }\r\n            g[data-type=\"g-rect-button\"] > text {\r\n                pointer-events: none;\r\n            }\r\n    \r\n            `;\r\n        return r;\r\n    }\r\n    Common.createCSS = createCSS;\r\n})(Common = exports.Common || (exports.Common = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/css.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/draggable_object.ts":
/*!**************************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/draggable_object.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst svg_1 = __webpack_require__(/*! ./svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nvar DraggableObjectFunctions;\r\n(function (DraggableObjectFunctions) {\r\n    let drag = null;\r\n    function draggable(element, g) {\r\n        element.addEventListener('mousedown', function (e) {\r\n            e.preventDefault();\r\n            const parent = svg_1.SVG.getLeastContainer(g);\r\n            if (parent != null) {\r\n                const rect = svg_1.SVG.getAbsolutePosition(g);\r\n                drag = {\r\n                    offsetX: e.clientX - rect.x,\r\n                    offsetY: e.clientY - rect.y,\r\n                    target: element,\r\n                    g: g,\r\n                    gParentG: parent\r\n                };\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n    DraggableObjectFunctions.draggable = draggable;\r\n    function appendDragFunctionsToDocument() {\r\n        document.onmouseup = function () {\r\n            drag = null;\r\n        };\r\n        document.onmousemove = function (e) {\r\n            if (drag != null) {\r\n                if (drag.target != null && drag.target instanceof SVGElement) {\r\n                    const g = drag.g;\r\n                    const containerRect = svg_1.SVG.getAbsolutePosition(drag.gParentG);\r\n                    const refx = (e.clientX - containerRect.x) - drag.offsetX;\r\n                    const refy = (e.clientY - containerRect.y) - drag.offsetY;\r\n                    g.setX(refx);\r\n                    g.setY(refy);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    DraggableObjectFunctions.appendDragFunctionsToDocument = appendDragFunctionsToDocument;\r\n})(DraggableObjectFunctions = exports.DraggableObjectFunctions || (exports.DraggableObjectFunctions = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/draggable_object.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/gui.ts":
/*!*************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/gui.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nvar GUI;\r\n(function (GUI) {\r\n    function setSVGBoxSize(box, item1, item2) {\r\n        if (item1 instanceof vline_1.Rectangle) {\r\n            if (item2 instanceof vline_1.Padding) {\r\n                const w = item1.right + item2.left + item2.right;\r\n                const h = item1.bottom + item2.top + item2.bottom;\r\n                setSVGBoxSize(box, w, h);\r\n            }\r\n            else {\r\n                throw new Error();\r\n            }\r\n        }\r\n        else {\r\n            if (item2 instanceof vline_1.Padding) {\r\n                throw new Error();\r\n            }\r\n            else {\r\n                const width = `${item1}px`;\r\n                const height = `${item2}px`;\r\n                if (box.style.width != width || box.style.height != height) {\r\n                    box.style.width = width;\r\n                    box.style.height = height;\r\n                    box.setAttribute(\"width\", width);\r\n                    box.setAttribute(\"height\", height);\r\n                    box.setAttribute(`viewBox`, `0 0 ${item1} ${item2}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    GUI.setSVGBoxSize = setSVGBoxSize;\r\n    function getURLParameters() {\r\n        const arg = {};\r\n        const pair = location.search.substring(1).split('&');\r\n        for (let i = 0; pair[i]; i++) {\r\n            const kv = pair[i].split('=');\r\n            arg[kv[0]] = kv[1];\r\n        }\r\n        return arg;\r\n    }\r\n    GUI.getURLParameters = getURLParameters;\r\n    function setURLParametersToHTMLElements() {\r\n        const parameters = getURLParameters();\r\n        Object.keys(parameters).forEach((key) => {\r\n            const val = parameters[key];\r\n            const element = document.getElementById(key);\r\n            if (element != null) {\r\n                if (element instanceof HTMLTextAreaElement) {\r\n                    element.value = val;\r\n                }\r\n            }\r\n        }, parameters);\r\n    }\r\n    GUI.setURLParametersToHTMLElements = setURLParametersToHTMLElements;\r\n    function getInputText(elementID) {\r\n        const textbox = document.getElementById(elementID);\r\n        return textbox.value;\r\n    }\r\n    GUI.getInputText = getInputText;\r\n    function getNonNullElementById(id) {\r\n        const tmp = document.getElementById(id);\r\n        if (tmp == null) {\r\n            throw Error(\"Null Error\");\r\n        }\r\n        else {\r\n            return tmp;\r\n        }\r\n    }\r\n    GUI.getNonNullElementById = getNonNullElementById;\r\n    function getClientRectangle() {\r\n        const x = window.pageXOffset;\r\n        const y = window.pageYOffset;\r\n        const width = window.innerWidth;\r\n        const height = window.innerHeight;\r\n        return new vline_1.Rectangle(x, y, width, height);\r\n    }\r\n    GUI.getClientRectangle = getClientRectangle;\r\n})(GUI = exports.GUI || (exports.GUI = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/gui.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/gui_observer.ts":
/*!**********************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/gui_observer.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst gui_1 = __webpack_require__(/*! ./gui */ \"../GraphTableSVG/src/basic/svghtml/gui.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ./html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst svg_1 = __webpack_require__(/*! ./svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nvar GUIObserver;\r\n(function (GUIObserver) {\r\n    function observeSVGBox(svgBox, sizeFunc, padding = new vline_1.Padding(5, 5, 5, 5)) {\r\n        let _observer;\r\n        let observeFunction = (x) => {\r\n            let b = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const item = x[i];\r\n                if (svgBox != item.target) {\r\n                    b = true;\r\n                }\r\n            }\r\n            if (b)\r\n                gui_1.GUI.setSVGBoxSize(svgBox, sizeFunc(), padding);\r\n        };\r\n        _observer = new MutationObserver(observeFunction);\r\n        const option = {\r\n            subtree: true, attributes: true\r\n        };\r\n        _observer.observe(svgBox, option);\r\n    }\r\n    GUIObserver.observeSVGBox = observeSVGBox;\r\n    let dic = [];\r\n    let createdObserveSVGSVGTimer = false;\r\n    function resizeSVGSVG(svgBox, padding) {\r\n        const rect = svg_1.SVG.getRegion2(svgBox);\r\n        if (rect.width == 0)\r\n            rect.width = 1;\r\n        if (rect.height == 0)\r\n            rect.height = 1;\r\n        gui_1.GUI.setSVGBoxSize(svgBox, rect, padding);\r\n    }\r\n    function observeSVGSVG(svgBox, padding = new vline_1.Padding(0, 0, 0, 0)) {\r\n        if (isObserved(svgBox)) {\r\n            return;\r\n        }\r\n        let _observer;\r\n        let observeFunction = (x) => {\r\n            const gShrink = svgBox.gtGetAttributeBooleanWithUndefined(\"g-shrink\");\r\n            let b = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const item = x[i];\r\n                if (svgBox != item.target) {\r\n                    b = true;\r\n                }\r\n            }\r\n            if (gShrink === true && b) {\r\n                resizeSVGSVG(svgBox, padding);\r\n            }\r\n        };\r\n        _observer = new MutationObserver(observeFunction);\r\n        const option = {\r\n            subtree: true, attributes: true\r\n        };\r\n        _observer.observe(svgBox, option);\r\n        dic.push({ svgsvg: svgBox, visible: false, padding: padding });\r\n        if (!createdObserveSVGSVGTimer) {\r\n            createdObserveSVGSVGTimer = true;\r\n            setTimeout(observeSVGSVGTimer, timerInterval);\r\n        }\r\n    }\r\n    GUIObserver.observeSVGSVG = observeSVGSVG;\r\n    function isObserved(svgBox) {\r\n        for (let i = 0; i < dic.length; i++) {\r\n            if (dic[i].svgsvg === svgBox) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    GUIObserver.isObserved = isObserved;\r\n    function observeSVGSVGTimer() {\r\n        dic.forEach((v, i) => {\r\n            const nowVisible = !svg_1.SVG.isSVGSVGHidden(v.svgsvg);\r\n            if (v.visible) {\r\n                if (!nowVisible) {\r\n                    v.visible = false;\r\n                }\r\n            }\r\n            else {\r\n                if (nowVisible) {\r\n                    dispatchResizeEvent(v.svgsvg);\r\n                    const b = v.svgsvg.gtGetAttributeBooleanWithUndefined(\"g-shrink\");\r\n                    if (b !== undefined && b === true)\r\n                        resizeSVGSVG(v.svgsvg, v.padding);\r\n                    v.visible = true;\r\n                }\r\n            }\r\n        });\r\n        setTimeout(observeSVGSVGTimer, timerInterval);\r\n    }\r\n    function dispatchResizeEvent(e) {\r\n        const children = html_functions_1.HTMLFunctions.getChildren(e);\r\n        children.forEach((v) => {\r\n            dispatchResizeEvent(v);\r\n        });\r\n        if (e instanceof SVGGElement) {\r\n            var event = document.createEvent(\"HTMLEvents\");\r\n            event.initEvent(custtome_attributes_1.CustomAttributeNames.resizeName, false, true);\r\n            e.dispatchEvent(event);\r\n        }\r\n    }\r\n    let changeElementDic = [];\r\n    let timerInterval = 100;\r\n    function observeChangeElement() {\r\n        var result = document.evaluate(\"//iframe[@g-src]\", document, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);\r\n        for (var i = 0; i < result.snapshotLength; i++) {\r\n            var node = result.snapshotItem(i);\r\n            changeElementDic.push(node);\r\n        }\r\n        if (changeElementDic.length > 0)\r\n            setTimeout(observeChangeElementTimer, timerInterval);\r\n    }\r\n    GUIObserver.observeChangeElement = observeChangeElement;\r\n    function observeChangeElementTimer() {\r\n        for (let i = 0; i < changeElementDic.length; i++) {\r\n            const element = changeElementDic[i];\r\n            if (html_functions_1.HTMLFunctions.isInsideElement(element)) {\r\n                const url = element.getAttribute(\"g-src\");\r\n                element.setAttribute(\"src\", url);\r\n                element.removeAttribute(\"g-src\");\r\n                changeElementDic.splice(i, 1);\r\n                i = -1;\r\n            }\r\n        }\r\n        if (changeElementDic.length > 0)\r\n            setTimeout(observeChangeElementTimer, timerInterval);\r\n    }\r\n})(GUIObserver = exports.GUIObserver || (exports.GUIObserver = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/gui_observer.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/html_functions.ts":
/*!************************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/html_functions.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst gui_1 = __webpack_require__(/*! ./gui */ \"../GraphTableSVG/src/basic/svghtml/gui.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nvar HTMLFunctions;\r\n(function (HTMLFunctions) {\r\n    let NodeOrder;\r\n    (function (NodeOrder) {\r\n        NodeOrder[NodeOrder[\"Preorder\"] = 0] = \"Preorder\";\r\n        NodeOrder[NodeOrder[\"Postorder\"] = 1] = \"Postorder\";\r\n    })(NodeOrder = HTMLFunctions.NodeOrder || (HTMLFunctions.NodeOrder = {}));\r\n    function getTNodes(e) {\r\n        const tNodes = HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement) == \"t\");\r\n        if (tNodes.length > 0) {\r\n            tNodes.forEach((v, i) => {\r\n                v.removeAttribute(custtome_attributes_1.CustomAttributeNames.customElement);\r\n                if (i > 0 && !v.hasAttribute(\"newline\"))\r\n                    v.setAttribute(\"newline\", \"true\");\r\n            });\r\n            return tNodes;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    HTMLFunctions.getTNodes = getTNodes;\r\n    function getAncestorAttribute(e, attr) {\r\n        if (e.hasAttribute(attr)) {\r\n            return e.getAttribute(attr);\r\n        }\r\n        else {\r\n            if (e.parentElement == null) {\r\n                return null;\r\n            }\r\n            else {\r\n                return getAncestorAttribute(e.parentElement, attr);\r\n            }\r\n        }\r\n    }\r\n    HTMLFunctions.getAncestorAttribute = getAncestorAttribute;\r\n    function isShow(e) {\r\n        const p = e.getBoundingClientRect();\r\n        return !(p.top == 0 && p.left == 0 && p.width == 0 && p.height == 0);\r\n    }\r\n    HTMLFunctions.isShow = isShow;\r\n    function getDescendantsByPreorder(e) {\r\n        const r = [];\r\n        r.push(e);\r\n        for (let i = 0; i < e.children.length; i++) {\r\n            const p = e.children.item(i);\r\n            if (p instanceof Element) {\r\n                getDescendantsByPreorder(p).forEach((v) => r.push(v));\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    HTMLFunctions.getDescendantsByPreorder = getDescendantsByPreorder;\r\n    function getDescendantsByPostorder(e) {\r\n        const r = [];\r\n        for (let i = 0; i < e.children.length; i++) {\r\n            const p = e.children.item(i);\r\n            if (p instanceof Element) {\r\n                getDescendantsByPostorder(p).forEach((v) => r.push(v));\r\n            }\r\n        }\r\n        r.push(e);\r\n        return r;\r\n    }\r\n    HTMLFunctions.getDescendantsByPostorder = getDescendantsByPostorder;\r\n    function getDescendants(e, order = NodeOrder.Preorder) {\r\n        if (order == NodeOrder.Preorder) {\r\n            return getDescendantsByPreorder(e);\r\n        }\r\n        else {\r\n            return getDescendantsByPostorder(e);\r\n        }\r\n    }\r\n    HTMLFunctions.getDescendants = getDescendants;\r\n    function getChildren(e) {\r\n        const r = [];\r\n        for (let i = 0; i < e.children.length; i++) {\r\n            const p = e.children.item(i);\r\n            if (p instanceof Element) {\r\n                r.push(p);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    HTMLFunctions.getChildren = getChildren;\r\n    function getChildByNodeName(e, name) {\r\n        const p = getChildren(e).filter((v) => v.nodeName == name);\r\n        if (p.length > 0) {\r\n            return p[0];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    HTMLFunctions.getChildByNodeName = getChildByNodeName;\r\n    function isInsideElement(element) {\r\n        const win = gui_1.GUI.getClientRectangle();\r\n        const ele = element.getBoundingClientRect();\r\n        const b1 = ele.left <= win.width && ele.top <= win.height;\r\n        const b2 = ele.right <= win.width && ele.top <= win.height;\r\n        const b3 = ele.left <= win.width && ele.bottom <= win.height;\r\n        const b4 = ele.right <= win.width && ele.bottom <= win.height;\r\n        return b1 || b2 || b3 || b4;\r\n    }\r\n    HTMLFunctions.isInsideElement = isInsideElement;\r\n})(HTMLFunctions = exports.HTMLFunctions || (exports.HTMLFunctions = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/html_functions.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/interface.ts":
/*!*******************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/interface.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_functions_1 = __webpack_require__(/*! ../common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ./svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nSVGTextPathElement.prototype.setTextContent = function (text, isLatexMode = false) {\r\n    svg_textbox_1.SVGTextBox.setTextToTextPath(this, text, isLatexMode);\r\n};\r\nCSSStyleDeclaration.prototype.tryGetPropertyValue = function (name) {\r\n    const p = this;\r\n    const r = p.getPropertyValue(name).trim();\r\n    if (r.length == 0) {\r\n        return null;\r\n    }\r\n    else {\r\n        return r;\r\n    }\r\n};\r\nSVGLineElement.prototype.getEmphasis = function () {\r\n    const p = this;\r\n    const emp = p.getAttribute(\"class\");\r\n    if (emp != null) {\r\n        return emp == custtome_attributes_1.CustomAttributeNames.cellEmphasisBorderClass;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n};\r\nSVGLineElement.prototype.setEmphasis = function (value) {\r\n    common_functions_1.CommonFunctions.setGraphTableCSS();\r\n    const p = this;\r\n    if (p.getEmphasis() && !value) {\r\n        const tmp = p.getAttribute(custtome_attributes_1.CustomAttributeNames.cellTemporaryBorderClass);\r\n        if (tmp != null) {\r\n            p.setAttribute(\"class\", tmp);\r\n            p.removeAttribute(custtome_attributes_1.CustomAttributeNames.cellTemporaryBorderClass);\r\n        }\r\n        else {\r\n            p.removeAttribute(\"class\");\r\n            p.removeAttribute(custtome_attributes_1.CustomAttributeNames.cellTemporaryBorderClass);\r\n        }\r\n    }\r\n    else if (!p.getEmphasis() && value) {\r\n        const lineClass = p.getAttribute(\"class\");\r\n        p.setAttribute(\"class\", custtome_attributes_1.CustomAttributeNames.cellTemporaryBorderClass);\r\n        if (lineClass != null) {\r\n            p.setAttribute(custtome_attributes_1.CustomAttributeNames.cellTemporaryBorderClass, lineClass);\r\n        }\r\n    }\r\n};\r\nSVGPathElement.prototype.setPathLocations = function (points) {\r\n    const p = this;\r\n    let s = \"\";\r\n    for (let i = 0; i < points.length; i++) {\r\n        s += `${i == 0 ? \"M\" : \"L\"} ${points[i][0]} ${points[i][1]} `;\r\n    }\r\n    p.setAttribute(\"d\", s);\r\n};\r\nSVGPathElement.prototype.getPathLocations = function () {\r\n    const p = this;\r\n    const info = p.getAttribute(\"d\");\r\n    if (info == null)\r\n        return [];\r\n    const r = [];\r\n    let pos = [0, 0];\r\n    let pathType = \"\";\r\n    info.split(\" \").forEach((v, i) => {\r\n        if (i % 3 == 0) {\r\n            pathType = v;\r\n        }\r\n        else if (i % 3 == 1) {\r\n            pos[0] = parseInt(v);\r\n        }\r\n        else {\r\n            pos[1] = parseInt(v);\r\n            r.push(pos);\r\n            pos = [0, 0];\r\n        }\r\n    });\r\n    return r;\r\n};\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/interface.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/svg.ts":
/*!*************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/svg.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ./html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nvar SVG;\r\n(function (SVG) {\r\n    SVG.idCounter = 0;\r\n    function createLine(x, y, x2, y2, className) {\r\n        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');\r\n        line1.x1.baseVal.value = x;\r\n        line1.x2.baseVal.value = x2;\r\n        line1.y1.baseVal.value = y;\r\n        line1.y2.baseVal.value = y2;\r\n        line1.setAttribute(\"class\", className);\r\n        return line1;\r\n    }\r\n    SVG.createLine = createLine;\r\n    function createText(className) {\r\n        const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n        _svgText.setAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName, (SVG.idCounter++).toString());\r\n        _svgText.setAttribute(\"class\", className);\r\n        return _svgText;\r\n    }\r\n    SVG.createText = createText;\r\n    function createRectangle(parent, className = null) {\r\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n        parent.appendChild(rect);\r\n        rect.width.baseVal.value = 30;\r\n        rect.height.baseVal.value = 30;\r\n        if (className == null) {\r\n            rect.style.fill = \"white\";\r\n            rect.style.stroke = \"black\";\r\n            rect.style.strokeWidth = \"1pt\";\r\n        }\r\n        else {\r\n            rect.setAttribute(\"class\", className);\r\n            const width = rect.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultWidth, null);\r\n            if (width != null) {\r\n                rect.width.baseVal.value = width;\r\n            }\r\n            const height = rect.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultHeight, null);\r\n            if (height != null) {\r\n                rect.height.baseVal.value = height;\r\n            }\r\n        }\r\n        return rect;\r\n    }\r\n    SVG.createRectangle = createRectangle;\r\n    function createCellRectangle(parent, className = null) {\r\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n        parent.appendChild(rect);\r\n        if (className != null) {\r\n            rect.setAttribute(\"class\", className);\r\n        }\r\n        return rect;\r\n    }\r\n    SVG.createCellRectangle = createCellRectangle;\r\n    function createGroup(parent) {\r\n        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        g.setAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName, (SVG.idCounter++).toString());\r\n        if (parent != null)\r\n            parent.appendChild(g);\r\n        return g;\r\n    }\r\n    SVG.createGroup = createGroup;\r\n    function resetStyle(style) {\r\n        style.stroke = null;\r\n        style.strokeWidth = null;\r\n        style.fill = null;\r\n        style.fontSize = null;\r\n        style.fontWeight = null;\r\n        style.fontFamily = null;\r\n    }\r\n    SVG.resetStyle = resetStyle;\r\n    function createCircle(parent, className = null) {\r\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\r\n        parent.appendChild(circle);\r\n        circle.r.baseVal.value = custtome_attributes_1.CustomAttributeNames.defaultCircleRadius;\r\n        if (className == null) {\r\n            circle.style.stroke = \"black\";\r\n            circle.style.strokeWidth = \"1pt\";\r\n            circle.style.fill = \"white\";\r\n        }\r\n        else {\r\n            circle.setAttribute(\"class\", className);\r\n            const radius = circle.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultRadius, null);\r\n            if (radius != null) {\r\n                circle.r.baseVal.value = radius;\r\n            }\r\n        }\r\n        circle.cx.baseVal.value = 0;\r\n        circle.cy.baseVal.value = 0;\r\n        return circle;\r\n    }\r\n    SVG.createCircle = createCircle;\r\n    function createMarker(option = {}) {\r\n        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');\r\n        const poly = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n        poly.setAttribute(\"d\", \"M 0 0 L 10 5 L 0 10 z\");\r\n        if (option.color != undefined) {\r\n            poly.setPropertyStyleValue(\"stroke\", option.color);\r\n            marker.setPropertyStyleValue(\"fill\", option.color);\r\n        }\r\n        else {\r\n            poly.setPropertyStyleValue(\"stroke\", \"black\");\r\n            marker.setPropertyStyleValue(\"fill\", \"black\");\r\n        }\r\n        poly.setPropertyStyleValue(\"stroke-width\", \"1px\");\r\n        marker.setAttribute(\"markerUnits\", \"userSpaceOnUse\");\r\n        marker.setAttribute(\"markerHeight\", \"15\");\r\n        marker.setAttribute(\"markerWidth\", \"15\");\r\n        marker.setAttribute(\"refX\", \"10\");\r\n        marker.setAttribute(\"refY\", \"5\");\r\n        marker.setAttribute(\"preserveAspectRatio\", \"none\");\r\n        marker.setAttribute(\"orient\", \"auto\");\r\n        marker.setAttribute(\"viewBox\", \"0 0 10 10\");\r\n        marker.appendChild(poly);\r\n        if (option.className != null) {\r\n        }\r\n        else {\r\n        }\r\n        return [marker, poly];\r\n    }\r\n    SVG.createMarker = createMarker;\r\n    function createTextPath(className = null) {\r\n        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n        ;\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\r\n        text.appendChild(path);\r\n        if (className == null) {\r\n            path.style.fill = \"black\";\r\n            path.style.fontSize = \"14px\";\r\n            path.style.fontWeight = \"bold\";\r\n            path.style.fontFamily = 'Times New Roman';\r\n        }\r\n        else {\r\n            path.setAttribute(\"class\", className);\r\n        }\r\n        return [text, path];\r\n    }\r\n    SVG.createTextPath = createTextPath;\r\n    function createTextPath2(className) {\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'textPath');\r\n        path.setAttribute(\"class\", className);\r\n        return path;\r\n    }\r\n    SVG.createTextPath2 = createTextPath2;\r\n    function setClass(svg, className = null) {\r\n        if (className == null) {\r\n            svg.removeAttribute(\"class\");\r\n        }\r\n        else {\r\n            resetStyle(svg.style);\r\n            svg.setAttribute(\"class\", className);\r\n        }\r\n    }\r\n    SVG.setClass = setClass;\r\n    function getStyleSheet(name) {\r\n        const name2 = \".\" + name;\r\n        for (let i = 0; i < document.styleSheets.length; i++) {\r\n            const sheet = document.styleSheets.item(i);\r\n            const rules = sheet.cssRules || sheet.rules;\r\n            if (rules != null) {\r\n                for (let j = 0; j < rules.length; j++) {\r\n                    const rule = rules.item(j);\r\n                    if (rule.selectorText == name2) {\r\n                        return rule.style;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    SVG.getStyleSheet = getStyleSheet;\r\n    function getRegion2(e) {\r\n        if (e instanceof SVGSVGElement) {\r\n            const elements = html_functions_1.HTMLFunctions.getChildren(e).filter((v) => v instanceof SVGElement);\r\n            const rectangles = elements.map((v) => getRegion2(v));\r\n            const parentRect = e.getBoundingClientRect();\r\n            const rect = vline_1.Rectangle.merge(rectangles);\r\n            let r = new vline_1.Rectangle();\r\n            r.x = 0;\r\n            r.y = 0;\r\n            r.width = rect.width + (rect.x - parentRect.left);\r\n            r.height = rect.height + (rect.y - parentRect.top);\r\n            return r;\r\n        }\r\n        else if (e instanceof SVGGElement) {\r\n            const rect = e.getBoundingClientRect();\r\n            let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\r\n            return r;\r\n        }\r\n        else {\r\n            const rect = e.getBoundingClientRect();\r\n            let r = new vline_1.Rectangle(rect.left, rect.top, rect.width, rect.height);\r\n            return r;\r\n        }\r\n    }\r\n    SVG.getRegion2 = getRegion2;\r\n    let ura = null;\r\n    function getSVGSVG(e) {\r\n        if (e instanceof SVGSVGElement) {\r\n            return e;\r\n        }\r\n        else {\r\n            const parent = e.parentElement;\r\n            if (parent instanceof SVGElement) {\r\n                return getSVGSVG(parent);\r\n            }\r\n            else {\r\n                throw Error(\"svgsvg\");\r\n            }\r\n        }\r\n    }\r\n    SVG.getSVGSVG = getSVGSVG;\r\n    function getLeastContainer(e) {\r\n        const parent = e.parentElement;\r\n        if (parent instanceof SVGSVGElement || parent instanceof SVGGElement) {\r\n            return parent;\r\n        }\r\n        else if (parent == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (parent instanceof SVGElement) {\r\n                return getLeastContainer(parent);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    SVG.getLeastContainer = getLeastContainer;\r\n    function getAbsolutePosition(g) {\r\n        if (g instanceof SVGSVGElement) {\r\n            const rect = g.getBoundingClientRect();\r\n            return { x: rect.left, y: rect.top };\r\n        }\r\n        else {\r\n            const parent = getLeastContainer(g);\r\n            if (parent instanceof SVGSVGElement) {\r\n                const rect = parent.getBoundingClientRect();\r\n                const x = rect.left + g.getX();\r\n                const y = rect.top + g.getY();\r\n                return { x: x, y: y };\r\n            }\r\n            else if (parent instanceof SVGGElement) {\r\n                const rect = getAbsolutePosition(parent);\r\n                const x = rect.x + g.getX();\r\n                const y = rect.y + g.getY();\r\n                return { x: x, y: y };\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    SVG.getAbsolutePosition = getAbsolutePosition;\r\n    function isSVGSVGHidden(e) {\r\n        const svgsvg = getSVGSVG(e);\r\n        return !html_functions_1.HTMLFunctions.isShow(svgsvg);\r\n    }\r\n    SVG.isSVGSVGHidden = isSVGSVGHidden;\r\n    function isSVGHidden(e) {\r\n        if (e instanceof SVGSVGElement) {\r\n            return false;\r\n        }\r\n        else {\r\n            const p = getComputedStyle(e);\r\n            const disp = p.display;\r\n            const vis = p.visibility;\r\n            if (disp == \"none\" || vis == \"hidden\") {\r\n                return true;\r\n            }\r\n            else {\r\n                const parent = e.parentElement;\r\n                if (parent instanceof SVGElement) {\r\n                    return isSVGHidden(parent);\r\n                }\r\n                else {\r\n                    throw Error(\"svg\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    SVG.isSVGHidden = isSVGHidden;\r\n})(SVG = exports.SVG || (exports.SVG = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/svg.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/svg_g.ts":
/*!***************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/svg_g.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nSVGGElement.prototype.getX = function () {\r\n    const p = this;\r\n    if (p.transform.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    return p.transform.baseVal.getItem(0).matrix.e;\r\n};\r\nSVGGElement.prototype.setX = function (value) {\r\n    const p = this;\r\n    if (p.transform.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    const a = this.transform.baseVal.getItem(0).matrix.a;\r\n    const b = this.transform.baseVal.getItem(0).matrix.b;\r\n    const c = this.transform.baseVal.getItem(0).matrix.c;\r\n    const d = this.transform.baseVal.getItem(0).matrix.d;\r\n    const e = value;\r\n    const f = this.transform.baseVal.getItem(0).matrix.f;\r\n    p.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\r\n};\r\nSVGGElement.prototype.getY = function () {\r\n    const p = this;\r\n    if (p.transform.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    return this.transform.baseVal.getItem(0).matrix.f;\r\n};\r\nSVGGElement.prototype.setY = function (value) {\r\n    const p = this;\r\n    if (p.transform.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('transform', \"matrix(1 0 0 1 0 0)\");\r\n    }\r\n    const a = this.transform.baseVal.getItem(0).matrix.a;\r\n    const b = this.transform.baseVal.getItem(0).matrix.b;\r\n    const c = this.transform.baseVal.getItem(0).matrix.c;\r\n    const d = this.transform.baseVal.getItem(0).matrix.d;\r\n    const e = this.transform.baseVal.getItem(0).matrix.e;\r\n    const f = value;\r\n    p.setAttribute('transform', `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\r\n};\r\nSVGElement.prototype.getPaddingTop = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.paddingTop, 5);\r\n};\r\nSVGElement.prototype.getPaddingLeft = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.paddingLeft, 5);\r\n};\r\nSVGElement.prototype.getPaddingRight = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.paddingRight, 5);\r\n};\r\nSVGElement.prototype.getPaddingBottom = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.paddingBottom, 5);\r\n};\r\nSVGElement.prototype.setPaddingLeft = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.paddingLeft, value.toString());\r\n};\r\nSVGElement.prototype.setPaddingTop = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.paddingTop, value.toString());\r\n};\r\nSVGElement.prototype.setPaddingRight = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.paddingRight, value.toString());\r\n};\r\nSVGElement.prototype.setPaddingBottom = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.paddingBottom, value.toString());\r\n};\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/svg_g.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/svg_interface.ts":
/*!***********************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/svg_interface.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_functions_1 = __webpack_require__(/*! ../common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nElement.prototype.hasStyleAttribute = function (name) {\r\n    const p = this.getPropertyStyleValue(name);\r\n    return p !== null;\r\n};\r\nElement.prototype.gtGetAttribute = function (name, defaultValue = null) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n};\r\nElement.prototype.gtGetAttributes = function () {\r\n    const p = this;\r\n    const r = [];\r\n    for (let i = 0; i < p.attributes.length; i++) {\r\n        const item = p.attributes.item(i);\r\n        if (item != null) {\r\n            r.push({ name: item.name, value: item.value });\r\n        }\r\n    }\r\n    return r;\r\n};\r\nElement.prototype.getActiveStyle = function () {\r\n    const p = this;\r\n    const r = p.getAttribute(\"class\");\r\n    if (r == null) {\r\n        return p.style;\r\n    }\r\n    else {\r\n        return getComputedStyle(p);\r\n    }\r\n};\r\nElement.prototype.gtGetAttributeNumber = function (name, defaultValue = null) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n};\r\nElement.prototype.gtGetAttributeNumberWithUndefined = function (name) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n};\r\nElement.prototype.gtGetAttributeStringWithUndefined = function (name) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n};\r\nElement.prototype.gtGetAttributeBooleanWithUndefined = function (name) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return value == \"true\";\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n};\r\nElement.prototype.gtGetStyleBooleanWithUndefined = function (name) {\r\n    const item = this;\r\n    const value = item.getPropertyStyleValue(name);\r\n    if (value != null) {\r\n        return value == \"true\";\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n};\r\nElement.prototype.gtGetAttributeNumberWithoutNull = function (name, defaultValue = 0) {\r\n    const item = this;\r\n    const value = item.getAttribute(name);\r\n    if (value != null) {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n};\r\nElement.prototype.getPropertyStyleValueWithDefault = function (name, defaultValue) {\r\n    const item = this;\r\n    const p = item.getPropertyStyleValue(name);\r\n    if (p == null) {\r\n        return defaultValue;\r\n    }\r\n    else {\r\n        return p;\r\n    }\r\n};\r\nElement.prototype.getPropertyStyleValue = function (name) {\r\n    const item = this;\r\n    const p = item.style.getPropertyValue(name).trim();\r\n    if (p.length == 0) {\r\n        const r = item.getAttribute(\"class\");\r\n        if (r == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            const css = getComputedStyle(item);\r\n            const p2 = css.getPropertyValue(name).trim();\r\n            if (p2.length == 0) {\r\n                return null;\r\n            }\r\n            else {\r\n                return p2;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return p;\r\n    }\r\n};\r\nElement.prototype.getPropertyStyleNumberValue = function (name, defaultValue = null) {\r\n    const item = this;\r\n    const p = item.getPropertyStyleValue(name);\r\n    if (p != null) {\r\n        return common_functions_1.CommonFunctions.toPX(p);\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n};\r\nElement.prototype.setPropertyStyleValue = function (name, value) {\r\n    const item = this;\r\n    item.style.setProperty(name, value);\r\n};\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/svg_interface.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/svg_text.ts":
/*!******************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/svg_text.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ./svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nSVGTextElement.prototype.gtSetXY = function (rect, vAnchor, hAnchor, isAutoSizeShapeToFitText) {\r\n    const text = this;\r\n    let x = rect.x;\r\n    let y = rect.y;\r\n    text.setAttribute('x', x.toString());\r\n    text.setAttribute('y', y.toString());\r\n    const b2 = svg_textbox_1.SVGTextBox.getSize(text, true);\r\n    const dy = b2.y - y;\r\n    const dx = b2.x - x;\r\n    y -= dy;\r\n    x -= dx;\r\n    if (vAnchor == enums_1.VerticalAnchor.Middle) {\r\n        y += (rect.height - b2.height) / 2;\r\n    }\r\n    else if (vAnchor == enums_1.VerticalAnchor.Bottom) {\r\n        y += rect.height - b2.height;\r\n    }\r\n    if (hAnchor == enums_1.HorizontalAnchor.Center) {\r\n        x += (rect.width - b2.width) / 2;\r\n    }\r\n    else if (hAnchor == enums_1.HorizontalAnchor.Right) {\r\n        x += rect.width - b2.width;\r\n    }\r\n    text.setAttribute('y', y.toString());\r\n    text.setAttribute('x', x.toString());\r\n};\r\nSVGTextElement.prototype.getMarginLeft = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.marginLeft, 5);\r\n};\r\nSVGTextElement.prototype.setMarginLeft = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.marginLeft, value.toString());\r\n};\r\nSVGTextElement.prototype.getMarginTop = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.marginTop, 5);\r\n};\r\nSVGTextElement.prototype.setMarginTop = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.marginTop, value.toString());\r\n};\r\nSVGTextElement.prototype.getMarginRight = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.marginRight, 5);\r\n};\r\nSVGTextElement.prototype.setMarginRight = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.marginRight, value.toString());\r\n};\r\nSVGTextElement.prototype.getMarginBottom = function () {\r\n    const p = this;\r\n    return p.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.marginBottom, 5);\r\n};\r\nSVGTextElement.prototype.setMarginBottom = function (value) {\r\n    const p = this;\r\n    p.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.marginBottom, value.toString());\r\n};\r\nSVGTextElement.prototype.setTextContent = function (text, isLatexMode = false) {\r\n    svg_textbox_1.SVGTextBox.setTextToSVGText(this, text, isLatexMode);\r\n};\r\nSVGTextElement.prototype.getX = function () {\r\n    const p = this;\r\n    if (p.x.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('x', \"0\");\r\n    }\r\n    return p.x.baseVal.getItem(0).value;\r\n};\r\nSVGTextElement.prototype.setX = function (value) {\r\n    const p = this;\r\n    if (p.x.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('x', \"0\");\r\n    }\r\n    p.x.baseVal.getItem(0).value = value;\r\n};\r\nSVGTextElement.prototype.getY = function () {\r\n    const p = this;\r\n    if (p.y.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('y', \"0\");\r\n    }\r\n    return p.y.baseVal.getItem(0).value;\r\n};\r\nSVGTextElement.prototype.setY = function (value) {\r\n    const p = this;\r\n    if (p.y.baseVal.numberOfItems == 0) {\r\n        p.setAttribute('y', \"0\");\r\n    }\r\n    p.y.baseVal.getItem(0).value = value;\r\n};\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/svg_text.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/basic/svghtml/svg_textbox.ts":
/*!*********************************************************!*\
  !*** ../GraphTableSVG/src/basic/svghtml/svg_textbox.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ../common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ./html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\n__webpack_require__(/*! ./svg_interface */ \"../GraphTableSVG/src/basic/svghtml/svg_interface.ts\");\r\nvar SVGTextBox;\r\n(function (SVGTextBox) {\r\n    function createTextSpans(text, className = null, fontsize = 12, dxOfFirstElement = null, dyOfFirstElement = null) {\r\n        let r = [];\r\n        text += \"_\";\r\n        let isFst = true;\r\n        let mode = \"\";\r\n        let tmp = \"\";\r\n        const char_dy = (1 * fontsize) / 3;\r\n        let lastMode = \"none\";\r\n        const smallFontSize = (2 * fontsize) / 3;\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text[i];\r\n            if (c == \"_\" || c == \"{\" || c == \"^\" || c == \"}\") {\r\n                mode += c;\r\n                if (mode == \"_{}\") {\r\n                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                    tspan.textContent = tmp;\r\n                    tspan.setAttribute(\"dy\", `${char_dy}`);\r\n                    tspan.setAttribute(\"data-script\", \"subscript\");\r\n                    tspan.style.fontSize = `${smallFontSize}pt`;\r\n                    r.push(tspan);\r\n                    lastMode = \"down\";\r\n                    mode = \"\";\r\n                    tmp = \"\";\r\n                }\r\n                else if (mode == \"^{}\") {\r\n                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                    tspan.textContent = tmp;\r\n                    tspan.setAttribute(\"dy\", `-${char_dy}`);\r\n                    tspan.style.fontSize = `${smallFontSize}pt`;\r\n                    tspan.setAttribute(\"data-script\", \"superscript\");\r\n                    r.push(tspan);\r\n                    lastMode = \"up\";\r\n                    mode = \"\";\r\n                    tmp = \"\";\r\n                }\r\n                else if (mode == \"_\" || mode == \"^\") {\r\n                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n                    tspan.textContent = tmp;\r\n                    const normaldy = lastMode == \"up\" ? char_dy : lastMode == \"down\" ? -char_dy : 0;\r\n                    if (isFst) {\r\n                        if (dxOfFirstElement != null)\r\n                            tspan.setAttribute(\"dx\", `${dxOfFirstElement}`);\r\n                        if (dyOfFirstElement != null)\r\n                            tspan.setAttribute(\"dy\", `${dyOfFirstElement}`);\r\n                    }\r\n                    else {\r\n                        tspan.setAttribute(\"dy\", `${normaldy}`);\r\n                    }\r\n                    r.push(tspan);\r\n                    lastMode = \"none\";\r\n                    tmp = \"\";\r\n                    isFst = false;\r\n                }\r\n            }\r\n            else {\r\n                tmp += c;\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    function setTextToSVGText(svgText, text, isLatexMode) {\r\n        svgText.textContent = \"\";\r\n        const fontSize = svgText.getPropertyStyleValueWithDefault(\"font-size\", \"12\");\r\n        const fs = parseInt(fontSize);\r\n        let dx = 0;\r\n        text.split(\"\\n\").forEach((lineText) => {\r\n            let dy = fs;\r\n            let width = 0;\r\n            if (isLatexMode) {\r\n                createTextSpans(lineText, null, fs, dx, dy).forEach((v) => {\r\n                    svgText.appendChild(v);\r\n                    const tLen = v.getComputedTextLength();\r\n                    dx = 0;\r\n                    dy = 0;\r\n                    width += tLen;\r\n                });\r\n                dy += fs;\r\n            }\r\n            else {\r\n                svgText.appendChild(createSingleTextSpan(lineText, null));\r\n            }\r\n            dx = -width;\r\n        });\r\n    }\r\n    SVGTextBox.setTextToSVGText = setTextToSVGText;\r\n    function setTextToTextPath(path, text, isLatexMode) {\r\n        path.textContent = \"\";\r\n        const fontSize = path.getPropertyStyleValueWithDefault(\"font-size\", \"12\");\r\n        if (isLatexMode) {\r\n            createTextSpans(text, null, parseInt(fontSize)).forEach((v) => path.appendChild(v));\r\n        }\r\n        else {\r\n            path.appendChild(createSingleTextSpan(text, null));\r\n        }\r\n    }\r\n    SVGTextBox.setTextToTextPath = setTextToTextPath;\r\n    function createSingleTextSpan(text, className = null) {\r\n        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n        tspan.textContent = text;\r\n        if (className != null) {\r\n            tspan.setAttribute(\"class\", className);\r\n        }\r\n        return tspan;\r\n    }\r\n    function copy(e, target) {\r\n        for (let i = 0; i < e.attributes.length; i++) {\r\n            const attr = e.attributes.item(i);\r\n            if (attr != null) {\r\n                const name = attr.name;\r\n                const value = attr.value;\r\n                target.setAttribute(name, value);\r\n            }\r\n        }\r\n    }\r\n    function getLines(svgText) {\r\n        const spans = html_functions_1.HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n        let r = [];\r\n        if (spans.length == 0) {\r\n            return [];\r\n        }\r\n        else {\r\n            r.push([]);\r\n            let y = 0;\r\n            spans.forEach((v, i) => {\r\n                if (v.getAttribute(\"newline\") == \"true\") {\r\n                    r.push([v]);\r\n                    y++;\r\n                }\r\n                else {\r\n                    r[y].push(v);\r\n                }\r\n            });\r\n            return r;\r\n        }\r\n    }\r\n    function alignTextByHorizontalAnchor(svgText, hAnchor) {\r\n        const lineSpans = getLines(svgText);\r\n        let dx = 0;\r\n        if (hAnchor == enums_1.HorizontalAnchor.Center) {\r\n            const tl = getComputedTextLengthsOfTSpans(svgText, true);\r\n            let p = 0;\r\n            let maxWidth = 0;\r\n            const widths = lineSpans.map((v) => {\r\n                let width = 0;\r\n                v.forEach((w) => {\r\n                    width += tl[p++].width;\r\n                });\r\n                return width;\r\n            });\r\n            p = 0;\r\n            widths.forEach((v) => {\r\n                if (v > maxWidth)\r\n                    maxWidth = v;\r\n            });\r\n            dx = 0;\r\n            if (widths.length > 0) {\r\n                for (let y = 0; y < lineSpans.length; y++) {\r\n                    const offset = (maxWidth - widths[y]) / 2;\r\n                    let width = offset;\r\n                    for (let x = 0; x < lineSpans[y].length; x++) {\r\n                        const v = lineSpans[y][x];\r\n                        const tLen = tl[p++].width;\r\n                        if (x == 0 && y != 0) {\r\n                            v.setAttribute(\"dx\", (dx + offset).toString());\r\n                        }\r\n                        width += tLen;\r\n                    }\r\n                    dx = -width;\r\n                }\r\n            }\r\n        }\r\n        else if (hAnchor == enums_1.HorizontalAnchor.Right) {\r\n        }\r\n    }\r\n    function alignTextAsText(svgText, showChecked) {\r\n        const lineSpans = getLines(svgText);\r\n        const fontSize = (svgText).getPropertyStyleValueWithDefault(\"font-size\", \"24\");\r\n        const fs = parseInt(fontSize);\r\n        let dx = 0;\r\n        let dy = fs;\r\n        let c = 0;\r\n        const lengths = getComputedTextLengthsOfTSpans(svgText, showChecked);\r\n        for (let y = 0; y < lineSpans.length; y++) {\r\n            let width = 0;\r\n            let heightMax = fs;\r\n            let fstObj = null;\r\n            for (let x = 0; x < lineSpans[y].length; x++) {\r\n                const v = lineSpans[y][x];\r\n                const size = lengths[c++];\r\n                if (size.height > heightMax)\r\n                    heightMax = size.height;\r\n                if (x == 0)\r\n                    v.setAttribute(\"dx\", dx.toString());\r\n                if (x == 0)\r\n                    fstObj = v;\r\n                width += size.width;\r\n            }\r\n            if (y != 0 && fstObj != null)\r\n                fstObj.setAttribute(\"dy\", heightMax.toString());\r\n            dx -= width;\r\n        }\r\n    }\r\n    function sortText(svgText, hAnchor, showChecked) {\r\n        alignTextAsText(svgText, showChecked);\r\n        alignTextByHorizontalAnchor(svgText, hAnchor);\r\n    }\r\n    SVGTextBox.sortText = sortText;\r\n    function constructSVGTextByHTMLElements(svgText, text, isLatexMode) {\r\n        svgText.textContent = \"\";\r\n        const spans = text.map((v, i) => {\r\n            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\r\n            tspan.innerHTML = v.innerHTML;\r\n            copy(v, tspan);\r\n            return tspan;\r\n        });\r\n        let dy = 0;\r\n        spans.forEach((v, i) => {\r\n            svgText.appendChild(v);\r\n        });\r\n    }\r\n    SVGTextBox.constructSVGTextByHTMLElements = constructSVGTextByHTMLElements;\r\n    let ura = null;\r\n    function getSize(svgText, showChecked = false) {\r\n        let r = new vline_1.Rectangle();\r\n        const b = showChecked ? true : html_functions_1.HTMLFunctions.isShow(svgText);\r\n        if (b) {\r\n            const rect = svgText.getBBox();\r\n            r.x = rect.x;\r\n            r.y = rect.y;\r\n            r.width = rect.width;\r\n            r.height = rect.height;\r\n            return r;\r\n        }\r\n        else {\r\n            return new vline_1.Rectangle();\r\n        }\r\n    }\r\n    SVGTextBox.getSize = getSize;\r\n    function getComputedTextLengthsOfTSpans(svgText, showChecked) {\r\n        const b = showChecked ? true : html_functions_1.HTMLFunctions.isShow(svgText);\r\n        if (b) {\r\n            const tspans = html_functions_1.HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n            const r = tspans.map((v) => {\r\n                const w = v.getComputedTextLength();\r\n                const fontSize = v.getPropertyStyleValueWithDefault(\"font-size\", \"24\");\r\n                const fs = common_functions_1.CommonFunctions.toPX(fontSize);\r\n                return new vline_1.Size(w, fs);\r\n            });\r\n            return r;\r\n        }\r\n        else {\r\n            const tspans = html_functions_1.HTMLFunctions.getChildren(svgText).filter((v) => v.nodeName == \"tspan\");\r\n            const r = tspans.map((v) => {\r\n                return new vline_1.Size(0, 0);\r\n            });\r\n            return r;\r\n        }\r\n    }\r\n    SVGTextBox.getComputedTextLengthsOfTSpans = getComputedTextLengthsOfTSpans;\r\n})(SVGTextBox = exports.SVGTextBox || (exports.SVGTextBox = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/basic/svghtml/svg_textbox.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_arrow_callout.ts":
/*!******************************************************!*\
  !*** ../GraphTableSVG/src/object/g_arrow_callout.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_path_textbox_1 = __webpack_require__(/*! ./g_path_textbox */ \"../GraphTableSVG/src/object/g_path_textbox.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nclass GArrowCallout extends g_path_textbox_1.GPathTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (option.height == undefined)\r\n            this.height = 100;\r\n        if (option.width == undefined)\r\n            this.width = 100;\r\n        this.arrowNeckWidth = option.arrowNeckWidth == undefined ? 10 : option.arrowNeckWidth;\r\n        this.arrowNeckHeight = option.arrowNeckHeight == undefined ? 10 : option.arrowNeckHeight;\r\n        this.arrowHeadWidth = option.arrowHeadWidth == undefined ? 20 : option.arrowHeadWidth;\r\n        this.arrowHeadHeight = option.arrowHeadHeight == undefined ? 20 : option.arrowHeadHeight;\r\n        this.svgGroup.setAttribute(\"data-direction\", option.direction == undefined ? \"down\" : option.direction);\r\n        this.updateAttributes.push(\"data-direction\");\r\n        if (this.type == enums_1.ShapeObjectType.ArrowCallout)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        output.arrowNeckWidth = e.gtGetAttributeNumberWithoutNull(\"arrow-neck-width\", 10);\r\n        output.arrowNeckHeight = e.gtGetAttributeNumberWithoutNull(\"arrow-neck-height\", 10);\r\n        output.arrowHeadWidth = e.gtGetAttributeNumberWithoutNull(\"arrow-head-width\", 20);\r\n        output.arrowHeadHeight = e.gtGetAttributeNumberWithoutNull(\"arrow-head-height\", 20);\r\n        const p = e.gtGetAttribute(\"direction\", \"\");\r\n        output.direction = enums_1.Direction.toDirection(p);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"arrow-neck-width\");\r\n            e.removeAttribute(\"arrow-neck-height\");\r\n            e.removeAttribute(\"arrow-head-width\");\r\n            e.removeAttribute(\"arrow-head-height\");\r\n            e.removeAttribute(\"direction\");\r\n        }\r\n        return output;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.ArrowCallout;\r\n    }\r\n    get arrowNeckWidth() {\r\n        return this.svgGroup.gtGetAttributeNumberWithoutNull(\"data-arrow-neck-width\", 0);\r\n    }\r\n    set arrowNeckWidth(value) {\r\n        if (this.arrowNeckWidth != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-neck-width\", value.toString());\r\n    }\r\n    get arrowNeckHeight() {\r\n        return this.svgGroup.gtGetAttributeNumberWithoutNull(\"data-arrow-neck-height\", 0);\r\n    }\r\n    set arrowNeckHeight(value) {\r\n        if (this.arrowNeckHeight != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-neck-height\", value.toString());\r\n    }\r\n    get arrowHeadWidth() {\r\n        return this.svgGroup.gtGetAttributeNumberWithoutNull(\"data-arrow-head-width\", 0);\r\n    }\r\n    set arrowHeadWidth(value) {\r\n        if (this.arrowHeadWidth != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-head-width\", value.toString());\r\n    }\r\n    get arrowHeadHeight() {\r\n        return this.svgGroup.gtGetAttributeNumberWithoutNull(\"data-arrow-head-height\", 0);\r\n    }\r\n    set arrowHeadHeight(value) {\r\n        if (this.arrowHeadHeight != value)\r\n            this.svgGroup.setAttribute(\"data-arrow-head-height\", value.toString());\r\n    }\r\n    get direction() {\r\n        const r = this.svgGroup.getAttribute(\"data-direction\");\r\n        return enums_1.Direction.toDirection(r);\r\n    }\r\n    set direction(value) {\r\n        if (this.direction != value) {\r\n            this.svgGroup.setAttribute(\"data-direction\", value.toString());\r\n        }\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        if (this.isAutoSizeShapeToFitText) {\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n            rect.width = textRect.width;\r\n            rect.height = textRect.height;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        else {\r\n            rect.width = this.boxWidth - this.marginPaddingLeft;\r\n            rect.height = this.boxHeight - this.marginPaddingTop;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        if (this.direction == \"up\")\r\n            rect.y += this.arrowNeckHeight + this.arrowHeadHeight;\r\n        if (this.direction == \"left\")\r\n            rect.x += this.arrowNeckHeight + this.arrowHeadHeight;\r\n        return rect;\r\n    }\r\n    get boxHeight() {\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            return this.height - this.arrowNeckHeight - this.arrowHeadWidth;\r\n        }\r\n        else {\r\n            return this.height;\r\n        }\r\n    }\r\n    get boxWidth() {\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            return this.width;\r\n        }\r\n        else {\r\n            return this.width - this.arrowNeckHeight - this.arrowHeadWidth;\r\n        }\r\n    }\r\n    updateToFitText() {\r\n        const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n        if (this.direction == \"up\" || this.direction == \"down\") {\r\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight;\r\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom + this.arrowNeckHeight + this.arrowHeadHeight;\r\n        }\r\n        else {\r\n            this.width = textRect.width + this.marginPaddingLeft + this.marginPaddingRight + this.arrowNeckHeight + this.arrowHeadHeight;\r\n            this.height = textRect.height + this.marginPaddingTop + this.marginPaddingBottom;\r\n        }\r\n    }\r\n    update() {\r\n        super.update();\r\n        if (this.direction == \"up\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1 + this.arrowHeadHeight + this.arrowNeckHeight;\r\n            const bx2 = x2;\r\n            const by2 = y2;\r\n            let nx1 = -(this.arrowNeckWidth / 2);\r\n            let nx2 = (this.arrowNeckWidth / 2);\r\n            let ny = by1 - this.arrowNeckHeight;\r\n            let cx = 0;\r\n            let hx1 = -(this.arrowHeadWidth / 2);\r\n            let hx2 = (this.arrowHeadWidth / 2);\r\n            let hy = y1;\r\n            const mes = `H ${nx1} V ${ny} H ${hx1} L ${cx} ${hy} L ${hx2} ${ny} H ${nx2} V ${by1}`;\r\n            const top = `M ${bx1} ${by1} ${mes} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else if (this.direction == \"left\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1 + this.arrowHeadHeight + this.arrowNeckHeight;\r\n            const by1 = y1;\r\n            const bx2 = x2;\r\n            const by2 = y2;\r\n            let ny1 = 0 + (this.arrowNeckWidth / 2);\r\n            let ny2 = 0 - (this.arrowNeckWidth / 2);\r\n            let nx = bx1 - this.arrowNeckHeight;\r\n            let cy = 0;\r\n            let hy1 = 0 + (this.arrowHeadWidth / 2);\r\n            let hy2 = 0 - (this.arrowHeadWidth / 2);\r\n            let hx = x1;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx1} V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else if (this.direction == \"right\") {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1;\r\n            const bx2 = x2 - this.arrowHeadHeight - this.arrowNeckHeight;\r\n            const by2 = y2;\r\n            let ny1 = 0 - (this.arrowNeckWidth / 2);\r\n            let ny2 = 0 + (this.arrowNeckWidth / 2);\r\n            let nx = bx2 + this.arrowNeckHeight;\r\n            let cy = 0;\r\n            let hy1 = 0 - (this.arrowHeadWidth / 2);\r\n            let hy2 = 0 + (this.arrowHeadWidth / 2);\r\n            let hx = x2;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${ny1} H ${nx} V ${hy1} L ${hx} ${cy} L ${nx} ${hy2} V ${ny2} H ${bx2} V ${by2}`;\r\n            const bottom = `H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n        else {\r\n            const x1 = -(this.width / 2);\r\n            const y1 = -(this.height / 2);\r\n            const x2 = (this.width / 2);\r\n            const y2 = (this.height / 2);\r\n            const bx1 = x1;\r\n            const by1 = y1;\r\n            const bx2 = x2;\r\n            const by2 = y2 - this.arrowHeadHeight - this.arrowNeckHeight;\r\n            let nx1 = -(this.arrowNeckWidth / 2);\r\n            let nx2 = (this.arrowNeckWidth / 2);\r\n            let ny = by2 + this.arrowNeckHeight;\r\n            let cx = 0;\r\n            let hx1 = -(this.arrowHeadWidth / 2);\r\n            let hx2 = (this.arrowHeadWidth / 2);\r\n            let hy = y2;\r\n            const top = `M ${bx1} ${by1} H ${bx2}`;\r\n            const right = `V ${by2}`;\r\n            const bottom = `H ${nx2} V ${ny} H ${hx2} L ${cx} ${hy} L ${hx1} ${ny} H ${nx1} V ${by2} H ${bx1}`;\r\n            const left = `V ${by1}`;\r\n            this.svgPath.setAttribute(\"d\", `${top} ${right} ${bottom} ${left} z`);\r\n        }\r\n    }\r\n    get shape() {\r\n        switch (this.direction) {\r\n            case \"up\": return \"msoShapeUpArrowCallout\";\r\n            case \"left\": return \"msoShapeLeftArrowCallout\";\r\n            case \"right\": return \"msoShapeRightArrowCallout\";\r\n            case \"down\": return \"msoShapeDownArrowCallout\";\r\n        }\r\n        return \"msoShapeDownArrowCallout\";\r\n    }\r\n    get VBAAdjustments() {\r\n        if (this.direction == \"up\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxHeightRatio = this.boxHeight / this.height;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\r\n        }\r\n        else if (this.direction == \"right\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxWidthRatio = this.boxWidth / this.width;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\r\n        }\r\n        else if (this.direction == \"left\") {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxWidthRatio = this.boxWidth / this.width;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxWidthRatio];\r\n        }\r\n        else {\r\n            const neckWidthRatio = this.arrowNeckWidth / this.height;\r\n            const headWidthRatio = this.arrowHeadWidth / (this.height * 2);\r\n            const headHeightRatio = this.arrowHeadHeight / this.height;\r\n            const boxHeightRatio = this.boxHeight / this.height;\r\n            return [neckWidthRatio, headWidthRatio, headHeightRatio, boxHeightRatio];\r\n        }\r\n    }\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.x, this.y - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.x + wr, this.y];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.x, this.y + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.x - wr, this.y];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y + hr);\r\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + wr, this.y - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GArrowCallout = GArrowCallout;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_arrow_callout.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_callout.ts":
/*!************************************************!*\
  !*** ../GraphTableSVG/src/object/g_callout.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst g_path_textbox_1 = __webpack_require__(/*! ./g_path_textbox */ \"../GraphTableSVG/src/object/g_path_textbox.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nclass GCallout extends g_path_textbox_1.GPathTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        const defaultSX = this.fixedX == null ? this.cx - 100 : this.fixedX - 50;\r\n        const defaultSY = this.fixedY == null ? this.cy - 100 : this.fixedY - 50;\r\n        this.speakerX = option.speakerX == undefined ? defaultSX : option.speakerX;\r\n        this.speakerY = option.speakerY == undefined ? defaultSY : option.speakerY;\r\n        if (this.type == enums_1.ShapeObjectType.Callout)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        if (e.hasAttribute(\"speaker-x\"))\r\n            output.speakerX = e.gtGetAttributeNumber(\"speaker-x\", 200);\r\n        if (e.hasAttribute(\"speaker-y\"))\r\n            output.speakerY = e.gtGetAttributeNumber(\"speaker-y\", 200);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"speaker-x\");\r\n            e.removeAttribute(\"speaker-y\");\r\n        }\r\n        return output;\r\n    }\r\n    get type() {\r\n        return \"g-callout\";\r\n    }\r\n    update() {\r\n        super.update();\r\n        const x1 = -(this.width / 2);\r\n        const y1 = -(this.height / 2);\r\n        const x2 = (this.width / 2);\r\n        const y2 = (this.height / 2);\r\n        const speakerDiffX = this.speakerX - this.cx;\r\n        const speakerDiffY = this.speakerY - this.cy;\r\n        let px1 = 0, px2 = 0, py1 = 0, py2 = 0;\r\n        let mes = \"\";\r\n        switch (this.speakerPosition) {\r\n            case \"upleft\":\r\n                px1 = (x1 / 3) * 2;\r\n                px2 = (x1 / 3) * 1;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"upright\":\r\n                px1 = (x2 / 3) * 1;\r\n                px2 = (x2 / 3) * 2;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y1}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} ${mes} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"rightup\":\r\n                py1 = (y1 / 3) * 2;\r\n                py2 = (y1 / 3) * 1;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"rightdown\":\r\n                py1 = (y2 / 3) * 1;\r\n                py2 = (y2 / 3) * 2;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x2} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} ${mes} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"leftup\":\r\n                py1 = (y1 / 3) * 1;\r\n                py2 = (y1 / 3) * 2;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\r\n                break;\r\n            case \"leftdown\":\r\n                py1 = (y2 / 3) * 2;\r\n                py2 = (y2 / 3) * 1;\r\n                mes = `V ${py1} L ${speakerDiffX} ${speakerDiffY} L ${x1} ${py2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} ${mes} V ${y1} z`);\r\n                break;\r\n            case \"downleft\":\r\n                px1 = (x1 / 3) * 1;\r\n                px2 = (x1 / 3) * 2;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\r\n                break;\r\n            case \"downright\":\r\n                px1 = (x2 / 3) * 2;\r\n                px2 = (x2 / 3) * 1;\r\n                mes = `H ${px1} L ${speakerDiffX} ${speakerDiffY} L ${px2} ${y2}`;\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} ${mes} H ${x1} V ${y1} z`);\r\n                break;\r\n            default:\r\n                this.svgPath.setAttribute(\"d\", `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} V ${y1} z`);\r\n                break;\r\n        }\r\n    }\r\n    get speakerX() {\r\n        return this.svgGroup.gtGetAttributeNumber(\"data-speaker-x\", 0);\r\n    }\r\n    set speakerX(value) {\r\n        if (this.speakerX != value)\r\n            this.svgGroup.setAttribute(\"data-speaker-x\", value.toString());\r\n    }\r\n    get speakerY() {\r\n        return this.svgGroup.gtGetAttributeNumber(\"data-speaker-y\", 0);\r\n    }\r\n    set speakerY(value) {\r\n        if (this.speakerY != value)\r\n            this.svgGroup.setAttribute(\"data-speaker-y\", value.toString());\r\n    }\r\n    get speakerPosition() {\r\n        const speakerDiffX = this.speakerX - this.cx;\r\n        const speakerDiffY = this.speakerY - this.cy;\r\n        const x1 = -(this.width / 2);\r\n        const y1 = -(this.height / 2);\r\n        const x2 = (this.width / 2);\r\n        const y2 = (this.height / 2);\r\n        if (x1 <= speakerDiffX && speakerDiffX <= x2 && y1 <= speakerDiffY && speakerDiffY <= y2) {\r\n            return \"inner\";\r\n        }\r\n        if (this.speakerX > this.cx) {\r\n            if (this.speakerY > this.cy) {\r\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"rightdown\";\r\n                }\r\n                else {\r\n                    return \"downright\";\r\n                }\r\n            }\r\n            else {\r\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"upright\";\r\n                }\r\n                else {\r\n                    return \"rightup\";\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this.speakerY > this.cy) {\r\n                const line = new vline_1.VLine(0, 0, this.width, -this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"leftdown\";\r\n                }\r\n                else {\r\n                    return \"downleft\";\r\n                }\r\n            }\r\n            else {\r\n                const line = new vline_1.VLine(0, 0, this.width, this.height);\r\n                if (line.contains(speakerDiffX, speakerDiffY)) {\r\n                    return \"upleft\";\r\n                }\r\n                else {\r\n                    return \"leftup\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get shape() {\r\n        return \"msoShapeRectangularCallout\";\r\n    }\r\n    get VBAAdjustments() {\r\n        const y1 = this.speakerY - this.cy;\r\n        const py = y1 / this.height;\r\n        const x1 = this.speakerX - this.cx;\r\n        const px = x1 / this.width;\r\n        return [px, py];\r\n    }\r\n}\r\nexports.GCallout = GCallout;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_callout.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_edge.ts":
/*!*********************************************!*\
  !*** ../GraphTableSVG/src/object/g_edge.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ../basic/common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst vba_functions_1 = __webpack_require__(/*! ../basic/common/vba_functions */ \"../GraphTableSVG/src/basic/common/vba_functions.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"../GraphTableSVG/src/object/g_vertex.ts\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nclass GEdge extends g_textbox_1.GTextBox {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this.connectPositionChangedFunc = () => {\r\n            this.update();\r\n        };\r\n        this.VBAConnectorNumber = 1;\r\n        this._isSpecialTextBox = true;\r\n        this.updateAttributes.push(custtome_attributes_1.CustomAttributeNames.beginNodeName);\r\n        this.updateAttributes.push(custtome_attributes_1.CustomAttributeNames.endNodeName);\r\n        const pathClass = this.svgSurface.getAttribute(\"class\");\r\n        if (pathClass == custtome_attributes_1.CustomAttributeNames.StyleValue.defaultSurfaceClass) {\r\n            this.svgSurface.setAttribute(\"class\", custtome_attributes_1.CustomAttributeNames.StyleValue.defaultPathSurfaceClass);\r\n        }\r\n        const _option = this.initializeOption(option);\r\n        this.svgText.textContent = \"\";\r\n        if (option.textClass === undefined)\r\n            option.textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextClass;\r\n        this._svgTextPath = svg_1.SVG.createTextPath2(option.textClass);\r\n        this.svgPath.id = `path-${this.objectID}`;\r\n        this.svgText.appendChild(this._svgTextPath);\r\n        this._svgTextPath.href.baseVal = `#${this.svgPath.id}`;\r\n        if (typeof _option.text == \"string\") {\r\n            this.svgTextPath.setTextContent(_option.text);\r\n        }\r\n        else if (Array.isArray(_option.text)) {\r\n        }\r\n        else {\r\n        }\r\n        const edgeColor = this.svgPath.getPropertyStyleValue(\"stroke\");\r\n        const edgeColor2 = edgeColor == null ? undefined : edgeColor;\r\n        const strokeWidth = this.svgPath.getPropertyStyleValue(\"stroke-width\");\r\n        const strokeWidth2 = strokeWidth == null ? undefined : strokeWidth;\r\n        if (_option.startMarker !== undefined)\r\n            this.markerStart = GEdge.createStartMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\r\n        if (_option.endMarker !== undefined)\r\n            this.markerEnd = GEdge.createEndMarker({ color: edgeColor2, strokeWidth: strokeWidth2 });\r\n        this.pathPoints = [[_option.x1, _option.y1], [_option.x2, _option.y2]];\r\n        if (_option.beginVertex instanceof g_vertex_1.GVertex)\r\n            this.beginVertex = _option.beginVertex;\r\n        if (_option.endVertex instanceof g_vertex_1.GVertex)\r\n            this.endVertex = _option.endVertex;\r\n        if (_option.x3 !== undefined && _option.y3 !== undefined) {\r\n            this.controlPoint = [[_option.x3, _option.y3]];\r\n        }\r\n        if (_option.beginConnectorType !== undefined)\r\n            this.beginConnectorType = _option.beginConnectorType;\r\n        if (_option.endConnectorType !== undefined)\r\n            this.endConnectorType = _option.endConnectorType;\r\n        if (_option.pathTextAlignment !== undefined)\r\n            this.pathTextAlignment = _option.pathTextAlignment;\r\n        if (this.svgText.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.PathTextAlignment) == null) {\r\n            this.pathTextAlignment = enums_1.PathTextAlighnment.center;\r\n        }\r\n        if (this.type == enums_1.ShapeObjectType.Edge)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        const _output = g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        _output.x1 = e.gtGetAttributeNumberWithoutNull(\"x1\", 0);\r\n        _output.x2 = e.gtGetAttributeNumberWithoutNull(\"x2\", 300);\r\n        _output.y1 = e.gtGetAttributeNumberWithoutNull(\"y1\", 0);\r\n        _output.y2 = e.gtGetAttributeNumberWithoutNull(\"y2\", 300);\r\n        if (e.hasAttribute(\"x3\")) {\r\n            _output.x3 = e.gtGetAttributeNumberWithoutNull(\"x3\", 0);\r\n        }\r\n        if (e.hasAttribute(\"y3\")) {\r\n            _output.y3 = e.gtGetAttributeNumberWithoutNull(\"y3\", 0);\r\n        }\r\n        _output.beginVertex = e.gtGetAttributeStringWithUndefined(\"begin-vertex\");\r\n        _output.endVertex = e.gtGetAttributeStringWithUndefined(\"end-vertex\");\r\n        const bct = e.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.beginConnectorType);\r\n        if (bct != null)\r\n            _output.beginConnectorType = enums_1.ConnectorPosition.ToConnectorPosition(bct);\r\n        const ect = e.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.endConnectorType);\r\n        if (ect != null)\r\n            _output.endConnectorType = enums_1.ConnectorPosition.ToConnectorPosition(ect);\r\n        _output.startMarker = e.gtGetStyleBooleanWithUndefined(custtome_attributes_1.CustomAttributeNames.Style.markerStart);\r\n        _output.endMarker = e.gtGetAttributeBooleanWithUndefined(custtome_attributes_1.CustomAttributeNames.Style.markerEnd);\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"x1\");\r\n            e.removeAttribute(\"x2\");\r\n            e.removeAttribute(\"x3\");\r\n            e.removeAttribute(\"y1\");\r\n            e.removeAttribute(\"y2\");\r\n            e.removeAttribute(\"y3\");\r\n            e.removeAttribute(\"begin-vertex\");\r\n            e.removeAttribute(\"end-vertex\");\r\n        }\r\n        return _output;\r\n    }\r\n    initializeOption(option) {\r\n        const _option = super.initializeOption(option);\r\n        const markerStartName = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.markerStart);\r\n        const markerEndName = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.markerEnd);\r\n        if (typeof _option.startMarker === \"undefined\" && markerStartName != null)\r\n            _option.startMarker = markerStartName == \"true\";\r\n        if (typeof _option.endMarker === \"undefined\" && markerEndName != null)\r\n            _option.endMarker = markerEndName == \"true\";\r\n        if (typeof _option.x1 === \"undefined\")\r\n            _option.x1 = 0;\r\n        if (typeof _option.y1 === \"undefined\")\r\n            _option.y1 = 0;\r\n        if (typeof _option.x2 === \"undefined\")\r\n            _option.x2 = 300;\r\n        if (typeof _option.y2 === \"undefined\")\r\n            _option.y2 = 300;\r\n        if (typeof _option.beginVertex === \"string\") {\r\n            const obj = g_textbox_1.GTextBox.getObjectFromID(_option.beginVertex);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                _option.beginVertex = obj;\r\n            }\r\n        }\r\n        if (typeof _option.endVertex === \"string\") {\r\n            const obj = g_textbox_1.GTextBox.getObjectFromID(_option.endVertex);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                _option.endVertex = obj;\r\n            }\r\n        }\r\n        return _option;\r\n    }\r\n    static getConnectedVertexFromDic(edge, isBegin) {\r\n        const dic = isBegin ? GEdge.connectedBeginVertexDic : GEdge.connectedEndVertexDic;\r\n        if (edge.objectID in dic) {\r\n            const id = dic[edge.objectID];\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(id);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                return obj;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    static setConnectedVertexFromDic(edge, isBegin) {\r\n        const dic = isBegin ? GEdge.connectedBeginVertexDic : GEdge.connectedEndVertexDic;\r\n        const id = isBegin ? edge.beginVertexID : edge.endVertexID;\r\n        if (id == null) {\r\n            if (edge.objectID in dic) {\r\n                delete dic[edge.objectID];\r\n            }\r\n        }\r\n        else {\r\n            dic[edge.objectID] = id;\r\n        }\r\n    }\r\n    get degree() {\r\n        const rad = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);\r\n        const degree = (180 * rad) / Math.PI;\r\n        return degree;\r\n    }\r\n    get defaultClassName() {\r\n        return custtome_attributes_1.CustomAttributeNames.StyleValue.defaultEdgeClass;\r\n    }\r\n    get svgPath() {\r\n        return this.svgSurface;\r\n    }\r\n    get svgTextPath() {\r\n        return this._svgTextPath;\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultEdgePathClass;\r\n        this._svgSurface = GEdge.createPath(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\r\n    }\r\n    static createPath(parent, x, y, x2, y2, className, style) {\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n        parent.appendChild(path);\r\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\r\n        if (style !== undefined)\r\n            path.setAttribute(\"style\", style);\r\n        path.setAttribute(\"class\", className);\r\n        return path;\r\n    }\r\n    get type() {\r\n        return \"g-edge\";\r\n    }\r\n    get controlPoint() {\r\n        const r = this.pathPoints;\r\n        r.shift();\r\n        r.pop();\r\n        return r;\r\n    }\r\n    set controlPoint(value) {\r\n        const fst = [this.x1, this.y1];\r\n        const lst = [this.x2, this.y2];\r\n        value.unshift(fst);\r\n        value.push(lst);\r\n        this.pathPoints = value;\r\n    }\r\n    get beginConnectorType() {\r\n        const p = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.beginConnectorType);\r\n        return enums_1.ConnectorPosition.ToConnectorPosition(p);\r\n    }\r\n    set beginConnectorType(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.beginConnectorType, value);\r\n    }\r\n    get endConnectorType() {\r\n        const p = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.endConnectorType);\r\n        return enums_1.ConnectorPosition.ToConnectorPosition(p);\r\n    }\r\n    set endConnectorType(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.endConnectorType, value);\r\n    }\r\n    get beginVertexID() {\r\n        return this.svgGroup.getAttribute(custtome_attributes_1.CustomAttributeNames.beginNodeName);\r\n    }\r\n    set beginVertexID(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(custtome_attributes_1.CustomAttributeNames.beginNodeName);\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(custtome_attributes_1.CustomAttributeNames.beginNodeName, v);\r\n        }\r\n    }\r\n    get endVertexID() {\r\n        return this.svgGroup.getAttribute(custtome_attributes_1.CustomAttributeNames.endNodeName);\r\n    }\r\n    set endVertexID(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(custtome_attributes_1.CustomAttributeNames.endNodeName);\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(custtome_attributes_1.CustomAttributeNames.endNodeName, v);\r\n        }\r\n    }\r\n    get isAppropriatelyReverseMode() {\r\n        const p = this.svgGroup.getAttribute(custtome_attributes_1.CustomAttributeNames.isAppropriatelyReverseTextMode);\r\n        if (p == null) {\r\n            return false;\r\n        }\r\n        else {\r\n            return p == \"true\";\r\n        }\r\n    }\r\n    set isAppropriatelyReverseMode(v) {\r\n        this.svgGroup.setAttribute(custtome_attributes_1.CustomAttributeNames.isAppropriatelyReverseTextMode, v.toString());\r\n    }\r\n    get side() {\r\n        return this.svgTextPath.getAttribute(\"side\");\r\n    }\r\n    set side(v) {\r\n        if (v == null) {\r\n            this.svgTextPath.removeAttribute(\"side\");\r\n        }\r\n        else {\r\n            this.svgTextPath.setAttribute(\"side\", v);\r\n        }\r\n    }\r\n    get markerStart() {\r\n        if (this.svgPath != null) {\r\n            var p = this.svgPath.getAttribute(\"marker-start\");\r\n            if (p != null) {\r\n                const str = p.substring(5, p.length - 1);\r\n                const ele = document.getElementById(str);\r\n                return ele;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set markerStart(value) {\r\n        if (this.svgPath != null) {\r\n            if (value == null) {\r\n                this.svgPath.removeAttribute(\"marker-start\");\r\n            }\r\n            else {\r\n                this.svgGroup.appendChild(value);\r\n                this.svgPath.setAttribute(\"marker-start\", `url(#${value.id})`);\r\n            }\r\n        }\r\n    }\r\n    get markerEnd() {\r\n        if (this.svgPath != null) {\r\n            var p = this.svgPath.getAttribute(\"marker-end\");\r\n            if (p != null) {\r\n                const str = p.substring(5, p.length - 1);\r\n                const ele = document.getElementById(str);\r\n                return ele;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set markerEnd(value) {\r\n        if (this.svgPath != null) {\r\n            if (value == null) {\r\n                this.svgPath.removeAttribute(\"marker-end\");\r\n            }\r\n            else {\r\n                this.svgGroup.appendChild(value);\r\n                this.svgPath.setAttribute(\"marker-end\", `url(#${value.id})`);\r\n            }\r\n        }\r\n    }\r\n    removeVertexEvent(vertex) {\r\n        vertex.svgGroup.removeEventListener(custtome_attributes_1.CustomAttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\r\n    }\r\n    addVertexEvent(vertex) {\r\n        vertex.svgGroup.addEventListener(custtome_attributes_1.CustomAttributeNames.connectPositionChangedEventName, this.connectPositionChangedFunc);\r\n    }\r\n    get beginVertex() {\r\n        if (this.beginVertexID == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return g_textbox_1.GTextBox.getObjectFromObjectID(this.beginVertexID);\r\n        }\r\n    }\r\n    set beginVertex(value) {\r\n        if (value == null) {\r\n            this.beginVertexID = null;\r\n        }\r\n        else {\r\n            this.beginVertexID = value.objectID;\r\n        }\r\n        this.update();\r\n    }\r\n    get endVertex() {\r\n        if (this.endVertexID == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return g_textbox_1.GTextBox.getObjectFromObjectID(this.endVertexID);\r\n        }\r\n    }\r\n    set endVertex(value) {\r\n        if (value == null) {\r\n            this.endVertexID = null;\r\n        }\r\n        else {\r\n            this.endVertexID = value.objectID;\r\n        }\r\n        this.update();\r\n    }\r\n    dispose() {\r\n        this.beginVertex = null;\r\n        this.endVertex = null;\r\n    }\r\n    get x1() {\r\n        return this.pathPoints[0][0];\r\n    }\r\n    set x1(value) {\r\n        const p = this.pathPoints;\r\n        p[0][0] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    get y1() {\r\n        return this.pathPoints[0][1];\r\n    }\r\n    set y1(value) {\r\n        const p = this.pathPoints;\r\n        p[0][1] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    get x2() {\r\n        const d = this.pathPoints;\r\n        return d[d.length - 1][0];\r\n    }\r\n    set x2(value) {\r\n        const p = this.pathPoints;\r\n        p[p.length - 1][0] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    get y2() {\r\n        const d = this.pathPoints;\r\n        return d[d.length - 1][1];\r\n    }\r\n    set y2(value) {\r\n        const p = this.pathPoints;\r\n        p[p.length - 1][1] = value;\r\n        this.pathPoints = p;\r\n    }\r\n    get lineColor() {\r\n        if (this.svgPath != null) {\r\n            return this.svgPath.getPropertyStyleValueWithDefault(\"stroke\", \"black\");\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    removeTextLengthAttribute() {\r\n        if (this.svgText.hasAttribute(\"textLength\"))\r\n            this.svgText.removeAttribute(\"textLength\");\r\n        if (this.svgTextPath.hasAttribute(\"textLength\"))\r\n            this.svgTextPath.removeAttribute(\"textLength\");\r\n        if (this.svgText.hasAttribute(\"letter-spacing\"))\r\n            this.svgText.removeAttribute(\"letter-spacing\");\r\n    }\r\n    setRegularInterval(value) {\r\n        this.removeTextLengthAttribute();\r\n        const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n        const diff = value - textRect.width;\r\n        const number = this.svgText.textContent != null ? this.svgText.textContent.length : 0;\r\n        if (number >= 2) {\r\n            const w = diff / (number - 1);\r\n            this.svgText.setAttribute(\"letter-spacing\", `${w}`);\r\n        }\r\n        this.svgText.setAttribute(\"textLength\", `${value}`);\r\n        this.svgTextPath.setAttribute(\"textLength\", `${value}`);\r\n    }\r\n    get pathPoints() {\r\n        const dAttr = this.svgPath.getAttribute(\"d\");\r\n        if (dAttr == null)\r\n            throw Error(\"error\");\r\n        const d = dAttr.split(\" \");\r\n        let i = 0;\r\n        const r = [];\r\n        while (i < d.length) {\r\n            if (d[i] == \"M\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                i += 3;\r\n            }\r\n            else if (d[i] == \"L\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                i += 3;\r\n            }\r\n            else if (d[i] == \"Q\") {\r\n                r.push([Number(d[i + 1]), Number(d[i + 2])]);\r\n                r.push([Number(d[i + 3]), Number(d[i + 4])]);\r\n                i += 5;\r\n            }\r\n            else {\r\n                throw Error(\"path points parse error\");\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    set pathPoints(points) {\r\n        let path = \"\";\r\n        if (points.length == 2) {\r\n            const [x1, y1] = points[0];\r\n            const [x2, y2] = points[1];\r\n            path = `M ${x1} ${y1} L ${x2} ${y2}`;\r\n        }\r\n        else if (points.length == 3) {\r\n            const [x1, y1] = points[0];\r\n            const [x2, y2] = points[2];\r\n            const [cx1, cy1] = points[1];\r\n            path = `M ${x1} ${y1} Q ${cx1} ${cy1} ${x2} ${y2}`;\r\n        }\r\n        else if (points.length == 1) {\r\n            throw Error(\"path points ivnalid error\");\r\n        }\r\n        else {\r\n            path = `M ${0} ${0} L ${0} ${0}`;\r\n        }\r\n        const prevPath = this.svgPath.getAttribute(\"d\");\r\n        if (prevPath == null || path != prevPath) {\r\n            this.svgPath.setAttribute(\"d\", path);\r\n        }\r\n    }\r\n    updateConnectorInfo() {\r\n        const oldBeginVertex = GEdge.getConnectedVertexFromDic(this, true);\r\n        const oldEndVertex = GEdge.getConnectedVertexFromDic(this, false);\r\n        if (this.beginVertex != oldBeginVertex) {\r\n            if (oldBeginVertex != null) {\r\n                this.removeVertexEvent(oldBeginVertex);\r\n                if (oldBeginVertex.outcomingEdges.indexOf(this) != -1) {\r\n                    oldBeginVertex.removeOutcomingEdge(this);\r\n                }\r\n            }\r\n            if (this.beginVertex != null) {\r\n                this.addVertexEvent(this.beginVertex);\r\n                if (this.beginVertex.outcomingEdges.indexOf(this) == -1) {\r\n                    this.beginVertex.insertOutcomingEdge(this);\r\n                }\r\n            }\r\n            GEdge.setConnectedVertexFromDic(this, true);\r\n        }\r\n        if (this.endVertex != oldEndVertex) {\r\n            if (oldEndVertex != null) {\r\n                this.removeVertexEvent(oldEndVertex);\r\n                if (oldEndVertex.incomingEdges.indexOf(this) != -1) {\r\n                    oldEndVertex.removeIncomingEdge(this);\r\n                }\r\n            }\r\n            if (this.endVertex != null) {\r\n                this.addVertexEvent(this.endVertex);\r\n                if (this.endVertex.incomingEdges.indexOf(this) == -1) {\r\n                    this.endVertex.insertIncomingEdge(this);\r\n                }\r\n            }\r\n            GEdge.setConnectedVertexFromDic(this, false);\r\n        }\r\n    }\r\n    revTextForApp() {\r\n        if (this.side == \"left\" || this.side == null) {\r\n            this.side = \"right\";\r\n        }\r\n        else {\r\n            this.side = \"left\";\r\n        }\r\n        const tspans = new Array(0);\r\n        this.svgTextPath.children.item;\r\n        for (let i = this.svgTextPath.children.length; i >= 0; i--) {\r\n            const tspan = this.svgTextPath.children.item(i);\r\n            if (tspan instanceof SVGTSpanElement) {\r\n                tspans.push(tspan);\r\n            }\r\n        }\r\n        tspans.forEach((v) => v.remove());\r\n        tspans.forEach((v) => {\r\n            const text = v.textContent;\r\n            if (text != null) {\r\n                const revText = GEdge.getRevString(text);\r\n                v.textContent = revText;\r\n            }\r\n            this.svgTextPath.appendChild(v);\r\n        });\r\n    }\r\n    update() {\r\n        super.update();\r\n        this.updateConnectorInfo();\r\n        this._observer.disconnect();\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null) {\r\n            enums_1.msoDashStyle.setCpmoutedDashArray(this.svgPath);\r\n        }\r\n        this._observer.observe(this.svgGroup, this._observerOption);\r\n        const [cx1, cy1] = this.beginVertex != null ? [this.beginVertex.cx, this.beginVertex.cy] : [this.x1, this.y1];\r\n        const [cx2, cy2] = this.endVertex != null ? [this.endVertex.cx, this.endVertex.cy] : [this.x2, this.y2];\r\n        const [x1, y1] = this.beginVertex != null ? this.beginVertex.getLocation(this.beginConnectorType, cx2, cy2) : [cx1, cy1];\r\n        const [x2, y2] = this.endVertex != null ? this.endVertex.getLocation(this.endConnectorType, cx1, cy1) : [cx2, cy2];\r\n        const points = this.pathPoints;\r\n        points[0] = [x1, y1];\r\n        points[points.length - 1] = [x2, y2];\r\n        this.pathPoints = points;\r\n        if (this.isAppropriatelyReverseMode) {\r\n            const degree = this.degree;\r\n            if (degree < -90 || degree > 90) {\r\n                if (this.side == \"left\" || this.side == null) {\r\n                    this.revTextForApp();\r\n                }\r\n            }\r\n            else {\r\n                if (this.side == \"right\") {\r\n                    this.revTextForApp();\r\n                }\r\n            }\r\n        }\r\n        if (this.markerStart != null) {\r\n            var node = this.markerStart.firstChild;\r\n            if (this.lineColor != null) {\r\n                node.setAttribute(\"fill\", this.lineColor);\r\n            }\r\n        }\r\n        if (this.markerEnd != null) {\r\n            var node = this.markerEnd.firstChild;\r\n            if (this.lineColor != null) {\r\n                node.setAttribute(\"fill\", this.lineColor);\r\n            }\r\n        }\r\n        const strokeWidth = this.svgPath.getPropertyStyleValue(\"stroke-width\");\r\n        if (strokeWidth != null) {\r\n            const diffy = common_functions_1.CommonFunctions.toPX(strokeWidth) + 3;\r\n            this.svgText.setAttribute(\"dy\", `-${diffy}`);\r\n        }\r\n        else {\r\n            this.svgText.setAttribute(\"dy\", \"0\");\r\n        }\r\n        if (this.pathTextAlignment == enums_1.PathTextAlighnment.regularInterval) {\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            const strLen = this.svgTextPath.textContent == null ? 0 : this.svgTextPath.textContent.length;\r\n            if (strLen > 0) {\r\n                const startPos = pathLen / (strLen + 1);\r\n                let textPathLen = pathLen - (startPos * 2);\r\n                if (textPathLen <= 0)\r\n                    textPathLen = 5;\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${startPos}`);\r\n                this.setRegularInterval(textPathLen);\r\n            }\r\n        }\r\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.end) {\r\n            this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            this.removeTextLengthAttribute();\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            this.svgTextPath.setAttribute(\"startOffset\", `${pathLen - textRect.width}`);\r\n        }\r\n        else if (this.pathTextAlignment == enums_1.PathTextAlighnment.center) {\r\n            this.removeTextLengthAttribute();\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n            const pathLen = this.svgPath.getTotalLength();\r\n            const offset = (pathLen - textRect.width) / 2;\r\n            if (this.side == \"right\") {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${offset}`);\r\n            }\r\n            else {\r\n                this.svgTextPath.setAttribute(\"startOffset\", `${offset}`);\r\n            }\r\n        }\r\n        else {\r\n            this.svgTextPath.setAttribute(\"startOffset\", `${0}`);\r\n            this.removeTextLengthAttribute();\r\n        }\r\n        return false;\r\n    }\r\n    static getRevString(text) {\r\n        let s = \"\";\r\n        for (let i = text.length - 1; i >= 0; i--) {\r\n            s += text[i];\r\n        }\r\n        return s;\r\n    }\r\n    get pathTextAlignment() {\r\n        const value = this.svgText.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.PathTextAlignment, \"none\");\r\n        return enums_1.PathTextAlighnment.toPathTextAlighnment(value);\r\n    }\r\n    set pathTextAlignment(value) {\r\n        this.svgText.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.PathTextAlignment, value);\r\n    }\r\n    save() {\r\n    }\r\n    setIndexDictionaryForVBA(vertexDic, edgeDic) {\r\n        if (this.controlPoint.length == 0) {\r\n            edgeDic[this.objectID] = Object.keys(edgeDic).length;\r\n        }\r\n        else if (this.controlPoint.length > 0) {\r\n            for (let i = 0; i < this.VBAConnectorNumber; i++) {\r\n                vertexDic[`${this.objectID}_${i}`] = Object.keys(vertexDic).length;\r\n            }\r\n            for (let i = 0; i <= this.VBAConnectorNumber; i++) {\r\n                edgeDic[`${this.objectID}_${i}`] = Object.keys(edgeDic).length;\r\n            }\r\n        }\r\n    }\r\n    static createMark(option = {}) {\r\n        var [marker, path] = svg_1.SVG.createMarker(option);\r\n        if (option.isEnd != undefined && option.isEnd) {\r\n            path.setAttribute(\"transform\", \"rotate(180,5,5)\");\r\n            marker.setAttribute(\"refX\", \"0\");\r\n        }\r\n        marker.id = `marker-${GEdge.markerCounter++}`;\r\n        return marker;\r\n    }\r\n    static createStartMarker(option = {}) {\r\n        const option2 = { className: option.className, strokeWidth: option.strokeWidth, color: option.color, isEnd: true };\r\n        return this.createMark(option2);\r\n    }\r\n    static createEndMarker(option = {}) {\r\n        return this.createMark(option);\r\n    }\r\n    get shape() {\r\n        return \"msoConnectorStraight\";\r\n    }\r\n    createVBACode(id) {\r\n        const lineArr = [];\r\n        const r = [];\r\n        r.push(`Sub create${id}(createdSlide As slide)`);\r\n        r.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        r.push(` Dim obj As Shape`);\r\n        if (this.controlPoint.length == 0) {\r\n            r.push(` Set obj = shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0)`);\r\n            if (this.beginVertex != null && this.endVertex != null) {\r\n                if (this.markerStart != null) {\r\n                    r.push(` obj.Line.BeginArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` obj.Line.BeginArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` obj.Line.BeginArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n                if (this.markerEnd != null) {\r\n                    r.push(` obj.Line.EndArrowheadLength = msoArrowheadLong`);\r\n                    r.push(` obj.Line.EndArrowheadStyle = msoArrowheadTriangle`);\r\n                    r.push(` obj.Line.EndArrowheadWidth = msoArrowheadWide`);\r\n                }\r\n                const begType = enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, this.endVertex.x, this.endVertex.y));\r\n                const endType = enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, this.beginVertex.x, this.beginVertex.y));\r\n                r.push(` Call EditConnector(obj.ConnectorFormat, shapes_(\"${this.beginVertex.objectID}\"), shapes_(\"${this.endVertex.objectID}\"), ${begType}, ${endType})`);\r\n                const lineType = enums_1.msoDashStyle.getLineType(this.svgPath);\r\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(this.svgPath.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                const strokeWidth = parseInt(this.svgPath.getPropertyStyleValueWithDefault(\"stroke-width\", \"4\"));\r\n                const visible = this.svgPath.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n                r.push(` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n            }\r\n        }\r\n        else if (this.controlPoint.length > 0 && this.beginVertex != null && this.endVertex != null) {\r\n            r.push(` Dim nodes(${this.VBAConnectorNumber}) As Shape`);\r\n            for (let j = 0; j < this.VBAConnectorNumber; j++) {\r\n                const t = (j + 1) / (this.VBAConnectorNumber + 1);\r\n                const centerPoint = common_functions_1.CommonFunctions.bezierLocation([this.x1, this.y1], this.controlPoint[0], [this.x2, this.y2], t);\r\n                r.push(`shapes_.AddShape(msoShapeOval, ${centerPoint[0]}, ${centerPoint[1]}, 0, 0).name = \"${this.objectID}_node_${j}\"`);\r\n            }\r\n            for (let j = 0; j <= this.VBAConnectorNumber; j++) {\r\n                const edgeID = `${this.objectID}_edge_${j}`;\r\n                const beg = j == 0 ? this.beginVertex.objectID : `${this.objectID}_node_${j - 1}`;\r\n                const end = j == this.VBAConnectorNumber ? this.endVertex.objectID : `${this.objectID}_node_${j}`;\r\n                r.push(` shapes_.AddConnector(msoConnectorStraight, 0, 0, 0, 0).name = \"${this.objectID}_edge_${j}\"`);\r\n                const lineType = enums_1.msoDashStyle.getLineType(this.svgPath);\r\n                const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(this.svgPath.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                const strokeWidth = parseInt(this.svgPath.getPropertyStyleValueWithDefault(\"stroke-width\", \"4\"));\r\n                const visible = this.svgPath.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n                r.push(` Call EditLine(shapes_(\"${edgeID}\").Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n                const begType = j == 0 ? enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.beginVertex.shape, this.beginVertex.getConnectorType(this.beginConnectorType, this.endVertex.x, this.endVertex.y)) : 1;\r\n                const endType = j == this.VBAConnectorNumber ? enums_1.ConnectorPosition.ToVBAConnectorPosition2(this.endVertex.shape, this.endVertex.getConnectorType(this.endConnectorType, this.beginVertex.x, this.beginVertex.y)) : 1;\r\n                r.push(` Call EditConnector(shapes_(\"${edgeID}\").ConnectorFormat, shapes_(\"${beg}\"), shapes_(\"${end}\"), ${begType}, ${endType})`);\r\n            }\r\n        }\r\n        lineArr.forEach((v) => {\r\n            const lineType = enums_1.msoDashStyle.getLineType(this.svgPath);\r\n            const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(this.svgPath.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n            const strokeWidth = parseInt(this.svgPath.getPropertyStyleValueWithDefault(\"stroke-width\", \"4\"));\r\n            const visible = this.svgPath.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n            r.push(` Call EditLine(edges(${v}).Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`);\r\n        });\r\n        const textCodes = this.createVBACodeOfText(id);\r\n        textCodes.forEach((v, i) => r.push(`Call create${id}_label_${i}(shapes_)`));\r\n        r.push(`End Sub`);\r\n        textCodes.forEach((v) => v.forEach((w) => r.push(w)));\r\n        return r;\r\n    }\r\n    get hasSize() {\r\n        return false;\r\n    }\r\n    createVBACodeOfText(id) {\r\n        const r = [];\r\n        const fontSize = parseInt(this.svgTextPath.getPropertyStyleValueWithDefault(\"font-size\", \"12\"));\r\n        const fontFamily = vba_functions_1.VBATranslateFunctions.ToVBAFont(this.svgTextPath.getPropertyStyleValueWithDefault(\"font-family\", \"MS PGothic\"));\r\n        const fontBold = vba_functions_1.VBATranslateFunctions.ToFontBold(this.svgTextPath.getPropertyStyleValueWithDefault(\"font-weight\", \"none\"));\r\n        if (this.svgTextPath.textContent != null) {\r\n            for (let i = 0; i < this.svgTextPath.textContent.length; i++) {\r\n                const s = new Array(0);\r\n                const p1 = this.svgTextPath.getStartPositionOfChar(i);\r\n                const p2 = this.svgTextPath.getEndPositionOfChar(i);\r\n                const width = Math.abs(p2.x - p1.x);\r\n                const height = Math.abs(p2.y - p1.y);\r\n                const rad = this.svgTextPath.getRotationOfChar(i);\r\n                const diffx = (fontSize * 1 / 2) * Math.sin((rad / 180) * Math.PI);\r\n                const diffy = (fontSize * 3 / 8) + ((fontSize * 3 / 8) * Math.cos((rad / 180) * Math.PI));\r\n                const left = p1.x + diffx;\r\n                const top = p1.y - (fontSize * 1 / 4) - diffy;\r\n                s.push(`Sub create${id}_label_${i}(shapes_ As Shapes)`);\r\n                s.push(`With shapes_.AddTextBox(msoTextOrientationHorizontal, ${left}, ${top},${width},${fontSize})`);\r\n                s.push(`.TextFrame.TextRange.Text = \"${this.svgTextPath.textContent[i]}\"`);\r\n                s.push(`.TextFrame.marginLeft = 0`);\r\n                s.push(`.TextFrame.marginRight = 0`);\r\n                s.push(`.TextFrame.marginTop = 0`);\r\n                s.push(`.TextFrame.marginBottom = 0`);\r\n                s.push(`.TextFrame.TextRange.Font.Size = ${fontSize}`);\r\n                s.push(`.TextFrame.TextRange.Font.name = \"${fontFamily}\"`);\r\n                s.push(`.TextFrame.TextRange.Font.Bold = ${fontBold}`);\r\n                s.push(`.IncrementRotation(${this.svgTextPath.getRotationOfChar(i)})`);\r\n                s.push(`End With`);\r\n                s.push(`End Sub`);\r\n                r.push(s);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\nexports.GEdge = GEdge;\r\nGEdge.connectedBeginVertexDic = {};\r\nGEdge.connectedEndVertexDic = {};\r\nGEdge.markerCounter = 0;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_edge.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_ellipse.ts":
/*!************************************************!*\
  !*** ../GraphTableSVG/src/object/g_ellipse.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"../GraphTableSVG/src/object/g_vertex.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nclass GEllipse extends g_vertex_1.GVertex {\r\n    get svgEllipse() {\r\n        return this._svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (this.type == enums_1.ShapeObjectType.Ellipse)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultSurfaceClass;\r\n        this._svgSurface = GEllipse.createEllipse(this.svgGroup, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgEllipse, this.svgText);\r\n    }\r\n    static createEllipse(parent, className, style) {\r\n        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');\r\n        parent.appendChild(circle);\r\n        if (style !== undefined)\r\n            circle.setAttribute(\"style\", style);\r\n        circle.rx.baseVal.value = custtome_attributes_1.CustomAttributeNames.defaultCircleRadius;\r\n        circle.ry.baseVal.value = custtome_attributes_1.CustomAttributeNames.defaultCircleRadius;\r\n        circle.setAttribute(\"class\", className);\r\n        const radius = circle.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultRadius, null);\r\n        if (radius != null) {\r\n            circle.rx.baseVal.value = radius;\r\n            circle.ry.baseVal.value = radius;\r\n        }\r\n        circle.cx.baseVal.value = 0;\r\n        circle.cy.baseVal.value = 0;\r\n        return circle;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        return output;\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = this.svgEllipse.rx.baseVal.value * 2;\r\n        rect.height = this.svgEllipse.ry.baseVal.value * 2;\r\n        rect.x = -this.svgEllipse.rx.baseVal.value;\r\n        rect.y = -this.svgEllipse.ry.baseVal.value;\r\n        return rect;\r\n    }\r\n    get width() {\r\n        return this.svgEllipse.rx.baseVal.value * 2;\r\n    }\r\n    set width(value) {\r\n        const _rx = value / 2;\r\n        if (this.width != value)\r\n            this.svgEllipse.setAttribute(\"rx\", _rx.toString());\r\n    }\r\n    get height() {\r\n        return this.svgEllipse.ry.baseVal.value * 2;\r\n    }\r\n    set height(value) {\r\n        const _ry = value / 2;\r\n        if (this.height != value)\r\n            this.svgEllipse.setAttribute(\"ry\", _ry.toString());\r\n    }\r\n    get rx() {\r\n        return this.svgEllipse.rx.baseVal.value;\r\n    }\r\n    get ry() {\r\n        return this.svgEllipse.ry.baseVal.value;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Ellipse;\r\n    }\r\n    getLocation(type, x, y) {\r\n        const centerX = (Math.sqrt(2) / 2) * this.svgEllipse.rx.baseVal.value;\r\n        const centerY = (Math.sqrt(2) / 2) * this.svgEllipse.ry.baseVal.value;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - this.ry];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n                return [this.cx + centerX, this.cy - centerY];\r\n            case enums_1.ConnectorPosition.Right:\r\n                return [this.cx + this.rx, this.cy];\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + centerX, this.cy + centerY];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + this.ry];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n                return [this.cx - centerX, this.cy + centerY];\r\n            case enums_1.ConnectorPosition.Left:\r\n                return [this.cx - this.rx, this.cy];\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - centerX, this.cy - centerY];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const radius = this.rx;\r\n        const r = (Math.sqrt(2) / 2) * radius;\r\n        const line1 = new vline_1.VLine(this.x, this.y, this.x + r, this.y + r);\r\n        const line2 = new vline_1.VLine(this.x, this.y, this.x + r, this.y - r);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n    get shape() {\r\n        return \"msoShapeOval\";\r\n    }\r\n}\r\nexports.GEllipse = GEllipse;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_ellipse.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_graph.ts":
/*!**********************************************!*\
  !*** ../GraphTableSVG/src/object/g_graph.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"../GraphTableSVG/src/object/g_vertex.ts\");\r\nconst g_edge_1 = __webpack_require__(/*! ./g_edge */ \"../GraphTableSVG/src/object/g_edge.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst open_svg_1 = __webpack_require__(/*! ../options/open_svg */ \"../GraphTableSVG/src/options/open_svg.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst logic_tree_1 = __webpack_require__(/*! ../options/logic_tree */ \"../GraphTableSVG/src/options/logic_tree.ts\");\r\nclass GGraph extends g_object_1.GObject {\r\n    constructor(box, option = {}) {\r\n        super(box, option);\r\n        this._roots = [];\r\n        this.objectCreatedFunction = (e) => {\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(e.target);\r\n            if (obj instanceof g_vertex_1.GVertex) {\r\n                this.dispatchVertexCreatedEvent(obj);\r\n            }\r\n            else if (obj instanceof g_edge_1.GEdge) {\r\n            }\r\n            else {\r\n            }\r\n        };\r\n        if (this.type == enums_1.ShapeObjectType.Graph)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    get vertices() {\r\n        const r = [];\r\n        html_functions_1.HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName)).forEach((v) => {\r\n            const item = g_object_1.GObject.getObjectFromObjectID(v.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName));\r\n            if (item instanceof g_vertex_1.GVertex) {\r\n                r.push(item);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get edges() {\r\n        const r = [];\r\n        html_functions_1.HTMLFunctions.getChildren(this.svgGroup).filter((v) => v.hasAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName)).forEach((v) => {\r\n            const item = g_object_1.GObject.getObjectFromObjectID(v.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName));\r\n            if (item instanceof g_edge_1.GEdge) {\r\n                r.push(item);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get roots() {\r\n        return this.vertices.filter((v) => v.incomingEdges.length == 0);\r\n    }\r\n    get vertexXInterval() {\r\n        const v = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.vertexXInterval);\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return parseInt(v);\r\n        }\r\n    }\r\n    set vertexXInterval(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.vertexXInterval, value == null ? null : value.toString());\r\n    }\r\n    get vertexYInterval() {\r\n        const v = this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.vertexYInterval);\r\n        if (v == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return parseInt(v);\r\n        }\r\n    }\r\n    set vertexYInterval(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.vertexYInterval, value == null ? null : value.toString());\r\n    }\r\n    get rootVertex() {\r\n        if (this.roots.length == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.roots[0];\r\n        }\r\n    }\r\n    add(item) {\r\n        if (item instanceof g_vertex_1.GVertex) {\r\n            this.svgGroup.insertBefore(item.svgGroup, this.svgGroup.firstChild);\r\n        }\r\n        else {\r\n            this.svgGroup.appendChild(item.svgGroup);\r\n        }\r\n    }\r\n    remove(item) {\r\n        this.svgGroup.removeChild(item.svgGroup);\r\n        item.dispose();\r\n    }\r\n    clear() {\r\n        while (this.edges.length > 0) {\r\n            this.remove(this.edges[0]);\r\n        }\r\n        while (this.vertices.length > 0) {\r\n            this.remove(this.vertices[0]);\r\n        }\r\n    }\r\n    connect(beginVertex, edge, endVertex, option = {}) {\r\n        const oIndex = option.outcomingInsertIndex == undefined ? beginVertex.outcomingEdges.length : option.outcomingInsertIndex;\r\n        const iIndex = option.incomingInsertIndex == undefined ? endVertex.incomingEdges.length : option.incomingInsertIndex;\r\n        beginVertex.insertOutcomingEdge(edge, oIndex);\r\n        endVertex.insertIncomingEdge(edge, iIndex);\r\n        const i = this.roots.indexOf(beginVertex);\r\n        const j = this.roots.indexOf(endVertex);\r\n        if (j != -1) {\r\n            if (i == -1) {\r\n                this.roots[j] = beginVertex;\r\n            }\r\n            else {\r\n                this.roots.splice(j, 1);\r\n            }\r\n        }\r\n        if (option.beginConnectorType != undefined)\r\n            edge.beginConnectorType = option.beginConnectorType;\r\n        if (option.endConnectorType != undefined)\r\n            edge.endConnectorType = option.endConnectorType;\r\n    }\r\n    getOrderedVertices(order, node = null) {\r\n        const r = [];\r\n        if (node == null) {\r\n            this.roots.forEach((v) => {\r\n                this.getOrderedVertices(order, v).forEach((w) => {\r\n                    r.push(w);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            const edges = node.outcomingEdges;\r\n            if (order == enums_1.VertexOrder.Preorder) {\r\n                r.push(node);\r\n                edges.forEach((v) => {\r\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                });\r\n            }\r\n            else if (order == enums_1.VertexOrder.Postorder) {\r\n                edges.forEach((v) => {\r\n                    this.getOrderedVertices(order, v.endVertex).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                });\r\n                r.push(node);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    appendChild(parent, child, option = {}) {\r\n        const _child = child == null ? open_svg_1.createVertex(this) : child;\r\n        const edge = open_svg_1.createShape(this, 'g-edge');\r\n        this.connect(parent, edge, _child, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\r\n        this.relocate();\r\n    }\r\n    get relocateStyle() {\r\n        return this.svgGroup.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.relocateName);\r\n    }\r\n    set relocateStyle(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.relocateName, value);\r\n    }\r\n    relocate() {\r\n        const value = this.relocateStyle;\r\n        if (value != null) {\r\n            const p = Function(\"v\", `return ${value}(v)`);\r\n            const f = Function(\"graph\", `${value}(graph)`);\r\n            f(this);\r\n        }\r\n    }\r\n    get width() {\r\n        return this.Noderegion().width;\r\n    }\r\n    get height() {\r\n        return this.Noderegion().height;\r\n    }\r\n    set width(value) {\r\n    }\r\n    set height(value) {\r\n    }\r\n    Noderegion() {\r\n        const _x = this.svgGroup.getX();\r\n        const _y = this.svgGroup.getY();\r\n        let left = _x;\r\n        let right = _y;\r\n        let top = _x;\r\n        let bottom = _y;\r\n        this.vertices.forEach((v) => {\r\n            const x = v.x + _x;\r\n            const y = v.y + _y;\r\n            if (x < left)\r\n                left = x;\r\n            if (right < (x + v.width))\r\n                right = x + v.width;\r\n            if (y < top)\r\n                top = y;\r\n            if (bottom < (y + v.height))\r\n                bottom = y + v.height;\r\n        });\r\n        return new vline_1.Rectangle(left, top, right - left, bottom - top);\r\n    }\r\n    moveInCanvas() {\r\n        const rect = this.Noderegion();\r\n        if (rect.x < 0) {\r\n            this.x = this.x - (rect.x);\r\n        }\r\n        if (rect.y < 0) {\r\n            this.y = this.y - (rect.y);\r\n        }\r\n    }\r\n    build(graph, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        this.clear();\r\n        const svgsvg = svg_1.SVG.getSVGSVG(this.svgGroup);\r\n        if (graph instanceof logic_tree_1.LogicGraph) {\r\n            const dic = new Map();\r\n            graph.nodes.forEach((v, i) => {\r\n                const node = open_svg_1.createShape(svgsvg, \"g-ellipse\");\r\n                node.svgText.textContent = v.text;\r\n                this.add(node);\r\n                dic.set(i, node);\r\n            });\r\n            graph.nodes.forEach((v, i) => {\r\n                v.outputEdges.forEach((e, j) => {\r\n                    const edge = open_svg_1.createShape(svgsvg, \"g-edge\");\r\n                    if (e.text != undefined) {\r\n                        const b = option.isLatexMode == undefined ? false : option.isLatexMode;\r\n                        edge.svgTextPath.setTextContent(e.text, b);\r\n                    }\r\n                    this.add(edge);\r\n                    const beginNode = dic.get(i);\r\n                    const endNode = dic.get(e.endNodeIndex);\r\n                    if (beginNode == undefined || endNode == undefined)\r\n                        throw Error(\"error\");\r\n                    this.connect(beginNode, edge, endNode);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            const dic = new Map();\r\n            graph.getOrderedNodes(enums_1.VertexOrder.Preorder).forEach((v, i) => {\r\n                const node = open_svg_1.createShape(svgsvg, \"g-ellipse\");\r\n                node.svgText.textContent = v.vertexText;\r\n                this.add(node);\r\n                dic.set(v, node);\r\n            });\r\n            graph.getOrderedNodes(enums_1.VertexOrder.Preorder).forEach((v, i) => {\r\n                v.children.forEach((e, j) => {\r\n                    if (e != null) {\r\n                        const edge = open_svg_1.createShape(svgsvg, \"g-edge\");\r\n                        if (e.parentEdgeText != null) {\r\n                            const b = option.isLatexMode == undefined ? false : option.isLatexMode;\r\n                            edge.svgTextPath.setTextContent(e.parentEdgeText, b);\r\n                            edge.isAppropriatelyReverseMode = true;\r\n                        }\r\n                        this.add(edge);\r\n                        const beginNode = dic.get(v);\r\n                        const endNode = dic.get(e);\r\n                        if (beginNode == undefined || endNode == undefined)\r\n                            throw Error(\"error\");\r\n                        this.connect(beginNode, edge, endNode);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        this.relocateStyle = \"GraphTableSVG.GraphArrangement.standardTreeWidthArrangement\";\r\n        if (option.x != undefined)\r\n            this.svgGroup.setX(option.x);\r\n        if (option.y != undefined)\r\n            this.svgGroup.setY(option.y);\r\n    }\r\n    constructFromLogicTree(roots, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        if (roots instanceof Array) {\r\n            this.clear();\r\n            roots.forEach((v) => {\r\n                if (v != null) {\r\n                    this.createChildFromLogicTree(null, v, option);\r\n                }\r\n            });\r\n            this.relocate();\r\n        }\r\n        else {\r\n            this.constructFromLogicTree([roots], option);\r\n        }\r\n        if (option.x != undefined)\r\n            this.svgGroup.setX(option.x);\r\n        if (option.y != undefined)\r\n            this.svgGroup.setY(option.y);\r\n    }\r\n    removeGraph(svg) {\r\n        if (svg.contains(this.svgGroup)) {\r\n            svg.removeChild(this.svgGroup);\r\n        }\r\n    }\r\n    getRegion() {\r\n        const rects = this.vertices.map((v) => v.region);\r\n        const rect = vline_1.Rectangle.merge(rects);\r\n        rect.addOffset(this.svgGroup.getX(), this.svgGroup.getY());\r\n        return rect;\r\n    }\r\n    createChildFromLogicTree(parent = null, logicVertex, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        const node = open_svg_1.createVertex(this, { class: logicVertex.vertexClass == null ? undefined : logicVertex.vertexClass });\r\n        if (logicVertex.vertexText != null)\r\n            svg_textbox_1.SVGTextBox.setTextToSVGText(node.svgText, logicVertex.vertexText, option.isLatexMode);\r\n        if (parent != null) {\r\n            const edge = open_svg_1.createShape(this, 'g-edge', { class: logicVertex.parentEdgeClass });\r\n            if (logicVertex.parentEdgeText != null) {\r\n                edge.svgTextPath.setTextContent(logicVertex.parentEdgeText, option.isLatexMode);\r\n                edge.pathTextAlignment = enums_1.PathTextAlighnment.regularInterval;\r\n            }\r\n            this.connect(parent, edge, node, { beginConnectorType: \"bottom\", endConnectorType: \"top\" });\r\n        }\r\n        else {\r\n            this.roots.push(node);\r\n        }\r\n        logicVertex.children.forEach((v) => {\r\n            if (v != null)\r\n                this.createChildFromLogicTree(node, v, option);\r\n        });\r\n        return node;\r\n    }\r\n    createVBACode(id) {\r\n        const r = [];\r\n        this.vertices.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\r\n        this.edges.forEach((v) => v.createVBACode(id++).forEach((w) => r.push(w)));\r\n        return r;\r\n    }\r\n    get VBAObjectNum() {\r\n        return this.vertices.length + this.edges.length;\r\n    }\r\n    getStyleValue(className, valueName) {\r\n        if (this.svgGroup.hasAttribute(\"class\")) {\r\n            const oldClass = this.svgGroup.getAttribute(\"class\");\r\n            this.svgGroup.setAttribute(\"class\", className);\r\n            const r = this.svgGroup.getPropertyStyleValue(valueName);\r\n            this.svgGroup.setAttribute(\"class\", oldClass);\r\n            return r;\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"class\", className);\r\n            const r = this.svgGroup.getPropertyStyleValue(valueName);\r\n            this.svgGroup.removeAttribute(\"class\");\r\n            return r;\r\n        }\r\n    }\r\n    dispatchVertexCreatedEvent(vertex) {\r\n        var event = document.createEvent(\"HTMLEvents\");\r\n        event.initEvent(custtome_attributes_1.CustomAttributeNames.vertexCreatedEventName, true, true);\r\n        vertex.svgGroup.dispatchEvent(event);\r\n    }\r\n    setRootIndex(vertex, rootIndex) {\r\n        if (vertex.graph == this) {\r\n            if (rootIndex < this.roots.length) {\r\n                this.svgGroup.insertBefore(vertex.svgGroup, this.roots[rootIndex].svgGroup);\r\n            }\r\n            else {\r\n                if (this.roots.length == 0) {\r\n                    if (this.svgGroup.firstChild == null) {\r\n                        this.svgGroup.appendChild(vertex.svgGroup);\r\n                    }\r\n                    else {\r\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.svgGroup.firstChild);\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.roots[this.roots.length - 1].svgGroup.nextSibling == null) {\r\n                        this.svgGroup.appendChild(vertex.svgGroup);\r\n                    }\r\n                    else {\r\n                        this.svgGroup.insertBefore(vertex.svgGroup, this.roots[this.roots.length - 1].svgGroup.nextSibling);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw Error(\"error!\");\r\n        }\r\n    }\r\n    observerFunction(x) {\r\n        super.observerFunction(x);\r\n        for (let i = 0; i < x.length; i++) {\r\n            const p = x[i];\r\n            if (p.attributeName == \"style\") {\r\n                this.relocate();\r\n            }\r\n        }\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Graph;\r\n    }\r\n    resizeUpdate() {\r\n        this.relocate();\r\n    }\r\n}\r\nexports.GGraph = GGraph;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_graph.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_object.ts":
/*!***********************************************!*\
  !*** ../GraphTableSVG/src/object/g_object.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ../basic/svghtml/interface */ \"../GraphTableSVG/src/basic/svghtml/interface.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ../basic/common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst gui_observer_1 = __webpack_require__(/*! ../basic/svghtml/gui_observer */ \"../GraphTableSVG/src/basic/svghtml/gui_observer.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst draggable_object_1 = __webpack_require__(/*! ../basic/svghtml/draggable_object */ \"../GraphTableSVG/src/basic/svghtml/draggable_object.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nclass GObject {\r\n    constructor(svgbox, option = {}) {\r\n        this._svgSurface = null;\r\n        this._isInitialized = false;\r\n        this.groupObserverOption = { attributes: true, childList: true, subtree: true };\r\n        this.pUpdateFunc = () => {\r\n            this.resizeUpdate();\r\n        };\r\n        this.observerFunc = (x) => {\r\n            this.observerFunction(x);\r\n        };\r\n        this._isUpdating = false;\r\n        this.updateAttributes = [\"style\", \"transform\", \"data-speaker-x\", \"data-speaker-y\",\r\n            \"data-width\", \"data-height\", \"data-arrow-neck-width\", \"data-arrow-neck-height\",\r\n            \"data-arrow-head-width\", \"data-arrow-head-height\"];\r\n        common_functions_1.CommonFunctions.setGraphTableCSS();\r\n        let parentElement = svgbox instanceof SVGElement ? svgbox : document.getElementById(svgbox);\r\n        if (parentElement instanceof SVGSVGElement && !gui_observer_1.GUIObserver.isObserved(parentElement)) {\r\n            gui_observer_1.GUIObserver.observeSVGSVG(parentElement);\r\n        }\r\n        this._svgGroup = svg_1.SVG.createGroup(parentElement);\r\n        if (option.class !== undefined) {\r\n            this._svgGroup.setAttribute(\"class\", option.class);\r\n        }\r\n        else if (this.defaultClassName !== undefined) {\r\n            this._svgGroup.setAttribute(\"class\", this.defaultClassName);\r\n        }\r\n        if (option.style !== undefined)\r\n            this._svgGroup.setAttribute(\"style\", option.style);\r\n        GObject.setObjectFromObjectID(this);\r\n        this.svgGroup.operator = this;\r\n        this.svgGroup.setAttribute(custtome_attributes_1.CustomAttributeNames.GroupAttribute, this.type);\r\n        const _option = this.initializeOption(option);\r\n        this.createSurface(parentElement, _option);\r\n        if (typeof _option.id !== \"undefined\")\r\n            this.svgGroup.id = _option.id;\r\n        this.width = _option.width;\r\n        this.height = _option.height;\r\n        this._observer = new MutationObserver(this.observerFunc);\r\n        this._observerOption = { attributes: true, childList: true, subtree: true };\r\n        this._observer.observe(this.svgGroup, this._observerOption);\r\n        this.dispatchObjectCreatedEvent();\r\n        this.addResizeEvent();\r\n        this.__x = option.x;\r\n        this.__y = option.y;\r\n        this.__cx = option.cx;\r\n        this.__cy = option.cy;\r\n        const __svg = this.svgGroup;\r\n        __svg.operator = this;\r\n        if (this.type == enums_1.ShapeObjectType.Object)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    get defaultClassName() {\r\n        return undefined;\r\n    }\r\n    get isInitialized() {\r\n        return this._isInitialized;\r\n    }\r\n    firstFunctionAfterInitialized() {\r\n        if (this._isInitialized) {\r\n            throw new Error(\"This function is already called\");\r\n        }\r\n        this._isInitialized = true;\r\n        this.update();\r\n        if (this.__cx !== undefined)\r\n            this.cx = this.__cx;\r\n        if (this.__cy !== undefined)\r\n            this.cy = this.__cy;\r\n        if (this.__x !== undefined)\r\n            this.x = this.__x;\r\n        if (this.__y !== undefined)\r\n            this.y = this.__y;\r\n    }\r\n    removeResizeEvent() {\r\n        this.svgGroup.removeEventListener(custtome_attributes_1.CustomAttributeNames.resizeName, this.pUpdateFunc);\r\n    }\r\n    addResizeEvent() {\r\n        this.svgGroup.addEventListener(custtome_attributes_1.CustomAttributeNames.resizeName, this.pUpdateFunc);\r\n    }\r\n    firstResizeUpdate() {\r\n    }\r\n    resizeUpdate() {\r\n        this.update();\r\n    }\r\n    initializeOption(option) {\r\n        const _option = Object.assign({}, option);\r\n        if (this.svgSurface != null && this.svgSurface.className != null) {\r\n            const width = this.svgSurface.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultWidth, null);\r\n            const height = this.svgSurface.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultHeight, null);\r\n            if (width != null)\r\n                _option.width = width;\r\n            if (height != null)\r\n                _option.height = height;\r\n        }\r\n        if (_option.width === undefined)\r\n            _option.width = 25;\r\n        if (_option.height === undefined)\r\n            _option.height = 25;\r\n        if (_option.cx === undefined)\r\n            _option.cx = 0;\r\n        if (_option.cy === undefined)\r\n            _option.cy = 0;\r\n        if (_option.surfaceClass === undefined)\r\n            _option.surfaceClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultSurfaceClass;\r\n        return _option;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        output.class = e.gtGetAttributeStringWithUndefined(\"class\");\r\n        if (output.class === undefined)\r\n            e.gtGetAttributeStringWithUndefined(\"group:class\");\r\n        output.surfaceClass = e.gtGetAttributeStringWithUndefined(\"surface:class\");\r\n        output.style = e.gtGetAttributeStringWithUndefined(\"group:style\");\r\n        if (e.hasAttribute(\"style\"))\r\n            output.style = e.gtGetAttributeStringWithUndefined(\"style\");\r\n        output.surfaceStyle = e.gtGetAttributeStringWithUndefined(\"surface:style\");\r\n        output.cx = e.gtGetAttributeNumberWithUndefined(\"cx\");\r\n        output.cy = e.gtGetAttributeNumberWithUndefined(\"cy\");\r\n        output.width = e.gtGetAttributeNumberWithUndefined(\"width\");\r\n        output.height = e.gtGetAttributeNumberWithUndefined(\"height\");\r\n        output.x = e.gtGetAttributeNumberWithUndefined(\"x\");\r\n        output.y = e.gtGetAttributeNumberWithUndefined(\"y\");\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"cx\");\r\n            e.removeAttribute(\"cy\");\r\n            e.removeAttribute(\"x\");\r\n            e.removeAttribute(\"y\");\r\n            e.removeAttribute(\"class\");\r\n            e.removeAttribute(\"surface:class\");\r\n            e.removeAttribute(\"group:class\");\r\n            e.removeAttribute(\"surface:style\");\r\n            e.removeAttribute(\"group:style\");\r\n            e.removeAttribute(\"style\");\r\n            e.removeAttribute(\"width\");\r\n            e.removeAttribute(\"height\");\r\n        }\r\n        return output;\r\n    }\r\n    get tag() {\r\n        return this._tag;\r\n    }\r\n    set tag(v) {\r\n        this._tag = v;\r\n    }\r\n    get isShow() {\r\n        return html_functions_1.HTMLFunctions.isShow(this.svgGroup);\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get isLocated() {\r\n        return common_functions_1.CommonFunctions.IsDescendantOfBody(this.svgGroup);\r\n    }\r\n    get svgSurface() {\r\n        return this._svgSurface;\r\n    }\r\n    get cx() {\r\n        if (this.isCenterBased) {\r\n            return this.svgGroup.getX();\r\n        }\r\n        else {\r\n            return this.svgGroup.getX() + (this.width / 2);\r\n        }\r\n    }\r\n    set cx(value) {\r\n        if (this.isCenterBased) {\r\n            if (this.svgGroup.getX() != value) {\r\n                this.svgGroup.setX(value);\r\n            }\r\n        }\r\n        else {\r\n            this.svgGroup.setX(value - (this.width / 2));\r\n        }\r\n    }\r\n    get cy() {\r\n        if (this.isCenterBased) {\r\n            return this.svgGroup.getY();\r\n        }\r\n        else {\r\n            return this.svgGroup.getY() + (this.height / 2);\r\n        }\r\n    }\r\n    set cy(value) {\r\n        if (this.isCenterBased) {\r\n            if (this.svgGroup.getY() != value) {\r\n                this.svgGroup.setY(value);\r\n            }\r\n        }\r\n        else {\r\n            this.svgGroup.setY(value - (this.height / 2));\r\n        }\r\n    }\r\n    get width() {\r\n        if (this.hasSize) {\r\n            return this.svgGroup.gtGetAttributeNumber(\"data-width\", 0);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    set width(value) {\r\n        if (this.hasSize) {\r\n            if (this.width != value && value != null)\r\n                this.svgGroup.setAttribute(\"data-width\", value.toString());\r\n        }\r\n    }\r\n    get height() {\r\n        if (this.hasSize) {\r\n            return this.svgGroup.gtGetAttributeNumber(\"data-height\", 0);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    set height(value) {\r\n        if (this.hasSize) {\r\n            if (this.height != value && value != null)\r\n                this.svgGroup.setAttribute(\"data-height\", value.toString());\r\n        }\r\n    }\r\n    get fixedX() {\r\n        return this.svgGroup.gtGetAttributeNumber(\"data-fixedX\", null);\r\n    }\r\n    set fixedX(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(\"data-fixedX\");\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"data-fixedX\", v.toString());\r\n        }\r\n    }\r\n    get fixedY() {\r\n        return this.svgGroup.gtGetAttributeNumber(\"data-fixedY\", null);\r\n    }\r\n    set fixedY(v) {\r\n        if (v == null) {\r\n            this.svgGroup.removeAttribute(\"data-fixedY\");\r\n        }\r\n        else {\r\n            this.svgGroup.setAttribute(\"data-fixedY\", v.toString());\r\n        }\r\n    }\r\n    get isCenterBased() {\r\n        return true;\r\n    }\r\n    get x() {\r\n        if (this.isCenterBased) {\r\n            return this.svgGroup.getX() - (this.width / 2);\r\n        }\r\n        else {\r\n            return this.svgGroup.getX();\r\n        }\r\n    }\r\n    get y() {\r\n        if (this.isCenterBased) {\r\n            return this.cy - (this.height / 2);\r\n        }\r\n        else {\r\n            return this.svgGroup.getY();\r\n        }\r\n    }\r\n    set x(v) {\r\n        if (this.isCenterBased) {\r\n            this.svgGroup.setX(v + (this.width / 2));\r\n        }\r\n        else {\r\n            this.svgGroup.setX(v);\r\n        }\r\n    }\r\n    set y(v) {\r\n        if (this.isCenterBased) {\r\n            this.svgGroup.setY(v + (this.height / 2));\r\n        }\r\n        else {\r\n            this.svgGroup.setY(v);\r\n        }\r\n    }\r\n    get isProhibitionOutOfRange() {\r\n        const p = this.svgGroup.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.prohibitionOutOfRange, \"true\");\r\n        return p == \"true\";\r\n    }\r\n    set isProhibitionOutOfRange(v) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.prohibitionOutOfRange, v.toString());\r\n    }\r\n    moveInCanvas() {\r\n        this.x = (this.width / 2) + 10;\r\n        this.y = (this.height / 2) + 10;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Object;\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n    }\r\n    setClassNameOfSVGGroup() {\r\n    }\r\n    observerFunction(x) {\r\n        let b = false;\r\n        if (!this.isLocated)\r\n            return;\r\n        for (let i = 0; i < x.length; i++) {\r\n            const p = x[i];\r\n            if (this.updateAttributes.some((v) => v == p.attributeName)) {\r\n                b = true;\r\n            }\r\n            if (p.target == this.svgGroup) {\r\n                if (p.attributeName == \"x\" || p.attributeName == \"y\") {\r\n                    this.dispatchConnectPositionChangedEvent();\r\n                }\r\n            }\r\n            if (p.attributeName == \"transform\") {\r\n                this.dispatchConnectPositionChangedEvent();\r\n            }\r\n        }\r\n        if (b)\r\n            this.update();\r\n    }\r\n    dispose() {\r\n    }\r\n    get isDisposed() {\r\n        return false;\r\n    }\r\n    get objectID() {\r\n        const r = this.svgGroup.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName);\r\n        if (r == null) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            return r;\r\n        }\r\n    }\r\n    createVBACode(id) {\r\n        const lines = [];\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(`End Sub`);\r\n        return lines;\r\n    }\r\n    get VBAObjectNum() {\r\n        return 1;\r\n    }\r\n    dispatchObjectCreatedEvent() {\r\n        var event = document.createEvent(\"HTMLEvents\");\r\n        event.initEvent(custtome_attributes_1.CustomAttributeNames.objectCreatedEventName, true, true);\r\n        this.svgGroup.dispatchEvent(event);\r\n    }\r\n    update() {\r\n        if (!this._isInitialized) {\r\n        }\r\n        else {\r\n            this._isUpdating = true;\r\n            this._isUpdating = false;\r\n        }\r\n    }\r\n    dispatchConnectPositionChangedEvent() {\r\n        if (this.svgSurface != null) {\r\n            var event = document.createEvent(\"HTMLEvents\");\r\n            event.initEvent(custtome_attributes_1.CustomAttributeNames.connectPositionChangedEventName, false, true);\r\n            this.svgGroup.dispatchEvent(event);\r\n        }\r\n    }\r\n    get hasSize() {\r\n        return false;\r\n    }\r\n    static getObjectFromObjectID(id) {\r\n        if (id instanceof SVGElement) {\r\n            if (id.hasAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName)) {\r\n                const _id = id.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName);\r\n                return GObject.getObjectFromObjectID(_id);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            if (id in this.objectDic) {\r\n                return this.objectDic[id];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    static setObjectFromObjectID(obj) {\r\n        const id = obj.objectID;\r\n        this.objectDic[id] = obj;\r\n    }\r\n    static getObjectFromID(id) {\r\n        for (let key in this.objectDic) {\r\n            if (this.objectDic[key].svgGroup.id == id) {\r\n                return this.objectDic[key];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getRegion() {\r\n        let rect = new vline_1.Rectangle();\r\n        rect.x = this.x;\r\n        rect.y = this.y;\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        return rect;\r\n    }\r\n    movable() {\r\n        draggable_object_1.DraggableObjectFunctions.appendDragFunctionsToDocument();\r\n        draggable_object_1.DraggableObjectFunctions.draggable(this.svgSurface, this.svgGroup);\r\n    }\r\n}\r\nexports.GObject = GObject;\r\nGObject.objectDic = {};\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_object.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_path_textbox.ts":
/*!*****************************************************!*\
  !*** ../GraphTableSVG/src/object/g_path_textbox.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"../GraphTableSVG/src/object/g_vertex.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nclass GPathTextBox extends g_vertex_1.GVertex {\r\n    get svgPath() {\r\n        return this.svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (this.type == enums_1.ShapeObjectType.PathTextBox)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        if (option.surfaceClass === undefined)\r\n            option.surfaceClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextboxPathClass;\r\n        this._svgSurface = GPathTextBox.createSurfacePath(this.svgGroup, 0, 0, 0, 0, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgPath, this.svgText);\r\n    }\r\n    static createSurfacePath(parent, x, y, x2, y2, className, style) {\r\n        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n        parent.appendChild(path);\r\n        path.setAttribute(\"d\", `M ${x} ${y} L ${x2} ${y2}`);\r\n        if (style !== undefined)\r\n            path.setAttribute(\"style\", style);\r\n        path.setAttribute(\"class\", className);\r\n        return path;\r\n    }\r\n    initializeOption(option) {\r\n        const _option = super.initializeOption(option);\r\n        return _option;\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        if (this.isAutoSizeShapeToFitText) {\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n            rect.width = textRect.width;\r\n            rect.height = textRect.height;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        else {\r\n            rect.width = this.width - this.marginPaddingLeft;\r\n            rect.height = this.height - this.marginPaddingTop;\r\n            rect.x = (-this.width / 2) + this.marginPaddingLeft;\r\n            rect.y = (-this.height / 2) + this.marginPaddingTop;\r\n        }\r\n        return rect;\r\n    }\r\n    get type() {\r\n        return \"g-path-textbox\";\r\n    }\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + wr, this.cy];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - wr, this.cy];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\r\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GPathTextBox = GPathTextBox;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_path_textbox.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_rect.ts":
/*!*********************************************!*\
  !*** ../GraphTableSVG/src/object/g_rect.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_vertex_1 = __webpack_require__(/*! ./g_vertex */ \"../GraphTableSVG/src/object/g_vertex.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nclass GRect extends g_vertex_1.GVertex {\r\n    get svgRectangle() {\r\n        return this._svgSurface;\r\n    }\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this.updateAttributes.push(\"width\");\r\n        this.updateAttributes.push(\"height\");\r\n        if (this.type == enums_1.ShapeObjectType.Rect)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    createSurface(svgbox, option = {}) {\r\n        this._svgSurface = GRect.createRectangle(this.svgGroup, option.surfaceClass, option.surfaceStyle);\r\n        this.svgGroup.insertBefore(this.svgRectangle, this.svgText);\r\n    }\r\n    static createRectangle(parent, className, style) {\r\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n        parent.appendChild(rect);\r\n        rect.width.baseVal.value = 30;\r\n        rect.height.baseVal.value = 30;\r\n        if (style !== undefined)\r\n            rect.setAttribute(\"style\", style);\r\n        if (className == null) {\r\n            if (rect.style.stroke == null || rect.style.stroke == \"\")\r\n                rect.style.stroke = \"black\";\r\n            if (rect.style.fill == null || rect.style.fill == \"\")\r\n                rect.style.fill = \"white\";\r\n            if (rect.style.strokeWidth == null || rect.style.strokeWidth == \"\")\r\n                rect.style.strokeWidth = \"1pt\";\r\n        }\r\n        else {\r\n            rect.setAttribute(\"class\", className);\r\n            const width = rect.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultWidth, null);\r\n            if (width != null) {\r\n                rect.width.baseVal.value = width;\r\n            }\r\n            const height = rect.getPropertyStyleNumberValue(custtome_attributes_1.CustomAttributeNames.Style.defaultHeight, null);\r\n            if (height != null) {\r\n                rect.height.baseVal.value = height;\r\n            }\r\n        }\r\n        return rect;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_textbox_1.GTextBox.constructAttributes(e, removeAttributes, output);\r\n        return output;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Rect;\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        rect.x = (-this.width / 2);\r\n        rect.y = (-this.height / 2);\r\n        return rect;\r\n    }\r\n    get width() {\r\n        return this.svgRectangle.width.baseVal.value;\r\n    }\r\n    set width(value) {\r\n        if (this.width != value)\r\n            this.svgRectangle.setAttribute(\"width\", value.toString());\r\n    }\r\n    get height() {\r\n        return this.svgRectangle.height.baseVal.value;\r\n    }\r\n    set height(value) {\r\n        if (this.height != value)\r\n            this.svgRectangle.setAttribute(\"height\", value.toString());\r\n    }\r\n    updateSurface() {\r\n        this.svgRectangle.x.baseVal.value = -this.width / 2;\r\n        this.svgRectangle.y.baseVal.value = -this.height / 2;\r\n        this._observer.disconnect();\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null) {\r\n            enums_1.msoDashStyle.setCpmoutedDashArray(this.svgRectangle);\r\n        }\r\n        this._observer.observe(this.svgGroup, this._observerOption);\r\n    }\r\n    getLocation(type, x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        switch (type) {\r\n            case enums_1.ConnectorPosition.Top:\r\n                return [this.cx, this.cy - hr];\r\n            case enums_1.ConnectorPosition.TopRight:\r\n            case enums_1.ConnectorPosition.Right:\r\n            case enums_1.ConnectorPosition.BottomRight:\r\n                return [this.cx + wr, this.cy];\r\n            case enums_1.ConnectorPosition.Bottom:\r\n                return [this.cx, this.cy + hr];\r\n            case enums_1.ConnectorPosition.BottomLeft:\r\n            case enums_1.ConnectorPosition.Left:\r\n            case enums_1.ConnectorPosition.TopLeft:\r\n                return [this.cx - wr, this.cy];\r\n            default:\r\n                const autoType = this.getAutoPosition(x, y);\r\n                return this.getLocation(autoType, x, y);\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        const wr = this.width / 2;\r\n        const hr = this.height / 2;\r\n        const line1 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy + hr);\r\n        const line2 = new vline_1.VLine(this.cx, this.cy, this.cx + wr, this.cy - hr);\r\n        const b1 = line1.contains(x, y);\r\n        const b2 = line2.contains(x, y);\r\n        if (b1) {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Top;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Right;\r\n            }\r\n        }\r\n        else {\r\n            if (b2) {\r\n                return enums_1.ConnectorPosition.Left;\r\n            }\r\n            else {\r\n                return enums_1.ConnectorPosition.Bottom;\r\n            }\r\n        }\r\n    }\r\n    get shape() {\r\n        return \"msoShapeRectangle\";\r\n    }\r\n}\r\nexports.GRect = GRect;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_rect.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_rect_button.ts":
/*!****************************************************!*\
  !*** ../GraphTableSVG/src/object/g_rect_button.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst g_rect_1 = __webpack_require__(/*! ./g_rect */ \"../GraphTableSVG/src/object/g_rect.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nclass GRectButton extends g_rect_1.GRect {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        if (this.type == enums_1.ShapeObjectType.RectButton)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    initializeOption(option) {\r\n        let b = false;\r\n        if (option.width !== undefined || option.height !== undefined) {\r\n            b = true;\r\n        }\r\n        if (option.surfaceClass === undefined) {\r\n            option.surfaceClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultRectButtonSurfaceClass;\r\n        }\r\n        const _option = super.initializeOption(option);\r\n        return _option;\r\n    }\r\n    get defaultClassName() {\r\n        return undefined;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.RectButton;\r\n    }\r\n}\r\nexports.GRectButton = GRectButton;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_rect_button.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_table.ts":
/*!**********************************************!*\
  !*** ../GraphTableSVG/src/object/g_table.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst color_1 = __webpack_require__(/*! ../basic/common/color */ \"../GraphTableSVG/src/basic/common/color.ts\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ../basic/common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst logic_table_1 = __webpack_require__(/*! ../options/logic_table */ \"../GraphTableSVG/src/options/logic_table.ts\");\r\nconst row_1 = __webpack_require__(/*! ./table/row */ \"../GraphTableSVG/src/object/table/row.ts\");\r\nconst column_1 = __webpack_require__(/*! ./table/column */ \"../GraphTableSVG/src/object/table/column.ts\");\r\nconst border_row_1 = __webpack_require__(/*! ./table/border_row */ \"../GraphTableSVG/src/object/table/border_row.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst vba_functions_1 = __webpack_require__(/*! ../basic/common/vba_functions */ \"../GraphTableSVG/src/basic/common/vba_functions.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nclass GTable extends g_object_1.GObject {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this._isNoneMode = false;\r\n        this._rows = new Array(0);\r\n        this._columns = new Array(0);\r\n        this._borderRows = new Array(0);\r\n        this._borderColumns = new Array(0);\r\n        this.isConstructing = false;\r\n        this._isDrawing = false;\r\n        this._isAutoResized = false;\r\n        this._cellTextObserverFunc = (x) => {\r\n            let b = false;\r\n            let b2 = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (p.type == \"childList\") {\r\n                    b = true;\r\n                    b2 = true;\r\n                }\r\n                for (let j = 0; j < p.addedNodes.length; j++) {\r\n                    const item = p.addedNodes.item(j);\r\n                    if (item != null && item.nodeName == \"#text\") {\r\n                        b = true;\r\n                        b2 = true;\r\n                    }\r\n                }\r\n            }\r\n            if (b2 && !this.isConstructing) {\r\n                this.fitSizeToOriginalCells(false);\r\n            }\r\n            if (b)\r\n                this.update();\r\n        };\r\n        this._isTextObserved = false;\r\n        this.isSetSize = false;\r\n        this.prevShow = false;\r\n        common_functions_1.CommonFunctions.setGraphTableCSS();\r\n        this._svgHiddenGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgRowBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgRowBorderGroup.setAttribute(\"name\", \"rowBorderGroup\");\r\n        this._svgColumnBorderGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        this._svgColumnBorderGroup.setAttribute(\"name\", \"columnBorderGroup\");\r\n        this._svgHiddenGroup.style.visibility = \"hidden\";\r\n        this.svgGroup.appendChild(this.svgHiddenGroup);\r\n        this.svgGroup.appendChild(this.svgRowBorderGroup);\r\n        this.svgGroup.appendChild(this.svgColumnBorderGroup);\r\n        this._cellTextObserver = new MutationObserver(this._cellTextObserverFunc);\r\n        this.updateAttributes = [];\r\n        this.isConstructing = true;\r\n        this.firstSetSize();\r\n        if (option.table === undefined) {\r\n            if (option.rowCount == undefined)\r\n                option.rowCount = 5;\r\n            if (option.columnCount == undefined)\r\n                option.columnCount = 5;\r\n            this.setSize(option.columnCount, option.rowCount);\r\n            if (option.rowHeight != undefined) {\r\n                this.rows.forEach((v) => v.height = option.rowHeight);\r\n            }\r\n            if (option.columnWidth != undefined) {\r\n                this.columns.forEach((v) => v.width = option.columnWidth);\r\n            }\r\n            for (let y = 0; y < this.rowCount; y++) {\r\n                for (let x = 0; x < this.columnCount; x++) {\r\n                    this.updateCellByLogicCell(null, x, y);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.svgGroup.style.display = \"none\";\r\n            this._isNoneMode = true;\r\n            this.constructFromLogicTable(option.table);\r\n            this._isNoneMode = false;\r\n            this.svgGroup.style.removeProperty(\"display\");\r\n            this.isTextObserved = true;\r\n        }\r\n        this.isConstructing = false;\r\n        if (this.type == enums_1.ShapeObjectType.Table)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    get isNoneMode() {\r\n        return this._isNoneMode;\r\n    }\r\n    get isCenterBased() {\r\n        return false;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        const table = logic_table_1.LogicTable.constructLogicTable(e);\r\n        g_object_1.GObject.constructAttributes(e, removeAttributes, output);\r\n        if (table != null) {\r\n            output.table = table;\r\n        }\r\n        if (output.x !== undefined)\r\n            output.table.x = output.x;\r\n        if (output.y !== undefined)\r\n            output.table.y = output.y;\r\n        if (output.class !== undefined)\r\n            output.table.tableClassName = output.class;\r\n        while (e.childNodes.length > 0)\r\n            e.removeChild(e.childNodes.item(0));\r\n        return output;\r\n    }\r\n    get svgRowBorderGroup() {\r\n        return this._svgRowBorderGroup;\r\n    }\r\n    get svgColumnBorderGroup() {\r\n        return this._svgColumnBorderGroup;\r\n    }\r\n    get borderRows() {\r\n        return this._borderRows;\r\n    }\r\n    get borderColumns() {\r\n        return this._borderColumns;\r\n    }\r\n    get width() {\r\n        let width = 0;\r\n        this.columns.forEach((v) => width += v.width);\r\n        return width;\r\n    }\r\n    set width(value) {\r\n    }\r\n    get height() {\r\n        let height = 0;\r\n        this.rows.forEach((v) => height += v.height);\r\n        return height;\r\n    }\r\n    set height(value) {\r\n    }\r\n    get svgHiddenGroup() {\r\n        return this._svgHiddenGroup;\r\n    }\r\n    get type() {\r\n        return enums_1.ShapeObjectType.Table;\r\n    }\r\n    get rows() {\r\n        return this._rows;\r\n    }\r\n    get columns() {\r\n        return this._columns;\r\n    }\r\n    get cells() {\r\n        return this.rows.map((v) => v.cells);\r\n    }\r\n    get isDrawing() {\r\n        return this._isDrawing;\r\n    }\r\n    get isAutoResized() {\r\n        return this._isAutoResized;\r\n    }\r\n    set isAutoResized(value) {\r\n        this._isAutoResized = value;\r\n        if (value) {\r\n            this.update();\r\n        }\r\n    }\r\n    get cellTextObserver() {\r\n        return this._cellTextObserver;\r\n    }\r\n    get columnCount() {\r\n        if (this.cells.length == 0) {\r\n            return 0;\r\n        }\r\n        else {\r\n            if (this.rows.length > 2 && (this.rows[0].length != this.rows[1].length))\r\n                throw new Error(\"Invalid length error\");\r\n            return this.rows[0].length;\r\n        }\r\n    }\r\n    get rowCount() {\r\n        return this.cells.length;\r\n    }\r\n    get cellArray() {\r\n        const arr = new Array(0);\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                arr.push(this.cells[y][x]);\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    get borders() {\r\n        const arr = new Array(0);\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                if (arr.indexOf(this.cells[y][x].svgTopBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgTopBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgLeftBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgLeftBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgRightBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgRightBorder);\r\n                }\r\n                if (arr.indexOf(this.cells[y][x].svgBottomBorder) == -1) {\r\n                    arr.push(this.cells[y][x].svgBottomBorder);\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    fitSizeToOriginalCells(allowShrink) {\r\n        this.rows.forEach((v) => v.fitHeightToOriginalCell(allowShrink));\r\n        this.columns.forEach((v) => v.fitWidthToOriginalCell(allowShrink));\r\n    }\r\n    getTryCell(x, y) {\r\n        if (x < 0 || x >= this.columnCount || y < 0 || y >= this.rowCount) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.cells[y][x];\r\n        }\r\n    }\r\n    getRangeCells(x, y, width, height) {\r\n        let cells = new Array(height);\r\n        for (let i = 0; i < cells.length; i++) {\r\n            cells[i] = new Array(0);\r\n            for (let j = 0; j < width; j++) {\r\n                cells[i].push(this.cells[y + i][x + j]);\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n    getRangeCellArray(x, y, width, height) {\r\n        let cells = new Array();\r\n        this.getRangeCells(x, y, width, height).forEach((v) => { v.forEach((w) => { cells.push(w); }); });\r\n        return cells;\r\n    }\r\n    getRegion() {\r\n        let rect = new vline_1.Rectangle();\r\n        rect.x = this.svgGroup.getX();\r\n        rect.y = this.svgGroup.getY();\r\n        rect.width = this.width;\r\n        rect.height = this.height;\r\n        return rect;\r\n    }\r\n    getEmphasizedCells() {\r\n        return this.cellArray.filter((v) => v.isEmphasized);\r\n    }\r\n    toPlainText() {\r\n        const plainTable = this.cells.map((v) => v.map((w) => w.toPlainText()));\r\n        const widtharr = new Array(this.columnCount);\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            widtharr[x] = 0;\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const width = plainTable[y][x].length;\r\n                if (widtharr[x] < width)\r\n                    widtharr[x] = width;\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                plainTable[y][x] = common_functions_1.CommonFunctions.paddingLeft(plainTable[y][x], widtharr[x], \" \");\r\n            }\r\n        }\r\n        return plainTable.map((v) => v.join(\",\")).join(\"\\n\");\r\n    }\r\n    get isTextObserved() {\r\n        return this._isTextObserved;\r\n    }\r\n    set isTextObserved(b) {\r\n        if (this._isTextObserved != b) {\r\n            if (this._isTextObserved) {\r\n                this.cellTextObserver.disconnect();\r\n            }\r\n            else {\r\n                const option1 = { childList: true, subtree: true };\r\n                this.cellArray.forEach((v) => {\r\n                    this.cellTextObserver.observe(v.svgText, option1);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    updateCellByLogicCell(table, x, y) {\r\n        const cell = this.cells[y][x];\r\n        if (table != null) {\r\n            const cellInfo = table.cells[y][x];\r\n            if (cellInfo != null) {\r\n                if (cellInfo.cellClass != null) {\r\n                    svg_1.SVG.resetStyle(cell.svgGroup.style);\r\n                    cell.svgGroup.setAttribute(\"class\", cellInfo.cellClass);\r\n                }\r\n                if (cellInfo.backgroundClass != null) {\r\n                    svg_1.SVG.resetStyle(cell.svgBackground.style);\r\n                    cell.svgBackground.setAttribute(\"class\", cellInfo.backgroundClass);\r\n                }\r\n                if (cellInfo.textClass != null) {\r\n                    svg_1.SVG.resetStyle(cell.svgText.style);\r\n                    cell.svgText.setAttribute(\"class\", cellInfo.textClass);\r\n                }\r\n                cellInfo.createTextElement(cell.svgText);\r\n                if (cellInfo.topBorderClass != null) {\r\n                    let borderClass = cellInfo.topBorderClass;\r\n                    svg_1.SVG.resetStyle(cell.svgTopBorder.style);\r\n                    cell.svgTopBorder.setAttribute(\"class\", borderClass);\r\n                }\r\n                if (cellInfo.leftBorderClass != null) {\r\n                    let borderClass = cellInfo.leftBorderClass;\r\n                    svg_1.SVG.resetStyle(cell.svgLeftBorder.style);\r\n                    cell.svgLeftBorder.setAttribute(\"class\", borderClass);\r\n                }\r\n                if (cellInfo.rightBorderClass != null) {\r\n                    let borderClass = cellInfo.rightBorderClass;\r\n                    svg_1.SVG.resetStyle(cell.svgRightBorder.style);\r\n                    cell.svgRightBorder.setAttribute(\"class\", borderClass);\r\n                }\r\n                if (cellInfo.bottomBorderClass != null) {\r\n                    let borderClass = cellInfo.bottomBorderClass;\r\n                    svg_1.SVG.resetStyle(cell.svgBottomBorder.style);\r\n                    cell.svgBottomBorder.setAttribute(\"class\", borderClass);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    constructFromLogicTable(table) {\r\n        if (table.tableClassName != null)\r\n            this.svgGroup.setAttribute(\"class\", table.tableClassName);\r\n        this.setSize(table.columnWidths.length, table.rowHeights.length);\r\n        if (table.x != null)\r\n            this.cx = table.x;\r\n        if (table.y != null)\r\n            this.cy = table.y;\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                this.updateCellByLogicCell(table, x, y);\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            const h = table.rowHeights[y];\r\n            if (h != null)\r\n                this.rows[y].height = h;\r\n        }\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            const w = table.columnWidths[x];\r\n            if (w != null)\r\n                this.columns[x].width = w;\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const logicCell = table.cells[y][x];\r\n                if (logicCell.connectedColumnCount > 1 || logicCell.connectedRowCount > 1) {\r\n                    if (cell.canMerge(logicCell.connectedColumnCount, logicCell.connectedRowCount)) {\r\n                        cell.merge(logicCell.connectedColumnCount, logicCell.connectedRowCount);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.isInitialized) {\r\n            this.update();\r\n        }\r\n    }\r\n    construct(table, option = {}) {\r\n        if (option.isLatexMode == undefined)\r\n            option.isLatexMode = false;\r\n        if (option.x == undefined)\r\n            option.x = 0;\r\n        if (option.y == undefined)\r\n            option.y = 0;\r\n        [this.cx, this.cy] = [option.x, option.y];\r\n        this.clear();\r\n        let width = 0;\r\n        table.forEach((v) => { if (v.length > width)\r\n            width = v.length; });\r\n        let height = table.length;\r\n        this.setSize(width, height);\r\n        table.forEach((v, y) => {\r\n            v.forEach((str, x) => {\r\n                this.cells[y][x].svgText.setTextContent(str, option.isLatexMode);\r\n            });\r\n        });\r\n        if (option.rowHeight != undefined) {\r\n            this.rows.forEach((v) => v.height = option.rowHeight);\r\n        }\r\n        if (option.columnWidth != undefined) {\r\n            this.columns.forEach((v) => v.width = option.columnWidth);\r\n        }\r\n    }\r\n    createVBACode2(id, slide) {\r\n        const lines = new Array(0);\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        const [main, sub] = this.createVBAMainCode(\"createdSlide\", id);\r\n        lines.push(main);\r\n        lines.push(`End Sub`);\r\n        lines.push(sub);\r\n        return lines;\r\n    }\r\n    createVBAMainCode(slideName, id) {\r\n        const fstLines = [];\r\n        const lines = new Array(0);\r\n        fstLines.push(` Dim tableS As shape`);\r\n        fstLines.push(` Dim table_ As table`);\r\n        fstLines.push(` Set tableS = ${slideName}.Shapes.AddTable(${this.rowCount}, ${this.columnCount})`);\r\n        fstLines.push(` tableS.Left = ${this.svgGroup.getX()}`);\r\n        fstLines.push(` tableS.Top = ${this.svgGroup.getY()}`);\r\n        fstLines.push(` Set table_ = tableS.table`);\r\n        const tableName = \"table_\";\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            lines.push([` Call EditRow(${tableName}.Rows(${y + 1}), ${this.rows[y].height})`]);\r\n        }\r\n        for (let x = 0; x < this.columnCount; x++) {\r\n            lines.push([` Call EditColumn(${tableName}.Columns(${x + 1}), ${this.columns[x].width})`]);\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                let color = color_1.Color.createRGBFromColorName(cell.svgBackground.getPropertyStyleValueWithDefault(\"fill\", \"gray\"));\r\n                vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement(lines, this.cells[y][x].svgText, `${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame.TextRange`);\r\n                lines.push([`${tableName}.cell(${y + 1},${x + 1}).Shape.Fill.ForeColor.RGB = RGB(CInt(${color.r}), CInt(${color.g}), CInt(${color.b}))`]);\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(cell.verticalAnchor == null ? \"\" : cell.verticalAnchor);\r\n                const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(cell.horizontalAnchor == null ? \"\" : cell.horizontalAnchor);\r\n                lines.push([` Call EditCellTextFrame(${tableName}.cell(${y + 1},${x + 1}).Shape.TextFrame, ${cell.paddingTop}, ${cell.paddingBottom}, ${cell.paddingLeft}, ${cell.paddingRight}, ${vAnchor}, ${hAnchor})`]);\r\n            }\r\n        }\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            for (let x = 0; x < this.columnCount; x++) {\r\n                const cell = this.cells[y][x];\r\n                const upLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(cell.svgTopBorder.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                const upLineStrokeWidth = cell.svgTopBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgTopBorder.style.strokeWidth) : \"\";\r\n                const upLineVisibility = cell.svgTopBorder.style.visibility != null ? vba_functions_1.visible(cell.svgTopBorder.style.visibility) : \"\";\r\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderTop), ${upLineStyle}, ${upLineStrokeWidth}, ${upLineVisibility})`]);\r\n                const leftLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(cell.svgLeftBorder.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                const leftLineStrokeWidth = cell.svgLeftBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgLeftBorder.style.strokeWidth) : \"\";\r\n                const leftLineVisibility = cell.svgLeftBorder.style.visibility != null ? vba_functions_1.visible(cell.svgLeftBorder.style.visibility) : \"\";\r\n                lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderLeft), ${leftLineStyle}, ${leftLineStrokeWidth}, ${leftLineVisibility})`]);\r\n                if (x + 1 == this.columnCount) {\r\n                    const rightLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(cell.svgRightBorder.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                    const rightLineStrokeWidth = cell.svgRightBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgRightBorder.style.strokeWidth) : \"\";\r\n                    const rightLineVisibility = cell.svgRightBorder.style.visibility != null ? vba_functions_1.visible(cell.svgRightBorder.style.visibility) : \"\";\r\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderRight), ${rightLineStyle}, ${rightLineStrokeWidth}, ${rightLineVisibility})`]);\r\n                }\r\n                if (y + 1 == this.rowCount) {\r\n                    const bottomLineStyle = vba_functions_1.VBATranslateFunctions.colorToVBA(cell.svgBottomBorder.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n                    const bottomLineStrokeWidth = cell.svgBottomBorder.style.strokeWidth != null ? vba_functions_1.parseInteger(cell.svgBottomBorder.style.strokeWidth) : \"\";\r\n                    const bottomLineVisibility = cell.svgBottomBorder.style.visibility != null ? vba_functions_1.visible(cell.svgBottomBorder.style.visibility) : \"\";\r\n                    lines.push([` Call EditCellBorder(${tableName}.cell(${y + 1},${x + 1}).Borders(ppBorderBottom), ${bottomLineStyle}, ${bottomLineStrokeWidth}, ${bottomLineVisibility})`]);\r\n                }\r\n            }\r\n        }\r\n        this.cellArray.forEach((v) => {\r\n            if (v.isMaster) {\r\n                const cells = v.cellsInGroup;\r\n                for (let y = 0; y < cells.length; y++) {\r\n                    for (let x = 1; x < cells[y].length; x++) {\r\n                        lines.push([` ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][x].cellY + 1}, ${cells[y][x].cellX + 1})`]);\r\n                    }\r\n                }\r\n                for (let y = 1; y < cells.length; y++) {\r\n                    lines.push([` ${tableName}.Cell(${cells[0][0].cellY + 1}, ${cells[0][0].cellX + 1}).Merge MergeTo := ${tableName}.Cell(${cells[y][0].cellY + 1}, ${cells[y][0].cellX + 1})`]);\r\n                }\r\n            }\r\n        });\r\n        const x0 = vba_functions_1.VBATranslateFunctions.joinLines(fstLines);\r\n        const [x1, y1] = vba_functions_1.VBATranslateFunctions.splitCode(lines, `${tableName} as Table`, `${tableName}`, id);\r\n        return [vba_functions_1.VBATranslateFunctions.joinLines([x0, x1]), y1];\r\n    }\r\n    removeTable(svg) {\r\n        if (svg.contains(this.svgGroup)) {\r\n            svg.removeChild(this.svgGroup);\r\n        }\r\n    }\r\n    firstSetSize() {\r\n        this.createRowBorder(0, 1);\r\n        this.createRowBorder(0, 1);\r\n        this.createColumnBorder(0, 1);\r\n        this.createColumnBorder(0, 1);\r\n        this._rows.splice(0, 0, new row_1.CellRow(this, 0, undefined));\r\n        this._rows[0]._appendCell();\r\n        this._columns.splice(0, 0, new column_1.CellColumn(this, 0));\r\n    }\r\n    borderSizeCheck(_w, _h) {\r\n        const w = this.borderRows[0].borders.length;\r\n        const h = this.borderColumns[0].borders.length;\r\n        if (w != _w)\r\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\r\n        if (h != _h)\r\n            throw Error(`error ${_w} ${_h} ${w} ${h}`);\r\n        this.borderRows.forEach((v, i) => {\r\n            if (w != v.borders.length)\r\n                throw Error(\"border rows error\");\r\n        });\r\n        this.borderColumns.forEach((v, i) => {\r\n            if (h != v.borders.length)\r\n                throw Error(`border column error ${h} ${v.borders.length} ${i}`);\r\n        });\r\n    }\r\n    setSize(columnCount, rowCount) {\r\n        this.clear();\r\n        this.isSetSize = true;\r\n        const borderRowCount = rowCount + 1;\r\n        const borderColumnCount = columnCount + 1;\r\n        if (this.rowCount == 0 || this.columnCount == 0)\r\n            throw Error(\"Table Empty Error\");\r\n        while (this.rowCount < rowCount) {\r\n            this.primitiveInsertRow(this.rowCount, false);\r\n        }\r\n        while (this.columnCount < columnCount) {\r\n            this.primitiveInsertColumn(this.columnCount, false);\r\n        }\r\n        this.updateNodeRelations();\r\n        this.isSetSize = false;\r\n    }\r\n    primitiveInsertRow(ithRow, insertTopBorders) {\r\n        let ithRowBorder = insertTopBorders ? ithRow : ithRow + 1;\r\n        if (ithRow < 0 || ithRow > this.rowCount)\r\n            throw new Error(\"primitive insert row error\");\r\n        if (ithRow == 0)\r\n            ithRowBorder = 0;\r\n        if (ithRow == this.rowCount)\r\n            ithRowBorder = this.borderRows.length;\r\n        this.createRowBorder(ithRowBorder);\r\n        this.insertYVerticalBorders(ithRow);\r\n        this.createRow(ithRow);\r\n    }\r\n    primitiveInsertColumn(ithColumn, insertLeftBorders) {\r\n        let ithColumnBorder = insertLeftBorders ? ithColumn : ithColumn + 1;\r\n        if (ithColumn < 0 || ithColumn > this.columnCount)\r\n            throw new Error(\"primitive insert column error\");\r\n        if (ithColumn == 0)\r\n            ithColumnBorder = 0;\r\n        if (ithColumn == this.columnCount)\r\n            ithColumnBorder = this.borderColumns.length;\r\n        this.createColumnBorder(ithColumnBorder);\r\n        this.insertXHorizontalBorders(ithColumn);\r\n        this.createColumn(ithColumn);\r\n    }\r\n    get borderColumnCount() {\r\n        return this.columnCount + 1;\r\n    }\r\n    get borderRowCount() {\r\n        return this.rowCount + 1;\r\n    }\r\n    clear() {\r\n        if (this.rowCount == 0 || this.columnCount == 0)\r\n            throw Error(\"Table Empty Error\");\r\n        if (this.columnCount != this.columns.length)\r\n            throw Error(\"clear error\");\r\n        while (this.rowCount > 1) {\r\n            this.primitiveRemoveRow(1, false);\r\n        }\r\n        while (this.columnCount > 1) {\r\n            this.primitiveRemoveColumn(1, false);\r\n        }\r\n        this.updateNodeRelations();\r\n    }\r\n    removeCellRow(i) {\r\n        this.rows[i]._dispose();\r\n        this.rows.splice(i, 1);\r\n    }\r\n    removeCellColumn(i) {\r\n        this.columns[i]._dispose();\r\n        this.columns.splice(i, 1);\r\n    }\r\n    primitiveRemoveRow(ithRow, removeTopBorders) {\r\n        const ithBorderRow = removeTopBorders ? ithRow : ithRow + 1;\r\n        if (ithRow < 0 || ithRow >= this.rowCount)\r\n            throw new Error(\"error\");\r\n        this.removeCellRow(ithRow);\r\n        ;\r\n        this.removeRowBorder(ithBorderRow);\r\n        this.deleteYVerticalBorders(ithRow);\r\n    }\r\n    primitiveRemoveColumn(ithColumn, removeLeftBorders) {\r\n        const ithborderColumn = removeLeftBorders ? ithColumn : ithColumn + 1;\r\n        if (ithColumn < 0 || ithColumn >= this.columnCount)\r\n            throw new Error(\"primitive insert column error\");\r\n        this.removeCellColumn(ithColumn);\r\n        this.removeColumnBorder(ithborderColumn);\r\n        this.deleteXHorizontalBorders(ithColumn);\r\n    }\r\n    removeColumnBorder(i) {\r\n        this._borderColumns[i].remove();\r\n        this._borderColumns.splice(i, 1);\r\n    }\r\n    removeRowBorder(i) {\r\n        this._borderRows[i].remove();\r\n        this._borderRows.splice(i, 1);\r\n    }\r\n    removeRow(ithRow) {\r\n        this.primitiveRemoveRow(ithRow, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    removeColumn(ithColumn) {\r\n        this.primitiveRemoveColumn(ithColumn, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    deleteXHorizontalBorders(i) {\r\n        this._borderRows.forEach((v) => {\r\n            v.removeBorder(i);\r\n        });\r\n    }\r\n    deleteYVerticalBorders(i) {\r\n        this._borderColumns.forEach((v) => {\r\n            v.removeBorder(i);\r\n        });\r\n    }\r\n    createColumnBorder(i, borderRowCount = this.borderRows.length - 1) {\r\n        const column = new border_row_1.BorderColumn(this, i, borderRowCount, undefined);\r\n        this._borderColumns.splice(i, 0, column);\r\n    }\r\n    createRowBorder(i, borderColumnCount = this.borderColumns.length - 1) {\r\n        const row = new border_row_1.BorderRow(this, i, borderColumnCount, undefined);\r\n        this._borderRows.splice(i, 0, row);\r\n    }\r\n    createRow(i) {\r\n        const columnCount = this.columnCount;\r\n        const row = new row_1.CellRow(this, i, undefined);\r\n        this._rows.splice(i, 0, row);\r\n        row._appendCell(columnCount);\r\n    }\r\n    createColumn(i) {\r\n        for (let y = 0; y < this.rowCount; y++) {\r\n            this.rows[y]._insertCell(i);\r\n        }\r\n        this._columns.splice(i, 0, new column_1.CellColumn(this, i));\r\n    }\r\n    insertXHorizontalBorders(i) {\r\n        this._borderRows.forEach((v) => {\r\n            v.insertBorder(i, undefined);\r\n        });\r\n    }\r\n    insertYVerticalBorders(i) {\r\n        this._borderColumns.forEach((v) => {\r\n            v.insertBorder(i, undefined);\r\n        });\r\n    }\r\n    insertRow(ithRow) {\r\n        this.primitiveInsertRow(ithRow, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    insertColumn(ithColumn) {\r\n        this.primitiveInsertColumn(ithColumn, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    appendColumn() {\r\n        this.primitiveInsertColumn(this.columnCount, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    appendRow() {\r\n        this.primitiveInsertRow(this.rowCount, false);\r\n        this.updateNodeRelations();\r\n        this.update();\r\n    }\r\n    update() {\r\n        super.update();\r\n        this._observer.disconnect();\r\n        const display = this.svgGroup.getPropertyStyleValue(\"display\");\r\n        const b = html_functions_1.HTMLFunctions.isShow(this.svgGroup);\r\n        if (!b) {\r\n            return;\r\n        }\r\n        this._isDrawing = true;\r\n        if (true) {\r\n            this.cellArray.forEach((v) => v.update());\r\n            this.fitSizeToOriginalCells(false);\r\n            this.prevShow = false;\r\n        }\r\n        this.resize();\r\n        this.relocation();\r\n        this._isDrawing = false;\r\n        this._observer.observe(this.svgGroup, this.groupObserverOption);\r\n    }\r\n    updateNodeRelations() {\r\n        this.rows.forEach((v, i) => v.cellY = i);\r\n        this.columns.forEach((v, i) => v.cellX = i);\r\n        this.borderRows.forEach((v, i) => {\r\n            if (v.borders.length != this.columnCount) {\r\n                throw new Error(`error row ${i} ${v.borders.length} ${this.columnCount}`);\r\n            }\r\n        });\r\n        this.borderColumns.forEach((v, i) => {\r\n            if (v.borders.length != this.rowCount) {\r\n                throw new Error(`error column ${i} ${v.borders.length} ${this.rowCount}`);\r\n            }\r\n        });\r\n        this.cellArray.forEach((v) => v.updateNodeRelations());\r\n    }\r\n    resize() {\r\n        this.rows.forEach((v) => v.resize());\r\n        this.columns.forEach((v) => v.resize());\r\n    }\r\n    relocation() {\r\n        let height = 0;\r\n        this.rows.forEach(function (x, i, arr) {\r\n            x.setY(height);\r\n            height += x.height;\r\n        });\r\n        let width = 0;\r\n        this.columns.forEach(function (x, i, arr) {\r\n            x.setX(width);\r\n            width += x.width;\r\n        });\r\n        this.cellArray.forEach((v) => v.relocation());\r\n    }\r\n}\r\nexports.GTable = GTable;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_table.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_textbox.ts":
/*!************************************************!*\
  !*** ../GraphTableSVG/src/object/g_textbox.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ../basic/svghtml/svg_interface */ \"../GraphTableSVG/src/basic/svghtml/svg_interface.ts\");\r\n__webpack_require__(/*! ../basic/svghtml/svg_text */ \"../GraphTableSVG/src/basic/svghtml/svg_text.ts\");\r\n__webpack_require__(/*! ../basic/svghtml/svg_g */ \"../GraphTableSVG/src/basic/svghtml/svg_g.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nclass GTextBox extends g_object_1.GObject {\r\n    constructor(svgbox, option = {}) {\r\n        super(svgbox, option);\r\n        this.isFixTextSize = false;\r\n        this.surfaceAttributes = [];\r\n        this._isSpecialTextBox = false;\r\n        this._minimumWidth = 10;\r\n        this._minimumHeight = 10;\r\n        this.textObserverFunc = (x) => {\r\n            if (!this.isLocated)\r\n                return;\r\n            let b = false;\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (GTextBox.updateTextAttributes.some((v) => v == p.attributeName)) {\r\n                    b = true;\r\n                }\r\n                if (p.attributeName == null) {\r\n                    b = true;\r\n                }\r\n            }\r\n            if (b)\r\n                this.update();\r\n        };\r\n        const _option = this.initializeOption(option);\r\n        this._svgText = GTextBox.createSVGText(_option.textClass, _option.textStyle);\r\n        this.svgGroup.appendChild(this.svgText);\r\n        this._textObserver = new MutationObserver(this.textObserverFunc);\r\n        const option2 = { childList: true, attributes: true, subtree: true };\r\n        this._textObserver.observe(this.svgText, option2);\r\n        if (typeof _option.text == \"string\") {\r\n            this.svgText.setTextContent(_option.text);\r\n        }\r\n        else if (Array.isArray(_option.text)) {\r\n            svg_textbox_1.SVGTextBox.constructSVGTextByHTMLElements(this.svgText, _option.text, false);\r\n        }\r\n        else {\r\n        }\r\n        const b = this.svgGroup.gtGetStyleBooleanWithUndefined(custtome_attributes_1.CustomAttributeNames.Style.autoSizeShapeToFitText);\r\n        if (b === undefined && _option.isAutoSizeShapeToFitText !== undefined) {\r\n            this.isAutoSizeShapeToFitText = _option.isAutoSizeShapeToFitText;\r\n        }\r\n        if (this.type == enums_1.ShapeObjectType.Object)\r\n            this.firstFunctionAfterInitialized();\r\n    }\r\n    initializeOption(option) {\r\n        let b = false;\r\n        if (option.width !== undefined || option.height !== undefined) {\r\n            b = true;\r\n        }\r\n        const _option = super.initializeOption(option);\r\n        if (b && _option.isAutoSizeShapeToFitText === undefined)\r\n            _option.isAutoSizeShapeToFitText = false;\r\n        if (_option.isAutoSizeShapeToFitText === undefined)\r\n            _option.isAutoSizeShapeToFitText = true;\r\n        if (_option.verticalAnchor === undefined)\r\n            _option.verticalAnchor = enums_1.VerticalAnchor.Middle;\r\n        if (_option.horizontalAnchor === undefined)\r\n            _option.horizontalAnchor = enums_1.HorizontalAnchor.Center;\r\n        if (_option.textClass === undefined)\r\n            _option.textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextClass;\r\n        return _option;\r\n    }\r\n    static createSVGText(className, style) {\r\n        const _svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n        _svgText.setAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName, (svg_1.SVG.idCounter++).toString());\r\n        if (style !== undefined)\r\n            _svgText.setAttribute(\"style\", style);\r\n        if (className == null) {\r\n            if (_svgText.style.fill == null || _svgText.style.fill == \"\")\r\n                _svgText.style.fill = \"black\";\r\n            if (_svgText.style.fontSize == null || _svgText.style.fontSize == \"\")\r\n                _svgText.style.fontSize = \"14px\";\r\n            if (_svgText.style.fontWeight == null || _svgText.style.fontWeight == \"\")\r\n                _svgText.style.fontWeight = \"bold\";\r\n            if (_svgText.style.fontFamily == null || _svgText.style.fontFamily == \"\")\r\n                _svgText.style.fontFamily = 'Times New Roman';\r\n            if (_svgText.style.getPropertyValue(custtome_attributes_1.CustomAttributeNames.Style.marginLeft) == \"\")\r\n                _svgText.setMarginLeft(10);\r\n            if (_svgText.style.getPropertyValue(custtome_attributes_1.CustomAttributeNames.Style.marginRight) == \"\")\r\n                _svgText.setMarginRight(10);\r\n            if (_svgText.style.getPropertyValue(custtome_attributes_1.CustomAttributeNames.Style.marginTop) == \"\")\r\n                _svgText.setMarginTop(10);\r\n            if (_svgText.style.getPropertyValue(custtome_attributes_1.CustomAttributeNames.Style.marginBottom) == \"\")\r\n                _svgText.setMarginBottom(10);\r\n        }\r\n        else {\r\n            _svgText.setAttribute(\"class\", className);\r\n        }\r\n        return _svgText;\r\n    }\r\n    static constructAttributes(e, removeAttributes = false, output = {}) {\r\n        g_object_1.GObject.constructAttributes(e, removeAttributes, output);\r\n        output.isAutoSizeShapeToFitText = e.gtGetStyleBooleanWithUndefined(custtome_attributes_1.CustomAttributeNames.Style.autoSizeShapeToFitText);\r\n        const textChild = html_functions_1.HTMLFunctions.getChildByNodeName(e, \"text\");\r\n        output.textClass = e.gtGetAttributeStringWithUndefined(\"text:class\");\r\n        output.textStyle = e.gtGetAttributeStringWithUndefined(\"text:style\");\r\n        if (e.hasAttribute(\"text\")) {\r\n            output.text = e.getAttribute(\"text\");\r\n        }\r\n        else if (e.children.length > 0) {\r\n            const tNodes = html_functions_1.HTMLFunctions.getTNodes(e);\r\n            if (tNodes != null) {\r\n                tNodes.forEach((v) => v.remove());\r\n                output.text = tNodes;\r\n            }\r\n        }\r\n        else if (textChild != null) {\r\n        }\r\n        else if (e.innerHTML.length > 0) {\r\n            output.text = e.innerHTML;\r\n        }\r\n        if (removeAttributes) {\r\n            e.removeAttribute(\"text\");\r\n            e.removeAttribute(\"text:class\");\r\n            e.removeAttribute(\"text:style\");\r\n            e.style.removeProperty(custtome_attributes_1.CustomAttributeNames.Style.autoSizeShapeToFitText);\r\n        }\r\n        return output;\r\n    }\r\n    get svgText() {\r\n        return this._svgText;\r\n    }\r\n    get horizontalAnchor() {\r\n        const b = this.svgGroup.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.HorizontalAnchor, \"center\");\r\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\r\n    }\r\n    set horizontalAnchor(value) {\r\n        if (this.horizontalAnchor != value)\r\n            this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.HorizontalAnchor, value);\r\n    }\r\n    get verticalAnchor() {\r\n        const b = this.svgGroup.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.VerticalAnchor, \"middle\");\r\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\r\n    }\r\n    set verticalAnchor(value) {\r\n        if (this.verticalAnchor != value)\r\n            this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.VerticalAnchor, value);\r\n    }\r\n    get isAutoSizeShapeToFitText() {\r\n        const b = this.svgGroup.gtGetStyleBooleanWithUndefined(custtome_attributes_1.CustomAttributeNames.Style.autoSizeShapeToFitText);\r\n        if (b == undefined) {\r\n            return false;\r\n        }\r\n        else {\r\n            return b;\r\n        }\r\n    }\r\n    set isAutoSizeShapeToFitText(value) {\r\n        this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.autoSizeShapeToFitText, value ? \"true\" : \"false\");\r\n    }\r\n    update() {\r\n        super.update();\r\n        this._isUpdating = true;\r\n        if (!this.isShow)\r\n            return;\r\n        this._observer.disconnect();\r\n        if (this.svgText == null) {\r\n            throw new TypeError(\"svgText is null\");\r\n        }\r\n        svg_textbox_1.SVGTextBox.sortText(this.svgText, this.horizontalAnchor, false);\r\n        if (this.isAutoSizeShapeToFitText)\r\n            this.updateToFitText();\r\n        this.updateSurface();\r\n        if (this.fixedX != null && Math.abs(this.x - this.fixedX) > 20) {\r\n            this.x = this.fixedX;\r\n        }\r\n        if (this.fixedY != null && Math.abs(this.y - this.fixedY) > 20) {\r\n            this.y = this.fixedY;\r\n        }\r\n        if (!this._isSpecialTextBox) {\r\n            this.svgText.gtSetXY(this.innerRectangleWithoutMargin, this.verticalAnchor, this.horizontalAnchor, this.isAutoSizeShapeToFitText);\r\n        }\r\n        this._isUpdating = false;\r\n        this._observer.observe(this.svgGroup, this.groupObserverOption);\r\n    }\r\n    updateSurface() {\r\n        this._observer.disconnect();\r\n        const dashStyle = this.msoDashStyle;\r\n        if (dashStyle != null && this.svgSurface != null) {\r\n            enums_1.msoDashStyle.setCpmoutedDashArray(this.svgSurface);\r\n        }\r\n        this._observer.observe(this.svgGroup, this._observerOption);\r\n    }\r\n    updateToFitText() {\r\n        this.isFixTextSize = true;\r\n        const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText);\r\n        const textWidth = textRect.width < this._minimumWidth ? this._minimumWidth : textRect.width;\r\n        const textHeight = textRect.height < this._minimumHeight ? this._minimumHeight : textRect.height;\r\n        this.width = textWidth + this.marginPaddingLeft + this.marginPaddingRight;\r\n        this.height = textHeight + this.marginPaddingTop + this.marginPaddingBottom;\r\n    }\r\n    get marginPaddingTop() {\r\n        return this.svgText.getMarginTop() + this.svgGroup.getPaddingTop();\r\n    }\r\n    get marginPaddingLeft() {\r\n        return this.svgText.getMarginLeft() + this.svgGroup.getPaddingLeft();\r\n    }\r\n    get marginPaddingRight() {\r\n        return this.svgText.getMarginRight() + this.svgGroup.getPaddingRight();\r\n    }\r\n    get marginPaddingBottom() {\r\n        return this.svgText.getMarginBottom() + this.svgGroup.getPaddingBottom();\r\n    }\r\n    get paddingTop() {\r\n        return this.svgGroup.getPaddingTop();\r\n    }\r\n    set paddingTop(value) {\r\n        this.svgGroup.setPaddingTop(value);\r\n    }\r\n    get paddingLeft() {\r\n        return this.svgGroup.getPaddingLeft();\r\n    }\r\n    set paddingLeft(value) {\r\n        this.svgGroup.setPaddingLeft(value);\r\n    }\r\n    get paddingRight() {\r\n        return this.svgGroup.getPaddingRight();\r\n    }\r\n    set paddingRight(value) {\r\n        this.svgGroup.setPaddingRight(value);\r\n    }\r\n    get paddingBottom() {\r\n        return this.svgGroup.getPaddingBottom();\r\n    }\r\n    set paddingBottom(value) {\r\n        this.svgGroup.setPaddingBottom(value);\r\n    }\r\n    get marginTop() {\r\n        return this.svgText.getMarginTop();\r\n    }\r\n    set marginTop(value) {\r\n        this.svgText.setMarginTop(value);\r\n    }\r\n    get marginLeft() {\r\n        return this.svgText.getMarginLeft();\r\n    }\r\n    set marginLeft(value) {\r\n        this.svgText.setMarginLeft(value);\r\n    }\r\n    get marginRight() {\r\n        return this.svgText.getMarginRight();\r\n    }\r\n    set marginRight(value) {\r\n        this.svgText.setMarginRight(value);\r\n    }\r\n    get marginBottom() {\r\n        return this.svgText.getMarginBottom();\r\n    }\r\n    set marginBottom(value) {\r\n        this.svgText.setMarginBottom(value);\r\n    }\r\n    get innerRectangle() {\r\n        const rect = new vline_1.Rectangle();\r\n        rect.width = 0;\r\n        rect.height = 0;\r\n        rect.x = 0;\r\n        rect.y = 0;\r\n        return rect;\r\n    }\r\n    get innerRectangleWithoutMargin() {\r\n        const rect = this.innerRectangle;\r\n        rect.width = rect.width - this.marginPaddingLeft - this.marginPaddingRight;\r\n        rect.height = rect.height - this.marginPaddingTop - this.marginPaddingBottom;\r\n        rect.x = rect.x + this.marginPaddingLeft;\r\n        rect.y = rect.y + this.marginPaddingTop;\r\n        return rect;\r\n    }\r\n    get svgElements() {\r\n        const r = [];\r\n        r.push(this.svgGroup);\r\n        r.push(this.svgText);\r\n        return r;\r\n    }\r\n    hasDescendant(obj) {\r\n        const ids = this.svgElements.map((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName)).filter((v) => v != null);\r\n        const id = obj.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName);\r\n        return ids.some((v) => v == id);\r\n    }\r\n    get hasSize() {\r\n        return true;\r\n    }\r\n    get msoDashStyle() {\r\n        if (this.svgSurface != null) {\r\n            const dashStyle = this.svgSurface.getPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.msoDashStyleName);\r\n            if (dashStyle != null) {\r\n                return enums_1.msoDashStyle.toMSODashStyle(dashStyle);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    set msoDashStyle(value) {\r\n        if (this.svgSurface != null) {\r\n            if (enums_1.msoDashStyle == null) {\r\n                this.svgSurface.style.removeProperty(custtome_attributes_1.CustomAttributeNames.Style.msoDashStyleName);\r\n            }\r\n            else {\r\n                this.svgSurface.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.msoDashStyleName, value);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.GTextBox = GTextBox;\r\nGTextBox.updateTextAttributes = [\"style\"];\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_textbox.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/g_vertex.ts":
/*!***********************************************!*\
  !*** ../GraphTableSVG/src/object/g_vertex.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vba_functions_1 = __webpack_require__(/*! ../basic/common/vba_functions */ \"../GraphTableSVG/src/basic/common/vba_functions.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst g_object_1 = __webpack_require__(/*! ./g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ./g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst g_graph_1 = __webpack_require__(/*! ./g_graph */ \"../GraphTableSVG/src/object/g_graph.ts\");\r\nconst virtual_tree_1 = __webpack_require__(/*! ./virtual_tree */ \"../GraphTableSVG/src/object/virtual_tree.ts\");\r\nclass GVertex extends g_textbox_1.GTextBox {\r\n    get defaultClassName() {\r\n        return custtome_attributes_1.CustomAttributeNames.StyleValue.defaultVertexClass;\r\n    }\r\n    getLocation(type, x, y) {\r\n        return [this.cx, this.cy];\r\n    }\r\n    getConnectorType(type, x, y) {\r\n        if (type == enums_1.ConnectorPosition.Auto) {\r\n            return this.getAutoPosition(x, y);\r\n        }\r\n        else {\r\n            return type;\r\n        }\r\n    }\r\n    getAutoPosition(x, y) {\r\n        return enums_1.ConnectorPosition.Top;\r\n    }\r\n    get outcomingEdges() {\r\n        const p = JSON.parse(this.svgGroup.gtGetAttribute(\"outcoming-edges\", \"[]\"));\r\n        const p2 = p.map((v) => g_object_1.GObject.getObjectFromObjectID(v.toString()));\r\n        return p2;\r\n    }\r\n    get incomingEdges() {\r\n        const p = JSON.parse(this.svgGroup.gtGetAttribute(\"incoming-edges\", \"[]\"));\r\n        const p2 = p.map((v) => g_object_1.GObject.getObjectFromObjectID(v.toString()));\r\n        return p2;\r\n    }\r\n    insertOutcomingEdge(edge, insertIndex = this.outcomingEdges.length) {\r\n        const p = this.outcomingEdges.indexOf(edge);\r\n        if (p != -1) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            const edges = this.outcomingEdges;\r\n            edges.splice(insertIndex, 0, edge);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"outcoming-edges\", newEdges);\r\n            if (edge.beginVertex != this) {\r\n                edge.beginVertex = this;\r\n            }\r\n        }\r\n    }\r\n    removeOutcomingEdge(edge) {\r\n        const p = this.outcomingEdges.indexOf(edge);\r\n        if (p != null) {\r\n            const edges = this.outcomingEdges;\r\n            edges.splice(p, 1);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"outcoming-edges\", newEdges);\r\n            if (edge.beginVertex == this) {\r\n                edge.beginVertex = null;\r\n            }\r\n        }\r\n    }\r\n    insertIncomingEdge(edge, insertIndex = this.incomingEdges.length) {\r\n        const p = this.incomingEdges.indexOf(edge);\r\n        if (p != -1) {\r\n            throw new Error();\r\n        }\r\n        else {\r\n            const edges = this.incomingEdges;\r\n            edges.splice(insertIndex, 0, edge);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"incoming-edges\", newEdges);\r\n            if (edge.endVertex != this) {\r\n                edge.endVertex = this;\r\n            }\r\n        }\r\n    }\r\n    removeIncomingEdge(edge) {\r\n        const p = this.incomingEdges.indexOf(edge);\r\n        if (p != null) {\r\n            const edges = this.incomingEdges;\r\n            edges.splice(p, 1);\r\n            const newEdges = JSON.stringify(edges.map((v) => Number(v.objectID)));\r\n            this.svgGroup.setAttribute(\"incoming-edges\", newEdges);\r\n            if (edge.endVertex == this) {\r\n                edge.endVertex = null;\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        while (this.incomingEdges.length > 0) {\r\n            this.removeIncomingEdge(this.incomingEdges[0]);\r\n        }\r\n        while (this.outcomingEdges.length > 0) {\r\n            this.removeOutcomingEdge(this.outcomingEdges[0]);\r\n        }\r\n    }\r\n    getParents() {\r\n        return this.incomingEdges.filter((v) => v.beginVertex != null).map((v) => v.beginVertex);\r\n    }\r\n    get parentEdge() {\r\n        if (this.incomingEdges.length == 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.incomingEdges[0];\r\n        }\r\n    }\r\n    get parent() {\r\n        if (this.parentEdge == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.parentEdge.beginVertex;\r\n        }\r\n    }\r\n    get isNoParent() {\r\n        return this.parent == null;\r\n    }\r\n    get children() {\r\n        return this.outcomingEdges.filter((v) => v.endVertex != null).map((v) => v.endVertex);\r\n    }\r\n    get isLeaf() {\r\n        return this.outcomingEdges.length == 0;\r\n    }\r\n    createVirtualTree(excludedEdgeDic) {\r\n        return new virtual_tree_1.VirtualTree(this, excludedEdgeDic);\r\n    }\r\n    get region() {\r\n        const p = new vline_1.Rectangle();\r\n        p.x = this.cx - (this.width / 2);\r\n        p.y = this.cy - (this.height / 2);\r\n        p.width = this.width;\r\n        p.height = this.height;\r\n        return p;\r\n    }\r\n    get shape() {\r\n        return \"NONE\";\r\n    }\r\n    createVBACode(id) {\r\n        const lines = [];\r\n        const backColor = vba_functions_1.VBATranslateFunctions.colorToVBA(this.svgSurface.getPropertyStyleValueWithDefault(\"fill\", \"gray\"));\r\n        const visible = this.svgSurface.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n        const vAnchor = vba_functions_1.VBATranslateFunctions.ToVerticalAnchor(this.verticalAnchor);\r\n        const hAnchor = vba_functions_1.VBATranslateFunctions.ToHorizontalAnchor(this.horizontalAnchor);\r\n        lines.push(`Sub create${id}(createdSlide As slide)`);\r\n        lines.push(` Dim shapes_ As Shapes : Set shapes_ = createdSlide.Shapes`);\r\n        lines.push(` Dim obj As Shape`);\r\n        lines.push(` Set obj = shapes_.AddShape(${this.shape}, ${this.x}, ${this.y}, ${this.width}, ${this.height})`);\r\n        lines.push(` Call EditTextFrame(obj.TextFrame, ${this.marginPaddingTop}, ${this.marginPaddingBottom}, ${this.marginPaddingLeft}, ${this.marginPaddingRight}, false, ppAutoSizeNone)`);\r\n        lines.push(` Call EditAnchor(obj.TextFrame, ${vAnchor}, ${hAnchor})`);\r\n        vba_functions_1.VBATranslateFunctions.TranslateSVGTextElement2(this.svgText, `obj.TextFrame.TextRange`).forEach((v) => lines.push(v));\r\n        lines.push(this.getVBAEditLine());\r\n        lines.push(` Call EditCallOut(obj, \"${this.objectID}\", ${visible}, ${backColor})`);\r\n        this.VBAAdjustments.forEach((v, i) => {\r\n            lines.push(` obj.Adjustments.Item(${i + 1}) = ${v}`);\r\n        });\r\n        lines.push(`End Sub`);\r\n        return lines;\r\n    }\r\n    get VBAAdjustments() {\r\n        return [];\r\n    }\r\n    getVBAEditLine() {\r\n        const lineColor = vba_functions_1.VBATranslateFunctions.colorToVBA(this.svgSurface.getPropertyStyleValueWithDefault(\"stroke\", \"gray\"));\r\n        const lineType = enums_1.msoDashStyle.getLineType(this.svgSurface);\r\n        const strokeWidth = parseInt(this.svgSurface.getPropertyStyleValueWithDefault(\"stroke-width\", \"4\"));\r\n        const visible = this.svgSurface.getPropertyStyleValueWithDefault(\"visibility\", \"visible\") == \"visible\" ? \"msoTrue\" : \"msoFalse\";\r\n        return ` Call EditLine(obj.Line, ${lineColor}, ${lineType}, ${0}, ${strokeWidth}, ${visible})`;\r\n    }\r\n    get graph() {\r\n        const v = this.svgGroup.parentElement;\r\n        if (v != null && v instanceof SVGGElement && v.hasAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName)) {\r\n            const id = v.getAttribute(custtome_attributes_1.CustomAttributeNames.objectIDName);\r\n            const obj = g_object_1.GObject.getObjectFromObjectID(id);\r\n            if (obj instanceof g_graph_1.GGraph) {\r\n                return obj;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexports.GVertex = GVertex;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/g_vertex.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/table/border_row.ts":
/*!*******************************************************!*\
  !*** ../GraphTableSVG/src/object/table/border_row.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"../GraphTableSVG/src/object/table/cell.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nclass BorderRow {\r\n    constructor(_table, _y, columnSize, borderClass) {\r\n        this._borders = new Array(0);\r\n        this.table = _table;\r\n        this._svgGroup = svg_1.SVG.createGroup(this.table.svgRowBorderGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"border_row\");\r\n        this.borderY = _y;\r\n        for (let x = 0; x < columnSize; x++) {\r\n            this.insertBorder(x, borderClass !== undefined ? borderClass : custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBorderClass);\r\n        }\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get borderY() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set borderY(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n    }\r\n    get borders() {\r\n        return this._borders;\r\n    }\r\n    insertBorder(coromni, borderClass) {\r\n        const line = svg_1.SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBorderClass);\r\n        this._svgGroup.appendChild(line);\r\n        this._borders.splice(coromni, 0, line);\r\n    }\r\n    removeBorder(i) {\r\n        this._borders[i].remove();\r\n        this._borders.splice(i, 1);\r\n    }\r\n    remove() {\r\n        this.svgGroup.remove();\r\n    }\r\n}\r\nexports.BorderRow = BorderRow;\r\nclass BorderColumn {\r\n    constructor(_table, _x, rowSize, borderClass) {\r\n        this._borders = new Array(0);\r\n        this.table = _table;\r\n        this._svgGroup = svg_1.SVG.createGroup(this.table.svgColumnBorderGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"border_column\");\r\n        this.borderX = _x;\r\n        for (let y = 0; y < rowSize; y++) {\r\n            this.insertBorder(y, borderClass !== undefined ? borderClass : custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBorderClass);\r\n        }\r\n    }\r\n    get borderX() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set borderX(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get borders() {\r\n        return this._borders;\r\n    }\r\n    insertBorder(rowi, borderClass) {\r\n        const line = svg_1.SVG.createLine(0, 0, 0, 0, borderClass !== undefined ? borderClass : custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBorderClass);\r\n        this._svgGroup.appendChild(line);\r\n        this._borders.splice(rowi, 0, line);\r\n    }\r\n    removeBorder(i) {\r\n        this._borders[i].remove();\r\n        this._borders.splice(i, 1);\r\n    }\r\n    remove() {\r\n        this.svgGroup.remove();\r\n    }\r\n}\r\nexports.BorderColumn = BorderColumn;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/table/border_row.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/table/cell.ts":
/*!*************************************************!*\
  !*** ../GraphTableSVG/src/object/table/cell.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_functions_1 = __webpack_require__(/*! ../../basic/common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst vline_1 = __webpack_require__(/*! ../../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nvar DirectionType;\r\n(function (DirectionType) {\r\n    DirectionType[DirectionType[\"top\"] = 0] = \"top\";\r\n    DirectionType[DirectionType[\"left\"] = 1] = \"left\";\r\n    DirectionType[DirectionType[\"right\"] = 2] = \"right\";\r\n    DirectionType[DirectionType[\"bottom\"] = 3] = \"bottom\";\r\n})(DirectionType = exports.DirectionType || (exports.DirectionType = {}));\r\nvar DirectionType2;\r\n(function (DirectionType2) {\r\n    DirectionType2[DirectionType2[\"topLeft\"] = 0] = \"topLeft\";\r\n    DirectionType2[DirectionType2[\"bottomLeft\"] = 1] = \"bottomLeft\";\r\n    DirectionType2[DirectionType2[\"bottomRight\"] = 2] = \"bottomRight\";\r\n    DirectionType2[DirectionType2[\"topRight\"] = 3] = \"topRight\";\r\n})(DirectionType2 = exports.DirectionType2 || (exports.DirectionType2 = {}));\r\nclass Cell {\r\n    constructor(parent, _px, _py, option = {}) {\r\n        this.__currentClass = null;\r\n        this.tmpStyle = null;\r\n        this._observerFunc = (x) => {\r\n            for (let i = 0; i < x.length; i++) {\r\n                const p = x[i];\r\n                if (p.attributeName == \"style\" || p.attributeName == \"class\") {\r\n                    if (p.attributeName == \"class\") {\r\n                        const className = this.svgGroup.getAttribute(\"class\");\r\n                        if (className != this.__currentClass) {\r\n                            this.recomputeDefaultProperties();\r\n                            this.__currentClass = className;\r\n                        }\r\n                    }\r\n                    this.locateSVGText();\r\n                }\r\n            }\r\n        };\r\n        this._assurancevisibility = false;\r\n        this._svgGroup = svg_1.SVG.createGroup(null);\r\n        this._table = parent;\r\n        this.table.rows[_py].svgGroup.appendChild(this.svgGroup);\r\n        this.svgGroup.setAttribute(\"class\", option.cellClass !== undefined ? option.cellClass : custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellClass);\r\n        this.svgGroup.setAttribute(custtome_attributes_1.CustomAttributeNames.GroupAttribute, \"cell\");\r\n        this.svgGroup.setAttribute(Cell.cellXName, `${_px}`);\r\n        this.svgGroup.setAttribute(Cell.cellYName, `${_py}`);\r\n        this.setMasterDiffX(0);\r\n        this.setMasterDiffY(0);\r\n        const backGroundClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultCellBackgroungClass;\r\n        this._svgBackground = svg_1.SVG.createCellRectangle(this.svgGroup, backGroundClass);\r\n        const textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextClass;\r\n        this._svgText = svg_1.SVG.createText(textClass);\r\n        this.svgGroup.appendChild(this.svgText);\r\n        this._observer = new MutationObserver(this._observerFunc);\r\n        const option2 = { attributes: true };\r\n        this._observer.observe(this.svgGroup, option2);\r\n    }\r\n    recomputeDefaultProperties() {\r\n    }\r\n    get isEmphasized() {\r\n        const cellClass = this.svgBackground.getAttribute(\"class\");\r\n        return cellClass == custtome_attributes_1.CustomAttributeNames.cellEmphasisCellClass;\r\n    }\r\n    set isEmphasized(v) {\r\n        if (v) {\r\n            if (!this.isEmphasized) {\r\n                this.tmpStyle = this.svgBackground.getAttribute(\"class\");\r\n                this.svgBackground.setAttribute(\"class\", custtome_attributes_1.CustomAttributeNames.cellEmphasisCellClass);\r\n            }\r\n        }\r\n        else {\r\n            if (this.isEmphasized) {\r\n                if (this.tmpStyle == null) {\r\n                    this.svgBackground.removeAttribute(\"class\");\r\n                }\r\n                else {\r\n                    this.svgBackground.setAttribute(\"class\", this.tmpStyle);\r\n                    this.tmpStyle = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get fontSize() {\r\n        const p = this.svgText.getPropertyStyleValueWithDefault(\"font-size\", \"24\");\r\n        const p2 = parseInt(p);\r\n        return p2;\r\n    }\r\n    get paddingLeft() {\r\n        return this.svgGroup.getPaddingLeft();\r\n    }\r\n    get paddingRight() {\r\n        return this.svgGroup.getPaddingRight();\r\n    }\r\n    get paddingTop() {\r\n        return this.svgGroup.getPaddingTop();\r\n    }\r\n    get paddingBottom() {\r\n        return this.svgGroup.getPaddingBottom();\r\n    }\r\n    get horizontalAnchor() {\r\n        const b = this.svgGroup.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.HorizontalAnchor, \"center\");\r\n        return enums_1.HorizontalAnchor.toHorizontalAnchor(b);\r\n    }\r\n    set horizontalAnchor(value) {\r\n        if (this.horizontalAnchor != value)\r\n            this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.HorizontalAnchor, value);\r\n    }\r\n    get verticalAnchor() {\r\n        const b = this.svgGroup.getPropertyStyleValueWithDefault(custtome_attributes_1.CustomAttributeNames.Style.VerticalAnchor, \"middle\");\r\n        return enums_1.VerticalAnchor.toVerticalAnchor(b);\r\n    }\r\n    set verticalAnchor(value) {\r\n        if (this.verticalAnchor != value)\r\n            this.svgGroup.setPropertyStyleValue(custtome_attributes_1.CustomAttributeNames.Style.VerticalAnchor, value);\r\n    }\r\n    get table() {\r\n        return this._table;\r\n    }\r\n    get svgBackground() {\r\n        return this._svgBackground;\r\n    }\r\n    get svgText() {\r\n        return this._svgText;\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get innerExtraPaddingLeft() {\r\n        const p = this.fontSize;\r\n        return p / 16;\r\n    }\r\n    get innerExtraPaddingRight() {\r\n        const p = this.fontSize;\r\n        return p / 16;\r\n    }\r\n    get masterDiffX() {\r\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffXName));\r\n    }\r\n    setMasterDiffX(id) {\r\n        this.svgGroup.setAttribute(Cell.masterDiffXName, `${id}`);\r\n    }\r\n    get masterDiffY() {\r\n        return Number(this.svgGroup.getAttribute(Cell.masterDiffYName));\r\n    }\r\n    setMasterDiffY(id) {\r\n        this.svgGroup.setAttribute(Cell.masterDiffYName, `${id}`);\r\n    }\r\n    get masterCellX() {\r\n        return this.cellX + this.masterDiffX;\r\n    }\r\n    setMasterCellX(id) {\r\n        this.setMasterDiffX(id - this.cellX);\r\n    }\r\n    get masterCellY() {\r\n        return this.cellY + this.masterDiffY;\r\n    }\r\n    setMasterCellY(id) {\r\n        this.setMasterDiffY(id - this.cellY);\r\n    }\r\n    get masterID() {\r\n        return this.table.cells[this.masterCellY][this.masterCellX].ID;\r\n    }\r\n    get master() {\r\n        return this.table.cellArray[this.masterID];\r\n    }\r\n    get cellX() {\r\n        return Number(this.svgGroup.getAttribute(Cell.cellXName));\r\n    }\r\n    set cellX(value) {\r\n        if (this.cellX != value)\r\n            this.svgGroup.setAttribute(Cell.cellXName, value.toString());\r\n    }\r\n    get cellY() {\r\n        return Number(this.svgGroup.getAttribute(Cell.cellYName));\r\n    }\r\n    set cellY(value) {\r\n        if (this.cellY != value)\r\n            this.svgGroup.setAttribute(Cell.cellYName, value.toString());\r\n    }\r\n    get isLocated() {\r\n        return common_functions_1.CommonFunctions.IsDescendantOfBody(this.svgGroup);\r\n    }\r\n    get isMaster() {\r\n        return this.ID == this.masterID;\r\n    }\r\n    get isSlave() {\r\n        return !this.isMaster;\r\n    }\r\n    get ID() {\r\n        return this.cellX + (this.cellY * this.table.columnCount);\r\n    }\r\n    get isErrorCell() {\r\n        return this.table.cells[this.cellY][this.cellX] != this;\r\n    }\r\n    get GroupRowCount() {\r\n        if (!this.isMaster)\r\n            throw Error(\"Slave Error\");\r\n        return this.leftSideGroupCells.length;\r\n    }\r\n    get GroupColumnCount() {\r\n        if (!this.isMaster)\r\n            throw Error(\"Slave Error\");\r\n        return this.upperSideGroupCells.length;\r\n    }\r\n    get cellsInGroup() {\r\n        if (this.isMaster) {\r\n            return this.table.getRangeCells(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    get cellArrayInGroup() {\r\n        if (this.isMaster) {\r\n            return this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, this.GroupRowCount);\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    get isSingleCell() {\r\n        return this.isMaster && this.leftSideGroupCells.length == 1 && this.upperSideGroupCells.length == 1;\r\n    }\r\n    get isMasterCellOfRowCountOne() {\r\n        return this.isMaster && this.leftSideGroupCells.length == 1;\r\n    }\r\n    get isMasterCellOfColumnCountOne() {\r\n        return this.isMaster && this.upperSideGroupCells.length == 1;\r\n    }\r\n    get x() {\r\n        return this.svgGroup.getX();\r\n    }\r\n    set x(value) {\r\n        this.svgGroup.setX(value);\r\n    }\r\n    get y() {\r\n        return this.svgGroup.getY();\r\n    }\r\n    set y(value) {\r\n        this.svgGroup.setY(value);\r\n    }\r\n    get width() {\r\n        return this.svgBackground.width.baseVal.value;\r\n    }\r\n    set width(value) {\r\n        this.svgBackground.width.baseVal.value = value;\r\n    }\r\n    get height() {\r\n        return this.svgBackground.height.baseVal.value;\r\n    }\r\n    set height(value) {\r\n        this.svgBackground.height.baseVal.value = value;\r\n    }\r\n    get region() {\r\n        const p = new vline_1.Rectangle(this.x, this.y, this.width, this.height);\r\n        return p;\r\n    }\r\n    get computeGroupWidth() {\r\n        const p = this.master.upperSideGroupCells;\r\n        const x2 = p[p.length - 1].cellX;\r\n        let w = 0;\r\n        for (let i = this.cellX; i <= x2; i++) {\r\n            w += this.table.columns[i].width;\r\n        }\r\n        return w;\r\n    }\r\n    get computeGroupHeight() {\r\n        const p = this.master.leftSideGroupCells;\r\n        const y2 = p[p.length - 1].cellY;\r\n        let w = 0;\r\n        for (let i = this.cellY; i <= y2; i++) {\r\n            w += this.table.rows[i].height;\r\n        }\r\n        return w;\r\n    }\r\n    static computeOverlapRange(v, w) {\r\n        if (w[0] < v[0]) {\r\n            return Cell.computeOverlapRange(w, v);\r\n        }\r\n        else {\r\n            if (v[1] < w[0]) {\r\n                return null;\r\n            }\r\n            else {\r\n                if (w[1] < v[1]) {\r\n                    return [w[0], w[1]];\r\n                }\r\n                else {\r\n                    return [w[0], v[1]];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static computeDisjunction(v, w) {\r\n        if (w[0] < v[0]) {\r\n            return Cell.computeDisjunction(w, v);\r\n        }\r\n        else {\r\n            if (v[1] < w[0]) {\r\n                return null;\r\n            }\r\n            else {\r\n                return [v[0], Math.max(v[1], w[1])];\r\n            }\r\n        }\r\n    }\r\n    get groupColumnRange() {\r\n        return [this.master.cellX, this.master.mostRightCellX];\r\n    }\r\n    get groupRowRange() {\r\n        return [this.master.cellY, this.master.mostBottomCellY];\r\n    }\r\n    computeBorderLength2(dir) {\r\n        const d1 = dir == DirectionType.top || dir == DirectionType.bottom ? this.master.x : this.master.y;\r\n        const d2 = dir == DirectionType.top || dir == DirectionType.bottom ? this.master.x + this.computeGroupWidth : this.master.y + this.computeGroupHeight;\r\n        const nextCell = this.getNextMasterCell(dir);\r\n        if (nextCell != null) {\r\n            const e1 = dir == DirectionType.top || dir == DirectionType.bottom ? nextCell.x : nextCell.y;\r\n            const e2 = dir == DirectionType.top || dir == DirectionType.bottom ? nextCell.x + nextCell.computeGroupWidth : nextCell.y + nextCell.computeGroupHeight;\r\n            const range = Cell.computeOverlapRange([d1, d2], [e1, e2]);\r\n            if (range == null) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return range[1] - range[0];\r\n            }\r\n        }\r\n        else {\r\n            return d2 - d1;\r\n        }\r\n    }\r\n    get svgTopBorder() {\r\n        return this._table.borderRows[this.cellY].borders[this.cellX];\r\n    }\r\n    get svgLeftBorder() {\r\n        return this._table.borderColumns[this.cellX].borders[this.cellY];\r\n    }\r\n    get svgRightBorder() {\r\n        return this._table.borderColumns[this.cellX + 1].borders[this.cellY];\r\n    }\r\n    get svgBottomBorder() {\r\n        return this._table.borderRows[this.cellY + 1].borders[this.cellX];\r\n    }\r\n    get logicalWidth() {\r\n        if (this.isMaster) {\r\n            let w = 0;\r\n            let now = this;\r\n            while (now != null && this.ID == now.masterID) {\r\n                now = this.rightCell;\r\n                w++;\r\n            }\r\n            return w;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    get logicalHeight() {\r\n        if (this.isMaster) {\r\n            let h = 0;\r\n            let now = this;\r\n            while (now != null && this.ID == now.masterID) {\r\n                now = this.bottomCell;\r\n                h++;\r\n            }\r\n            return h;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    get calculatedWidthUsingText() {\r\n        if (this.isLocated) {\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText, this._assurancevisibility);\r\n            return textRect.width + this.innerExtraPaddingLeft + this.innerExtraPaddingRight\r\n                + this.paddingLeft + this.paddingRight;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    get calculatedHeightUsingText() {\r\n        if (this.isLocated) {\r\n            const textRect = svg_textbox_1.SVGTextBox.getSize(this.svgText, this._assurancevisibility);\r\n            return textRect.height + this.paddingTop + this.paddingBottom;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    calculatedSizeUsingGroup() {\r\n        if (this.isLocated) {\r\n            let w = 0;\r\n            let h = 0;\r\n            this.leftSideGroupCells.forEach((v) => h += this.table.rows[v.cellY].height);\r\n            this.upperSideGroupCells.forEach((v) => w += this.table.columns[v.cellX].width);\r\n            return [w, h];\r\n        }\r\n        else {\r\n            return [0, 0];\r\n        }\r\n    }\r\n    computeSidePosition(dir) {\r\n        switch (dir) {\r\n            case DirectionType2.topLeft: return [this.x, this.y];\r\n            case DirectionType2.topRight: return [this.x + this.width, this.y];\r\n            case DirectionType2.bottomLeft: return [this.x, this.y + this.height];\r\n            case DirectionType2.bottomRight: return [this.x + this.width, this.y + this.height];\r\n        }\r\n        throw Error(\"error\");\r\n    }\r\n    getNextCell(direction) {\r\n        switch (direction) {\r\n            case DirectionType.top: return this.cellY != 0 ? this.table.cells[this.cellY - 1][this.cellX] : null;\r\n            case DirectionType.left: return this.cellX != 0 ? this.table.cells[this.cellY][this.cellX - 1] : null;\r\n            case DirectionType.right: return this.cellX + 1 != this.table.columnCount ? this.table.cells[this.cellY][this.cellX + 1] : null;\r\n            case DirectionType.bottom: return this.cellY + 1 != this.table.rowCount ? this.table.cells[this.cellY + 1][this.cellX] : null;\r\n        }\r\n        throw Error(\"error\");\r\n    }\r\n    getNextMasterCell(direction) {\r\n        const nextCell = this.getNextCell(direction);\r\n        return nextCell == null ? null :\r\n            nextCell.masterID != this.masterID ? nextCell.master : nextCell.getNextMasterCell(direction);\r\n    }\r\n    get topCell() {\r\n        return this.getNextCell(DirectionType.top);\r\n    }\r\n    get leftCell() {\r\n        return this.getNextCell(DirectionType.left);\r\n    }\r\n    get rightCell() {\r\n        return this.getNextCell(DirectionType.right);\r\n    }\r\n    get bottomCell() {\r\n        return this.getNextCell(DirectionType.bottom);\r\n    }\r\n    get bottomRightCell() {\r\n        return this.bottomCell == null ? null : this.bottomCell.rightCell == null ? null : this.bottomCell.rightCell;\r\n    }\r\n    get topRightCell() {\r\n        return this.topCell == null ? null : this.topCell.rightCell == null ? null : this.topCell.rightCell;\r\n    }\r\n    get bottomLeftCell() {\r\n        return this.bottomCell == null ? null : this.bottomCell.leftCell == null ? null : this.bottomCell.leftCell;\r\n    }\r\n    get topLeftCell() {\r\n        return this.topCell == null ? null : this.topCell.leftCell == null ? null : this.topCell.leftCell;\r\n    }\r\n    get topMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.top);\r\n    }\r\n    get leftMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.left);\r\n    }\r\n    get rightMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.right);\r\n    }\r\n    get bottomMasterCell() {\r\n        return this.getNextMasterCell(DirectionType.bottom);\r\n    }\r\n    get mostRightCellX() {\r\n        return this.cellX + this.GroupColumnCount - 1;\r\n    }\r\n    get mostBottomCellY() {\r\n        return this.cellY + this.GroupRowCount - 1;\r\n    }\r\n    getNextGroupCells(direction) {\r\n        if (this.isMaster) {\r\n            let w = [this];\r\n            let now = this.getNextCell(direction);\r\n            while (now != null && this.ID == now.masterID) {\r\n                w.push(now);\r\n                now = now.getNextCell(direction);\r\n                if (this.table.columnCount < w.length && (direction == DirectionType.left || direction == DirectionType.right)) {\r\n                    throw new Error(\"Invalid getNextGroupCells-Loop!\");\r\n                }\r\n            }\r\n            return w;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    get leftSideGroupCells() {\r\n        return this.getNextGroupCells(DirectionType.bottom);\r\n    }\r\n    get upperSideGroupCells() {\r\n        return this.getNextGroupCells(DirectionType.right);\r\n    }\r\n    toPlainText() {\r\n        if (this.isMaster) {\r\n            const textContext = this.svgText.textContent != null ? this.svgText.textContent : \"\";\r\n            if (this.isSingleCell) {\r\n                return textContext;\r\n            }\r\n            else {\r\n                return `${textContext}%%%${this.GroupColumnCount}%%%${this.GroupRowCount}`;\r\n            }\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    updateNodeRelations() {\r\n        this.updateSVGGroupParent();\r\n        this.updateBorderParent();\r\n    }\r\n    update() {\r\n        if (this.table.isNoneMode)\r\n            return;\r\n        const className = this.svgGroup.getAttribute(\"class\");\r\n        if (className != this.__currentClass) {\r\n            this.recomputeDefaultProperties();\r\n            this.__currentClass = className;\r\n        }\r\n        this.resize();\r\n        this.relocation();\r\n    }\r\n    updateSVGGroupParent() {\r\n        if (this.isMaster) {\r\n            if (this.table.rows[this.cellY].svgGroup != this.table.svgGroup) {\r\n                this.table.rows[this.cellY].svgGroup.appendChild(this.svgGroup);\r\n            }\r\n        }\r\n        else {\r\n            this.table.svgHiddenGroup.appendChild(this.svgGroup);\r\n            this.svgText.textContent = \"\";\r\n        }\r\n    }\r\n    get topBorderRow() {\r\n        return this.table.borderRows[this.cellY];\r\n    }\r\n    get bottomBorderRow() {\r\n        return this.table.borderRows[this.cellY + 1];\r\n    }\r\n    get leftBorderColumn() {\r\n        return this.table.borderColumns[this.cellX];\r\n    }\r\n    get rightBorderColumn() {\r\n        return this.table.borderColumns[this.cellX + 1];\r\n    }\r\n    updateBorderParent() {\r\n        if (this.isMaster || (this.topCell != null && this.topCell.isMaster)) {\r\n            if (this.topBorderRow.svgGroup != this.svgTopBorder.parentNode)\r\n                this.topBorderRow.svgGroup.appendChild(this.svgTopBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgTopBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgTopBorder);\r\n        }\r\n        if (this.isMaster || (this.leftCell != null && this.leftCell.isMaster)) {\r\n            if (this.leftBorderColumn.svgGroup != this.svgLeftBorder.parentNode)\r\n                this.leftBorderColumn.svgGroup.appendChild(this.svgLeftBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgLeftBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgLeftBorder);\r\n        }\r\n        if (this.isMaster || (this.rightCell != null && this.rightCell.isMaster)) {\r\n            if (this.rightBorderColumn.svgGroup != this.svgRightBorder.parentNode)\r\n                this.rightBorderColumn.svgGroup.appendChild(this.svgRightBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgRightBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgRightBorder);\r\n        }\r\n        if (this.isMaster || (this.bottomCell != null && this.bottomCell.isMaster)) {\r\n            if (this.bottomBorderRow.svgGroup != this.svgBottomBorder.parentNode)\r\n                this.bottomBorderRow.svgGroup.appendChild(this.svgBottomBorder);\r\n        }\r\n        else {\r\n            if (this.table.svgHiddenGroup != this.svgBottomBorder.parentNode)\r\n                this.table.svgHiddenGroup.appendChild(this.svgBottomBorder);\r\n        }\r\n    }\r\n    resize() {\r\n        svg_textbox_1.SVGTextBox.sortText(this.svgText, this.horizontalAnchor, this._assurancevisibility);\r\n        const [w, h] = this.calculatedSizeUsingGroup();\r\n        if (this.width != w) {\r\n            this.width = w;\r\n        }\r\n        if (this.height != h) {\r\n            this.height = h;\r\n        }\r\n        if (this.width < this.calculatedWidthUsingText) {\r\n            this.width = this.calculatedWidthUsingText;\r\n        }\r\n        if (this.height < this.calculatedHeightUsingText) {\r\n            this.height = this.calculatedHeightUsingText;\r\n        }\r\n    }\r\n    locateSVGText() {\r\n        const innerRect = new vline_1.Rectangle();\r\n        innerRect.x = this.innerExtraPaddingLeft + this.paddingLeft;\r\n        innerRect.y = this.paddingTop;\r\n        innerRect.height = this.height - this.paddingTop - this.paddingBottom;\r\n        innerRect.width = this.width - this.innerExtraPaddingLeft - this.innerExtraPaddingRight - this.paddingLeft - this.paddingRight;\r\n        if (this.isLocated) {\r\n            this.svgText.gtSetXY(innerRect, this.verticalAnchor, this.horizontalAnchor, false);\r\n        }\r\n    }\r\n    removeBorder(dir) {\r\n    }\r\n    removeFromTable(isColumn) {\r\n        this.svgGroup.remove();\r\n    }\r\n    updateBorderAttributes() {\r\n        const topCellX = this.svgTopBorder.getAttribute(Cell.borderXName);\r\n        const topCellY = this.svgTopBorder.getAttribute(Cell.borderYName);\r\n        const topCellAttr = this.svgTopBorder.getAttribute(Cell.borderTypeName);\r\n        if (topCellX != `${this.cellX}`)\r\n            this.svgTopBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (topCellY != `${this.cellY}`)\r\n            this.svgTopBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (topCellAttr != `horizontal`)\r\n            this.svgTopBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\r\n        const leftCellX = this.svgLeftBorder.getAttribute(Cell.borderXName);\r\n        const leftCellY = this.svgLeftBorder.getAttribute(Cell.borderYName);\r\n        const leftCellAttr = this.svgLeftBorder.getAttribute(Cell.borderTypeName);\r\n        if (leftCellX != `${this.cellX}`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (leftCellY != `${this.cellY}`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (leftCellAttr != `vertical`)\r\n            this.svgLeftBorder.setAttribute(Cell.borderTypeName, \"vertical\");\r\n        const rightCellX = this.svgRightBorder.getAttribute(Cell.borderXName);\r\n        const rightCellY = this.svgRightBorder.getAttribute(Cell.borderYName);\r\n        const rightCellAttr = this.svgRightBorder.getAttribute(Cell.borderTypeName);\r\n        if (rightCellX != `${this.cellX + 1}`)\r\n            this.svgRightBorder.setAttribute(Cell.borderXName, `${this.cellX + 1}`);\r\n        if (rightCellY != `${this.cellY}`)\r\n            this.svgRightBorder.setAttribute(Cell.borderYName, `${this.cellY}`);\r\n        if (rightCellAttr != `vertical`)\r\n            this.svgRightBorder.setAttribute(Cell.borderTypeName, \"vertical\");\r\n        const bottomCellX = this.svgBottomBorder.getAttribute(Cell.borderXName);\r\n        const bottomCellY = this.svgBottomBorder.getAttribute(Cell.borderYName);\r\n        const bottomCellAttr = this.svgBottomBorder.getAttribute(Cell.borderTypeName);\r\n        if (bottomCellX != `${this.cellX}`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderXName, `${this.cellX}`);\r\n        if (bottomCellY != `${this.cellY + 1}`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderYName, `${this.cellY + 1}`);\r\n        if (bottomCellAttr != `horizontal`)\r\n            this.svgBottomBorder.setAttribute(Cell.borderTypeName, \"horizontal\");\r\n    }\r\n    relocateTopBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgTopBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgTopBorder.x1.baseVal.value = this.x;\r\n                this.svgTopBorder.x2.baseVal.value = this.x + this.computeBorderLength2(DirectionType.top);\r\n                this.svgTopBorder.y1.baseVal.value = this.y;\r\n                this.svgTopBorder.y2.baseVal.value = this.svgTopBorder.y1.baseVal.value;\r\n            }\r\n            else if (this.topCell != null && this.topCell.isMaster) {\r\n                this.topCell.relocateBottomBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    relocateLeftBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgLeftBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgLeftBorder.x1.baseVal.value = this.x;\r\n                this.svgLeftBorder.x2.baseVal.value = this.svgLeftBorder.x1.baseVal.value;\r\n                this.svgLeftBorder.y1.baseVal.value = this.y;\r\n                this.svgLeftBorder.y2.baseVal.value = this.y + this.computeBorderLength2(DirectionType.left);\r\n            }\r\n            else if (this.leftCell != null && this.leftCell.isMaster) {\r\n                this.leftCell.relocateRightBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    relocateRightBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgRightBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgRightBorder.x1.baseVal.value = this.x + this.width;\r\n                this.svgRightBorder.x2.baseVal.value = this.svgRightBorder.x1.baseVal.value;\r\n                this.svgRightBorder.y1.baseVal.value = this.y;\r\n                this.svgRightBorder.y2.baseVal.value = this.y + this.computeBorderLength2(DirectionType.right);\r\n            }\r\n            else if (this.rightCell != null && this.rightCell.isMaster) {\r\n                this.rightCell.relocateLeftBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    relocateBottomBorder() {\r\n        if (!this.isMaster)\r\n            return;\r\n        if (this.table.svgGroup.contains(this.svgBottomBorder)) {\r\n            if (this.isMaster) {\r\n                this.svgBottomBorder.x1.baseVal.value = this.x;\r\n                this.svgBottomBorder.x2.baseVal.value = this.x + this.computeBorderLength2(DirectionType.bottom);\r\n                this.svgBottomBorder.y1.baseVal.value = this.y + this.height;\r\n                this.svgBottomBorder.y2.baseVal.value = this.svgBottomBorder.y1.baseVal.value;\r\n            }\r\n            else if (this.bottomCell != null && this.bottomCell.isMaster) {\r\n                this.bottomCell.relocateTopBorder();\r\n            }\r\n            else {\r\n                throw Error(\"error\");\r\n            }\r\n        }\r\n    }\r\n    relocation() {\r\n        if (!common_functions_1.CommonFunctions.IsDescendantOfBody(this.svgGroup))\r\n            return;\r\n        this.relocateTopBorder();\r\n        this.relocateLeftBorder();\r\n        this.relocateRightBorder();\r\n        this.relocateBottomBorder();\r\n        this.locateSVGText();\r\n    }\r\n    mergeRight() {\r\n        const range = this.getMergedRangeRight();\r\n        if (range != null) {\r\n            this.merge(range[0], range[1]);\r\n        }\r\n        else {\r\n            throw Error(\"Error\");\r\n        }\r\n    }\r\n    mergeBottom() {\r\n        const range = this.getMergedRangeBottom();\r\n        if (range != null) {\r\n            this.merge(range[0], range[1]);\r\n        }\r\n        else {\r\n            throw Error(\"Error\");\r\n        }\r\n    }\r\n    canMerge(w, h) {\r\n        const range = this.table.getRangeCells(this.cellX, this.cellY, w, h);\r\n        for (let x = 0; x < w; x++) {\r\n            const topCell = range[0][x].topCell;\r\n            if (topCell != null) {\r\n                if (range[0][x].masterID == topCell.masterID)\r\n                    return false;\r\n            }\r\n            const bottomCell = range[h - 1][x].bottomCell;\r\n            if (bottomCell != null) {\r\n                if (range[h - 1][x].masterID == bottomCell.masterID)\r\n                    return false;\r\n            }\r\n        }\r\n        for (let y = 0; y < h; y++) {\r\n            const leftCell = range[y][0].leftCell;\r\n            if (leftCell != null) {\r\n                if (range[y][0].masterID == leftCell.masterID)\r\n                    return false;\r\n            }\r\n            const rightCell = range[y][w - 1].rightCell;\r\n            if (rightCell != null) {\r\n                if (range[y][w - 1].masterID == rightCell.masterID)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    merge(w, h) {\r\n        if (!this.isMaster)\r\n            throw Error(\"Error\");\r\n        const range = this.table.getRangeCellArray(this.cellX, this.cellY, w, h);\r\n        range.forEach((v) => { v.setMasterCellX(this.masterCellX); v.setMasterCellY(this.masterCellY); });\r\n        range.forEach((v) => { v.updateNodeRelations(); v.update(); });\r\n    }\r\n    getMergedRangeRight() {\r\n        if (!this.isMaster)\r\n            return null;\r\n        if (this.rightMasterCell != null) {\r\n            const b1 = this.cellY == this.rightMasterCell.cellY;\r\n            const b2 = this.GroupRowCount == this.rightMasterCell.GroupRowCount;\r\n            if (b1 && b2) {\r\n                return [this.GroupColumnCount + this.rightMasterCell.GroupColumnCount, this.GroupRowCount];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    getMergedRangeBottom() {\r\n        if (!this.isMaster)\r\n            return null;\r\n        if (this.bottomMasterCell != null) {\r\n            const b1 = this.cellX == this.bottomMasterCell.cellX;\r\n            const b2 = this.GroupColumnCount == this.bottomMasterCell.GroupColumnCount;\r\n            if (b1 && b2) {\r\n                return [this.GroupColumnCount, this.GroupRowCount + this.bottomMasterCell.GroupRowCount];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    get canMergeRight() {\r\n        return this.getMergedRangeRight() != null;\r\n    }\r\n    get canMergeBottom() {\r\n        return this.getMergedRangeBottom() != null;\r\n    }\r\n    decomposeRow(upperRowCount) {\r\n        if (this.isMaster) {\r\n            const upperSide = this.table.getRangeCellArray(this.cellX, this.cellY, this.GroupColumnCount, upperRowCount);\r\n            const lowerSide = this.table.getRangeCellArray(this.cellX, this.cellY + upperRowCount, this.GroupColumnCount, this.GroupRowCount - upperRowCount);\r\n            const lowerMaster = lowerSide[0];\r\n            lowerSide.forEach((v) => {\r\n                v.setMasterCellX(lowerMaster.cellX);\r\n                v.setMasterCellY(lowerMaster.cellY);\r\n            });\r\n            upperSide.forEach((v) => v.update());\r\n            lowerSide.forEach((v) => v.update());\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n    decomposeColomn(leftColumnCount) {\r\n        if (this.isMaster) {\r\n            const leftSide = this.table.getRangeCellArray(this.cellX, this.cellY, leftColumnCount, this.GroupRowCount);\r\n            const rightSide = this.table.getRangeCellArray(this.cellX + leftColumnCount, this.cellY, this.GroupColumnCount - leftColumnCount, this.GroupRowCount);\r\n            const rightMaster = rightSide[0];\r\n            rightSide.forEach((v) => {\r\n                v.setMasterCellX(rightMaster.cellX);\r\n                v.setMasterCellY(rightMaster.cellY);\r\n            });\r\n            leftSide.forEach((v) => v.update());\r\n            rightSide.forEach((v) => v.update());\r\n        }\r\n        else {\r\n            throw Error(\"Slave Error\");\r\n        }\r\n    }\r\n}\r\nexports.Cell = Cell;\r\nCell.defaultCellClass = \"___cell-default\";\r\nCell.cellXName = \"data-cellX\";\r\nCell.cellYName = \"data-cellY\";\r\nCell.borderXName = \"data-borderX\";\r\nCell.borderYName = \"data-borderY\";\r\nCell.borderTypeName = \"data-borderType\";\r\nCell.masterIDName = \"data-masterID\";\r\nCell.masterDiffXName = \"data-masterDiffX\";\r\nCell.masterDiffYName = \"data-masterDiffY\";\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/table/cell.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/table/column.ts":
/*!***************************************************!*\
  !*** ../GraphTableSVG/src/object/table/column.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"../GraphTableSVG/src/object/table/cell.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nclass CellColumn {\r\n    constructor(_table, _x, _width = 30) {\r\n        this.table = _table;\r\n        this._svgGroup = svg_1.SVG.createGroup(this.table.svgGroup);\r\n        this._svgGroup.setAttribute(\"name\", \"cell_column\");\r\n        this.cellX = _x;\r\n        this._svgGroup.setAttribute(CellColumn.rowWidthName, `${_width}`);\r\n    }\r\n    get cellX() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellXName));\r\n    }\r\n    set cellX(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellXName, `${v}`);\r\n        this.cells.forEach((w) => w.cellX = v);\r\n    }\r\n    get width() {\r\n        return Number(this._svgGroup.getAttribute(CellColumn.rowWidthName));\r\n    }\r\n    set width(value) {\r\n        this._svgGroup.setAttribute(CellColumn.rowWidthName, `${value}`);\r\n        this.setWidthToCells();\r\n    }\r\n    setWidthToCells() {\r\n        const width = this.width;\r\n        let b = false;\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (cell.isMasterCellOfColumnCountOne && cell.width != width) {\r\n                cell.width = width;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (!cell.isMasterCellOfColumnCountOne) {\r\n                cell.update();\r\n                b = true;\r\n            }\r\n        }\r\n    }\r\n    get cells() {\r\n        const items = [];\r\n        for (let i = 0; i < this.table.rowCount; i++) {\r\n            items.push(this.table.rows[i].cells[this.cellX]);\r\n        }\r\n        return items;\r\n    }\r\n    get length() {\r\n        return this.cells.length;\r\n    }\r\n    getMaxWidth() {\r\n        let width = 0;\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            if (cell.isMasterCellOfColumnCountOne) {\r\n                if (width < cell.calculatedWidthUsingText)\r\n                    width = cell.calculatedWidthUsingText;\r\n                if (width < cell.width)\r\n                    width = cell.width;\r\n            }\r\n        }\r\n        return width;\r\n    }\r\n    resize() {\r\n        this.cells.forEach((v) => v.update());\r\n        this.setWidthToCells();\r\n    }\r\n    fitWidthToOriginalCell(allowShrink) {\r\n        if (allowShrink) {\r\n            this.width = this.getMaxWidth();\r\n        }\r\n        else {\r\n            this.width = Math.max(this.width, this.getMaxWidth());\r\n        }\r\n    }\r\n    setX(posX) {\r\n        for (let y = 0; y < this.table.rowCount; y++) {\r\n            const cell = this.table.cells[y][this.cellX];\r\n            cell.x = posX;\r\n        }\r\n    }\r\n    get leftBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgLeftBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgLeftBorder)\r\n                    r.push(v.svgLeftBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get rightBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgRightBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgRightBorder)\r\n                    r.push(v.svgRightBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get topBorder() {\r\n        return this.cells[0].svgTopBorder;\r\n    }\r\n    get bottomBorder() {\r\n        const cells = this.cells;\r\n        return cells[cells.length - 1].svgBottomBorder;\r\n    }\r\n    get selfx() {\r\n        for (let i = 0; i < this.table.columnCount; i++) {\r\n            if (this.table.columns[i] == this) {\r\n                return i;\r\n            }\r\n        }\r\n        throw new Error(\"error\");\r\n    }\r\n    _dispose() {\r\n        const x = this.selfx;\r\n        this.table.rows.forEach((v, i) => v._removeCell(x));\r\n        this._svgGroup.remove();\r\n    }\r\n    relocation() {\r\n        this.cells.forEach((v) => v.relocation());\r\n    }\r\n    get groupColumnRange() {\r\n        let range = this.cells[0].groupColumnRange;\r\n        this.cells.forEach((v) => {\r\n            if (range != null) {\r\n                range = cell_1.Cell.computeDisjunction(range, v.groupColumnRange);\r\n            }\r\n        });\r\n        if (range == null) {\r\n            throw Error(\"error\");\r\n        }\r\n        else {\r\n            return range;\r\n        }\r\n    }\r\n}\r\nexports.CellColumn = CellColumn;\r\nCellColumn.rowWidthName = \"data-width\";\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/table/column.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/table/row.ts":
/*!************************************************!*\
  !*** ../GraphTableSVG/src/object/table/row.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cell_1 = __webpack_require__(/*! ./cell */ \"../GraphTableSVG/src/object/table/cell.ts\");\r\nconst svg_1 = __webpack_require__(/*! ../../basic/svghtml/svg */ \"../GraphTableSVG/src/basic/svghtml/svg.ts\");\r\nclass CellRow {\r\n    constructor(_table, _y, _height = 30) {\r\n        this._cells = [];\r\n        this.table = _table;\r\n        this._svgGroup = svg_1.SVG.createGroup(this.table.svgGroup);\r\n        this.svgGroup.setAttribute(\"name\", \"cell_row\");\r\n        this.table.svgGroup.insertBefore(this.svgGroup, this.table.svgRowBorderGroup);\r\n        this.cellY = _y;\r\n        this._svgGroup.setAttribute(CellRow.columnHeightName, `${_height}`);\r\n    }\r\n    createCell(cellX, cellY) {\r\n        const cellClass = undefined;\r\n        const borderClass = undefined;\r\n        const option = { cellClass: cellClass, borderClass: borderClass };\r\n        return new cell_1.Cell(this.table, cellX, cellY, option);\r\n    }\r\n    _insertCell(i) {\r\n        const cell = this.createCell(i, this.cellY);\r\n        this.cells.splice(i, 0, cell);\r\n    }\r\n    _appendCell(num = 1) {\r\n        for (let i = 0; i < num; i++) {\r\n            const cell = this.createCell(this.cells.length, this.cellY);\r\n            this.cells.push(cell);\r\n        }\r\n    }\r\n    get cells() {\r\n        return this._cells;\r\n    }\r\n    get length() {\r\n        return this.cells.length;\r\n    }\r\n    get svgGroup() {\r\n        return this._svgGroup;\r\n    }\r\n    get cellY() {\r\n        return Number(this._svgGroup.getAttribute(cell_1.Cell.cellYName));\r\n    }\r\n    set cellY(v) {\r\n        this._svgGroup.setAttribute(cell_1.Cell.cellYName, `${v}`);\r\n        this.cells.forEach((w) => w.cellY = v);\r\n    }\r\n    get height() {\r\n        return Number(this._svgGroup.getAttribute(CellRow.columnHeightName));\r\n    }\r\n    set height(value) {\r\n        this._svgGroup.setAttribute(CellRow.columnHeightName, `${value}`);\r\n        this.setHeightToCells();\r\n    }\r\n    get topBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgTopBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgTopBorder)\r\n                    r.push(v.svgTopBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get bottomBorders() {\r\n        const r = [];\r\n        this.cells.forEach((v) => {\r\n            if (r.length == 0) {\r\n                r.push(v.svgBottomBorder);\r\n            }\r\n            else {\r\n                const last = r[r.length - 1];\r\n                if (last != v.svgBottomBorder)\r\n                    r.push(v.svgBottomBorder);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    get leftBorder() {\r\n        return this.cells[0].svgLeftBorder;\r\n    }\r\n    get rightBorder() {\r\n        const cells = this.cells;\r\n        return cells[cells.length - 1].svgRightBorder;\r\n    }\r\n    setHeightToCells() {\r\n        const height = this.height;\r\n        let b = false;\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (cell.isMasterCellOfRowCountOne && cell.height != height) {\r\n                cell.height = height;\r\n                b = true;\r\n            }\r\n        }\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (!cell.isMasterCellOfRowCountOne) {\r\n                cell.update();\r\n                b = true;\r\n            }\r\n        }\r\n    }\r\n    resize() {\r\n        this.cells.forEach((v) => v.update());\r\n        this.setHeightToCells();\r\n    }\r\n    fitHeightToOriginalCell(allowShrink) {\r\n        if (allowShrink) {\r\n            this.height = this.getMaxHeight();\r\n        }\r\n        else {\r\n            this.height = Math.max(this.height, this.getMaxHeight());\r\n        }\r\n    }\r\n    setY(posY) {\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            cell.y = posY;\r\n        }\r\n    }\r\n    getMaxHeight() {\r\n        let height = 0;\r\n        for (let x = 0; x < this.table.columnCount; x++) {\r\n            const cell = this.table.cells[this.cellY][x];\r\n            if (cell.isMasterCellOfRowCountOne) {\r\n                if (height < cell.calculatedHeightUsingText)\r\n                    height = cell.calculatedHeightUsingText;\r\n                if (height < cell.height)\r\n                    height = cell.height;\r\n            }\r\n        }\r\n        return height;\r\n    }\r\n    get selfy() {\r\n        for (let i = 0; i < this.table.rowCount; i++) {\r\n            if (this.table.rows[i] == this) {\r\n                return i;\r\n            }\r\n        }\r\n        throw new Error(\"error\");\r\n    }\r\n    _dispose() {\r\n        while (this.length > 0) {\r\n            const x = this.length - 1;\r\n            this._removeCell(x);\r\n        }\r\n        this.svgGroup.remove();\r\n    }\r\n    _removeCell(i) {\r\n        this.cells[i].removeFromTable(false);\r\n        this.cells.splice(i, 1);\r\n    }\r\n    get groupRowRange() {\r\n        let range = this.cells[0].groupRowRange;\r\n        this.cells.forEach((v) => {\r\n            if (range != null) {\r\n                range = cell_1.Cell.computeDisjunction(range, v.groupRowRange);\r\n            }\r\n        });\r\n        if (range == null) {\r\n            throw Error(\"error\");\r\n        }\r\n        else {\r\n            return range;\r\n        }\r\n    }\r\n}\r\nexports.CellRow = CellRow;\r\nCellRow.columnHeightName = \"data-height\";\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/table/row.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/object/virtual_tree.ts":
/*!***************************************************!*\
  !*** ../GraphTableSVG/src/object/virtual_tree.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vline_1 = __webpack_require__(/*! ../basic/common/vline */ \"../GraphTableSVG/src/basic/common/vline.ts\");\r\nclass VirtualTree {\r\n    constructor(_root, _externalEdgeDic) {\r\n        this.subTreeRoot = _root;\r\n        if (_externalEdgeDic !== undefined) {\r\n            this.externalEdges = _externalEdgeDic;\r\n        }\r\n        else {\r\n            this.externalEdges = new Set();\r\n        }\r\n    }\r\n    get root() {\r\n        return this.subTreeRoot;\r\n    }\r\n    get children() {\r\n        return this.subTreeRoot.outcomingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).map((v) => v.endVertex);\r\n    }\r\n    get virtualTreeChildren() {\r\n        return this.children.map((v) => v.createVirtualTree(this.externalEdges));\r\n    }\r\n    get parentEdge() {\r\n        const p = this.subTreeRoot.incomingEdges.filter((v) => !this.externalEdges.has(v) && v.beginVertex != null);\r\n        if (p.length != 0) {\r\n            return p[0];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    getSubtree(result = []) {\r\n        result.push(this.subTreeRoot);\r\n        const children = this.virtualTreeChildren;\r\n        if (children.length == 0) {\r\n            return result;\r\n        }\r\n        else {\r\n            children.forEach(function (x, i, arr) {\r\n                x.getSubtree(result);\r\n            });\r\n            return result;\r\n        }\r\n    }\r\n    getHeight() {\r\n        const children = this.virtualTreeChildren;\r\n        if (children.length == 0) {\r\n            return 1;\r\n        }\r\n        else {\r\n            let max = 0;\r\n            children.forEach(function (x, i, arr) {\r\n                if (max < x.getHeight())\r\n                    max = x.getHeight();\r\n            });\r\n            return max + 1;\r\n        }\r\n    }\r\n    region() {\r\n        const p = this.getSubtree();\r\n        let minX = this.subTreeRoot.x;\r\n        let maxX = this.subTreeRoot.x;\r\n        let minY = this.subTreeRoot.y;\r\n        let maxY = this.subTreeRoot.y;\r\n        p.forEach(function (x, i, arr) {\r\n            const rect = x.region;\r\n            if (minX > rect.x)\r\n                minX = rect.x;\r\n            if (maxX < rect.right)\r\n                maxX = rect.right;\r\n            if (minY > rect.y)\r\n                minY = rect.y;\r\n            if (maxY < rect.bottom)\r\n                maxY = rect.bottom;\r\n        });\r\n        const result = new vline_1.Rectangle();\r\n        result.x = minX;\r\n        result.y = minY;\r\n        result.width = maxX - minX;\r\n        result.height = maxY - minY;\r\n        return result;\r\n    }\r\n    get mostLeftLeave() {\r\n        return this.leaves[0];\r\n    }\r\n    addOffset(_x, _y) {\r\n        this.getSubtree().forEach(function (x, i, arr) {\r\n            x.cx += _x;\r\n            x.cy += _y;\r\n        });\r\n    }\r\n    setRectangleLocation(_x, _y) {\r\n        const x = this.mostLeftLeave.region.x;\r\n        const y = this.subTreeRoot.region.y;\r\n        const diffX = _x - x;\r\n        const diffY = _y - y;\r\n        this.addOffset(diffX, diffY);\r\n    }\r\n    setRootLocation(_x, _y) {\r\n        const x = this.subTreeRoot.cx;\r\n        const y = this.subTreeRoot.cy;\r\n        const diffX = _x - x;\r\n        const diffY = _y - y;\r\n        this.addOffset(diffX, diffY);\r\n    }\r\n    setRegionXYLocation(_x, _y) {\r\n        const region = this.region();\r\n        const newX = _x - region.x;\r\n        const newY = _y - region.y;\r\n        this.addOffset(newX, newY);\r\n    }\r\n    get leaves() {\r\n        return this.getSubtree().filter((x) => {\r\n            const r = x.outcomingEdges.filter((v) => !this.externalEdges.has(v) && v.endVertex != null).length;\r\n            return r == 0;\r\n        });\r\n    }\r\n}\r\nexports.VirtualTree = VirtualTree;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/object/virtual_tree.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/console.ts":
/*!***********************************************!*\
  !*** ../GraphTableSVG/src/options/console.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst table_dictionary_1 = __webpack_require__(/*! ./table_dictionary */ \"../GraphTableSVG/src/options/table_dictionary.ts\");\r\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"../GraphTableSVG/src/options/logic_tree.ts\");\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"../GraphTableSVG/src/options/logic_table.ts\");\r\nconst common_functions_1 = __webpack_require__(/*! ../basic/common/common_functions */ \"../GraphTableSVG/src/basic/common/common_functions.ts\");\r\nconst open_svg_1 = __webpack_require__(/*! ./open_svg */ \"../GraphTableSVG/src/options/open_svg.ts\");\r\nvar Console;\r\n(function (Console) {\r\n    function getCodeTag() {\r\n        const collection = document.getElementsByTagName(\"code\");\r\n        for (let i = 0; i < collection.length; i++) {\r\n            const item = collection.item(i);\r\n            if (item != null) {\r\n                const name = item.getAttribute(\"name\");\r\n                if (name == \"GraphTableSVG\") {\r\n                    return item;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function createCodeTag() {\r\n        const element = document.createElement(\"code\");\r\n        document.body.appendChild(element);\r\n        element.setAttribute(\"name\", \"GraphTableSVG\");\r\n        return element;\r\n    }\r\n    function getOrCreateCodeElement() {\r\n        const code = getCodeTag();\r\n        if (code != null) {\r\n            return code;\r\n        }\r\n        else {\r\n            return createCodeTag();\r\n        }\r\n    }\r\n    function addSVGSVGElement(code) {\r\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n        const p = document.createElement(\"p\");\r\n        code.appendChild(p);\r\n        p.appendChild(svg);\r\n        svg.setAttribute(\"style\", \"background:#e9e9e9;border:solid 1pt;padding:10px\");\r\n        svg.setAttribute(\"g-shrink\", \"true\");\r\n        if (svg instanceof SVGSVGElement) {\r\n            return svg;\r\n        }\r\n        else {\r\n            throw \"error\";\r\n        }\r\n    }\r\n    function initialize() {\r\n        const code = getCodeTag();\r\n        if (code == null) {\r\n            createCodeTag();\r\n        }\r\n    }\r\n    function table(item) {\r\n        if (item instanceof logic_table_1.LogicTable) {\r\n            common_functions_1.CommonFunctions.setGraphTableCSS();\r\n            const code = getOrCreateCodeElement();\r\n            const svg = addSVGSVGElement(code);\r\n            const gtable = open_svg_1.createShape(svg, \"g-table\");\r\n            gtable.constructFromLogicTable(item);\r\n            gtable.x = 0;\r\n            gtable.y = 0;\r\n        }\r\n        else {\r\n            const tableDic = new table_dictionary_1.TableDictionary();\r\n            tableDic.construct(item);\r\n            const logicTable = tableDic.toLogicTable();\r\n            table(logicTable);\r\n        }\r\n    }\r\n    Console.table = table;\r\n    function clear() {\r\n        const code = getOrCreateCodeElement();\r\n        code.innerHTML = \"\";\r\n    }\r\n    Console.clear = clear;\r\n    function graph(item) {\r\n        if (item instanceof logic_tree_1.LogicTree || item instanceof logic_tree_1.LogicGraph) {\r\n            common_functions_1.CommonFunctions.setGraphTableCSS();\r\n            const code = getOrCreateCodeElement();\r\n            const svg = addSVGSVGElement(code);\r\n            const ggraph = open_svg_1.createShape(svg, \"g-graph\");\r\n            ggraph.build(item);\r\n        }\r\n        else {\r\n            const tableDic = new table_dictionary_1.TableDictionary();\r\n            tableDic.construct(item);\r\n            const logicGraph = tableDic.toLogicGraph();\r\n            graph(logicGraph);\r\n        }\r\n    }\r\n    Console.graph = graph;\r\n})(Console = exports.Console || (exports.Console = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/console.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/html_table.ts":
/*!**************************************************!*\
  !*** ../GraphTableSVG/src/options/html_table.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"../GraphTableSVG/src/options/logic_table.ts\");\r\nvar HTMLFunctions;\r\n(function (HTMLFunctions) {\r\n    function createHTMLTable(e) {\r\n        const table = logic_table_1.LogicTable.constructHTMLLogicTable(e);\r\n        const tableTag = document.createElement(\"table\");\r\n        tableTag.setAttribute(\"border\", \"1\");\r\n        tableTag.setAttribute(\"cellspacing\", \"0\");\r\n        tableTag.setAttribute(\"bordercolor\", \"black\");\r\n        if (table != null) {\r\n            const cellConnectChecker = new Array();\r\n            for (let y = 0; y < table.rowCount; y++) {\r\n                cellConnectChecker.push(new Array(table.columnCount));\r\n                for (let x = 0; x < table.columnCount; x++) {\r\n                    cellConnectChecker[y][x] = true;\r\n                }\r\n            }\r\n            for (let y = 0; y < table.rowCount; y++) {\r\n                const tr = document.createElement(\"tr\");\r\n                tableTag.appendChild(tr);\r\n                for (let x = 0; x < table.columnCount; x++) {\r\n                    if (cellConnectChecker[y][x]) {\r\n                        const td = document.createElement(\"td\");\r\n                        const cell = table.cells[y][x];\r\n                        if (cell.connectedRowCount > 1) {\r\n                            td.setAttribute(\"rowspan\", cell.connectedRowCount.toString());\r\n                        }\r\n                        if (cell.connectedColumnCount > 1) {\r\n                            td.setAttribute(\"columnspan\", cell.connectedColumnCount.toString());\r\n                        }\r\n                        for (let ty = 0; ty < cell.connectedRowCount; ty++) {\r\n                            for (let tx = 0; tx < cell.connectedColumnCount; tx++) {\r\n                                if (tx != 0 || ty != 0) {\r\n                                    cellConnectChecker[ty + y][tx + x] = false;\r\n                                }\r\n                            }\r\n                        }\r\n                        const tTexts = cell.tTexts;\r\n                        if (tTexts != null) {\r\n                            tTexts.forEach((v) => {\r\n                                td.appendChild(v);\r\n                            });\r\n                        }\r\n                        else {\r\n                            const text = cell.text;\r\n                            if (text != null)\r\n                                td.innerHTML = text;\r\n                        }\r\n                        tr.appendChild(td);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return tableTag;\r\n    }\r\n    HTMLFunctions.createHTMLTable = createHTMLTable;\r\n})(HTMLFunctions = exports.HTMLFunctions || (exports.HTMLFunctions = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/html_table.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/logic_table.ts":
/*!***************************************************!*\
  !*** ../GraphTableSVG/src/options/logic_table.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst svg_textbox_1 = __webpack_require__(/*! ../basic/svghtml/svg_textbox */ \"../GraphTableSVG/src/basic/svghtml/svg_textbox.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst console_1 = __webpack_require__(/*! ./console */ \"../GraphTableSVG/src/options/console.ts\");\r\nconst cell_1 = __webpack_require__(/*! ../object/table/cell */ \"../GraphTableSVG/src/object/table/cell.ts\");\r\nclass LogicCell {\r\n    constructor() {\r\n        this.text = null;\r\n        this.cellClass = cell_1.Cell.defaultCellClass;\r\n        this.textClass = null;\r\n        this.backgroundClass = null;\r\n        this.topBorderClass = null;\r\n        this.leftBorderClass = null;\r\n        this.rightBorderClass = null;\r\n        this.bottomBorderClass = null;\r\n        this.svgText = null;\r\n        this.connectedColumnCount = 1;\r\n        this.connectedRowCount = 1;\r\n        this.tTexts = null;\r\n        this.isLatexMode = false;\r\n    }\r\n    set(text = undefined, isLatexMode = false, cellClass = undefined, backgroundClass = undefined, textClass = undefined, topBorderClass = undefined, leftBorderClass = undefined, rightBorderClass = undefined, bottomBorderClass = undefined) {\r\n        if (text !== undefined)\r\n            this.text = text;\r\n        if (cellClass !== undefined)\r\n            this.cellClass = cellClass;\r\n        if (textClass !== undefined)\r\n            this.textClass = textClass;\r\n        if (backgroundClass !== undefined)\r\n            this.backgroundClass = backgroundClass;\r\n        if (topBorderClass !== undefined)\r\n            this.topBorderClass = topBorderClass;\r\n        if (leftBorderClass !== undefined)\r\n            this.leftBorderClass = leftBorderClass;\r\n        if (rightBorderClass !== undefined)\r\n            this.rightBorderClass = rightBorderClass;\r\n        if (bottomBorderClass !== undefined)\r\n            this.bottomBorderClass = bottomBorderClass;\r\n        this.isLatexMode = isLatexMode;\r\n    }\r\n    createTextElement(svgText) {\r\n        if (this.tTexts != null) {\r\n            svg_textbox_1.SVGTextBox.constructSVGTextByHTMLElements(svgText, this.tTexts, this.isLatexMode);\r\n        }\r\n        else if (this.text != null) {\r\n            svgText.setTextContent(this.text, this.isLatexMode);\r\n        }\r\n    }\r\n}\r\nexports.LogicCell = LogicCell;\r\nclass LogicTable {\r\n    constructor(option = {}) {\r\n        this.tableClassName = null;\r\n        this.x = null;\r\n        this.y = null;\r\n        if (option.columnCount == undefined)\r\n            option.columnCount = 3;\r\n        if (option.rowCount == undefined)\r\n            option.rowCount = 3;\r\n        if (option.x == undefined)\r\n            option.x = 0;\r\n        if (option.y == undefined)\r\n            option.y = 0;\r\n        [this.x, this.y] = [option.x, option.y];\r\n        this.tableClassName = option.tableClassName == undefined ? null : option.tableClassName;\r\n        this.cells = new Array(option.rowCount);\r\n        for (let y = 0; y < option.rowCount; y++) {\r\n            this.cells[y] = new Array(option.columnCount);\r\n            for (let x = 0; x < option.columnCount; x++) {\r\n                this.cells[y][x] = new LogicCell();\r\n            }\r\n        }\r\n        this.rowHeights = new Array(option.rowCount);\r\n        for (let y = 0; y < option.rowCount; y++) {\r\n            this.rowHeights[y] = null;\r\n        }\r\n        this.columnWidths = new Array(option.columnCount);\r\n        for (let x = 0; x < option.columnCount; x++) {\r\n            this.columnWidths[x] = null;\r\n        }\r\n    }\r\n    get rowCount() {\r\n        return this.rowHeights.length;\r\n    }\r\n    get columnCount() {\r\n        return this.columnWidths.length;\r\n    }\r\n    get cellArray() {\r\n        const r = new Array();\r\n        for (let y = 0; y < this.rowHeights.length; y++) {\r\n            for (let x = 0; x < this.columnWidths.length; x++) {\r\n                r.push(this.cells[y][x]);\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    getColumn(i) {\r\n        const r = new Array();\r\n        for (let y = 0; y < this.rowHeights.length; y++) {\r\n            r.push(this.cells[y][i]);\r\n        }\r\n        return r;\r\n    }\r\n    getRow(i) {\r\n        const r = new Array();\r\n        for (let x = 0; x < this.columnWidths.length; x++) {\r\n            r.push(this.cells[i][x]);\r\n        }\r\n        return r;\r\n    }\r\n    static parse(str, delimiter) {\r\n        const lines = str.split(\"\\n\");\r\n        const r = new Array(lines.length);\r\n        for (let y = 0; y < lines.length; y++) {\r\n            const line = lines[y].split(delimiter);\r\n            r[y] = new Array(line.length);\r\n            for (let x = 0; x < line.length; x++) {\r\n                r[y][x] = line[x];\r\n            }\r\n            if (y > 0) {\r\n                if (r[y].length != r[y - 1].length) {\r\n                    alert(\"Parse Error\");\r\n                    throw Error(\"Parse Error\");\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    static create(str, tableClassName = null) {\r\n        const table = new LogicTable({ columnCount: str[0].length, rowCount: str.length, tableClassName: tableClassName == null ? undefined : tableClassName });\r\n        for (let y = 0; y < str.length; y++) {\r\n            for (let x = 0; x < str[y].length; x++) {\r\n                const p = str[y][x].split(\"%%%\");\r\n                table.cells[y][x].text = p[0];\r\n                if (p.length == 3) {\r\n                    table.cells[y][x].connectedColumnCount = Number(p[1]);\r\n                    table.cells[y][x].connectedRowCount = Number(p[2]);\r\n                }\r\n            }\r\n        }\r\n        return table;\r\n    }\r\n    static constructLogicTable(e) {\r\n        const rows = html_functions_1.HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement) == \"row\").map((v) => v);\r\n        const widthsStr = e.getPropertyStyleValue(\"--widths\");\r\n        if (rows.length == 0)\r\n            return null;\r\n        const cells = new Array(rows.length);\r\n        let columnSize = 0;\r\n        rows.forEach((v, i) => {\r\n            const cellArray = html_functions_1.HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement) == \"cell\");\r\n            cellArray.forEach((v) => v.removeAttribute(custtome_attributes_1.CustomAttributeNames.customElement));\r\n            cells[i] = cellArray;\r\n            if (columnSize < cellArray.length)\r\n                columnSize = cellArray.length;\r\n        });\r\n        const logicTable = new LogicTable({ rowCount: rows.length, columnCount: columnSize });\r\n        ;\r\n        if (widthsStr != null) {\r\n            const widths = JSON.parse(widthsStr);\r\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\r\n        }\r\n        for (let y = 0; y < cells.length; y++) {\r\n            const h = rows[y].getPropertyStyleNumberValue(\"--height\", null);\r\n            logicTable.rowHeights[y] = h;\r\n            for (let x = 0; x < cells[y].length; x++) {\r\n                logicTable.cells[y][x].text = cells[y][x].innerHTML;\r\n                if (cells[y][x].hasAttribute(\"w\")) {\r\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\r\n                    logicTable.cells[y][x].connectedColumnCount = w;\r\n                }\r\n                if (cells[y][x].hasAttribute(\"h\")) {\r\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\r\n                    logicTable.cells[y][x].connectedRowCount = h;\r\n                }\r\n                const tNodes = html_functions_1.HTMLFunctions.getTNodes(cells[y][x]);\r\n                if (tNodes != null)\r\n                    logicTable.cells[y][x].tTexts = tNodes;\r\n            }\r\n        }\r\n        return logicTable;\r\n    }\r\n    static constructHTMLLogicTable(e) {\r\n        const rows = html_functions_1.HTMLFunctions.getChildren(e).filter((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement) == \"row\").map((v) => v);\r\n        const widthsStr = e.getPropertyStyleValue(\"--widths\");\r\n        if (rows.length == 0)\r\n            return null;\r\n        const cells = new Array(rows.length);\r\n        let columnSize = 0;\r\n        rows.forEach((v, i) => {\r\n            const cellArray = html_functions_1.HTMLFunctions.getChildren(v).filter((v) => v.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement) == \"cell\");\r\n            cellArray.forEach((v) => v.removeAttribute(custtome_attributes_1.CustomAttributeNames.customElement));\r\n            cells[i] = cellArray;\r\n            if (columnSize < cellArray.length)\r\n                columnSize = cellArray.length;\r\n        });\r\n        const logicTable = new LogicTable({ rowCount: rows.length, columnCount: columnSize });\r\n        ;\r\n        if (widthsStr != null) {\r\n            const widths = JSON.parse(widthsStr);\r\n            widths.forEach((v, i) => logicTable.columnWidths[i] = v);\r\n        }\r\n        for (let y = 0; y < cells.length; y++) {\r\n            const h = rows[y].getPropertyStyleNumberValue(\"--height\", null);\r\n            logicTable.rowHeights[y] = h;\r\n            for (let x = 0; x < cells[y].length; x++) {\r\n                logicTable.cells[y][x].text = cells[y][x].innerHTML;\r\n                if (cells[y][x].hasAttribute(\"w\")) {\r\n                    const w = Number(cells[y][x].getAttribute(\"w\"));\r\n                    logicTable.cells[y][x].connectedColumnCount = w;\r\n                }\r\n                if (cells[y][x].hasAttribute(\"h\")) {\r\n                    const h = Number(cells[y][x].getAttribute(\"h\"));\r\n                    logicTable.cells[y][x].connectedRowCount = h;\r\n                }\r\n                logicTable.cells[y][x].text = cells[y][x].innerHTML;\r\n            }\r\n        }\r\n        return logicTable;\r\n    }\r\n    view() {\r\n        console_1.Console.table(this);\r\n    }\r\n}\r\nexports.LogicTable = LogicTable;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/logic_table.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/logic_tree.ts":
/*!**************************************************!*\
  !*** ../GraphTableSVG/src/options/logic_tree.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst console_1 = __webpack_require__(/*! ./console */ \"../GraphTableSVG/src/options/console.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nclass LogicGraphEdge {\r\n    constructor() {\r\n        this.text = null;\r\n        this.endNodeIndex = -1;\r\n    }\r\n}\r\nexports.LogicGraphEdge = LogicGraphEdge;\r\nclass LogicGraphNode {\r\n    constructor() {\r\n        this.text = null;\r\n        this.outputEdges = [];\r\n    }\r\n    addEdge(e) {\r\n        this.outputEdges.push(e);\r\n    }\r\n}\r\nexports.LogicGraphNode = LogicGraphNode;\r\nclass LogicGraph {\r\n    constructor() {\r\n        this.nodes = [];\r\n        this.edges = [];\r\n    }\r\n    construct(iten) {\r\n    }\r\n    addNode() {\r\n        const node = new LogicGraphNode();\r\n        this.nodes.push(node);\r\n        return node;\r\n    }\r\n    createEdge() {\r\n        const edge = new LogicGraphEdge();\r\n        this.edges.push(edge);\r\n        return edge;\r\n    }\r\n    getIndex(node) {\r\n        return this.nodes.indexOf(node);\r\n    }\r\n}\r\nexports.LogicGraph = LogicGraph;\r\nclass LogicTree {\r\n    constructor(option = {}) {\r\n        this.vertexText = null;\r\n        this.parentEdgeText = null;\r\n        this.vertexClass = null;\r\n        this.parentEdgeClass = null;\r\n        this.children = [];\r\n        this.item = null;\r\n        if (option.item != undefined)\r\n            this.item = option.item;\r\n        if (option.vertexText != undefined)\r\n            this.vertexText = option.vertexText;\r\n        if (option.parentEdgeText != undefined)\r\n            this.parentEdgeText = option.parentEdgeText;\r\n        if (option.children != undefined)\r\n            this.children = option.children;\r\n    }\r\n    getOrderedNodes(order) {\r\n        const r = [];\r\n        const edges = this.children;\r\n        if (order == enums_1.VertexOrder.Preorder) {\r\n            r.push(this);\r\n            edges.forEach((v) => {\r\n                if (v != null) {\r\n                    v.getOrderedNodes(order).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else if (order == enums_1.VertexOrder.Postorder) {\r\n            edges.forEach((v) => {\r\n                if (v != null) {\r\n                    v.getOrderedNodes(order).forEach((w) => {\r\n                        r.push(w);\r\n                    });\r\n                }\r\n            });\r\n            r.push(this);\r\n        }\r\n        return r;\r\n    }\r\n    view() {\r\n        console_1.Console.graph(this);\r\n    }\r\n}\r\nexports.LogicTree = LogicTree;\r\nclass BinaryLogicTree extends LogicTree {\r\n    constructor(item = null, left = null, right = null, nodeText = null, edgeLabel = null) {\r\n        super({ item: item == null ? undefined : item, children: [left, right], vertexText: nodeText == null ? undefined : nodeText, parentEdgeText: edgeLabel == null ? undefined : edgeLabel });\r\n        this.item = item;\r\n    }\r\n    get left() {\r\n        const left = this.children[0];\r\n        if (left == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return left;\r\n        }\r\n    }\r\n    set left(value) {\r\n        this.children[0] = value;\r\n    }\r\n    get right() {\r\n        const right = this.children[1];\r\n        if (right == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return right;\r\n        }\r\n    }\r\n    set right(value) {\r\n        this.children[1] = value;\r\n    }\r\n}\r\nexports.BinaryLogicTree = BinaryLogicTree;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/logic_tree.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/open_svg.ts":
/*!************************************************!*\
  !*** ../GraphTableSVG/src/options/open_svg.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nconst enums_1 = __webpack_require__(/*! ../basic/common/enums */ \"../GraphTableSVG/src/basic/common/enums.ts\");\r\nconst html_functions_1 = __webpack_require__(/*! ../basic/svghtml/html_functions */ \"../GraphTableSVG/src/basic/svghtml/html_functions.ts\");\r\nconst HTMLTable = __webpack_require__(/*! ./html_table */ \"../GraphTableSVG/src/options/html_table.ts\");\r\nconst gui_observer_1 = __webpack_require__(/*! ../basic/svghtml/gui_observer */ \"../GraphTableSVG/src/basic/svghtml/gui_observer.ts\");\r\nconst g_object_1 = __webpack_require__(/*! ../object/g_object */ \"../GraphTableSVG/src/object/g_object.ts\");\r\nconst g_callout_1 = __webpack_require__(/*! ../object/g_callout */ \"../GraphTableSVG/src/object/g_callout.ts\");\r\nconst g_arrow_callout_1 = __webpack_require__(/*! ../object/g_arrow_callout */ \"../GraphTableSVG/src/object/g_arrow_callout.ts\");\r\nconst g_ellipse_1 = __webpack_require__(/*! ../object/g_ellipse */ \"../GraphTableSVG/src/object/g_ellipse.ts\");\r\nconst g_rect_1 = __webpack_require__(/*! ../object/g_rect */ \"../GraphTableSVG/src/object/g_rect.ts\");\r\nconst g_textbox_1 = __webpack_require__(/*! ../object/g_textbox */ \"../GraphTableSVG/src/object/g_textbox.ts\");\r\nconst g_edge_1 = __webpack_require__(/*! ../object/g_edge */ \"../GraphTableSVG/src/object/g_edge.ts\");\r\nconst g_table_1 = __webpack_require__(/*! ../object/g_table */ \"../GraphTableSVG/src/object/g_table.ts\");\r\nconst g_graph_1 = __webpack_require__(/*! ../object/g_graph */ \"../GraphTableSVG/src/object/g_graph.ts\");\r\nconst g_rect_button_1 = __webpack_require__(/*! ../object/g_rect_button */ \"../GraphTableSVG/src/object/g_rect_button.ts\");\r\nfunction isGCustomElement(element) {\r\n    const gObjectTypeAttr = element.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement);\r\n    if (gObjectTypeAttr != null) {\r\n        const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\r\n        return gObjectType != null;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction openCustomElement(id) {\r\n    if (typeof id == \"string\") {\r\n        const item = document.getElementById(id);\r\n        if (item instanceof SVGElement) {\r\n            return openCustomElement(item);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        const element = id;\r\n        const gObjectTypeAttr = element.getAttribute(custtome_attributes_1.CustomAttributeNames.customElement);\r\n        if (gObjectTypeAttr != null) {\r\n            const gObjectType = enums_1.ShapeObjectType.toShapeObjectType(gObjectTypeAttr);\r\n            if (gObjectType != null) {\r\n                return createCustomElement(element, gObjectType);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            const type = enums_1.ShapeObjectType.toShapeObjectType(element.nodeName);\r\n            if (type != null) {\r\n                return createCustomElement(element, type);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.openCustomElement = openCustomElement;\r\nfunction createCustomElement(e, type) {\r\n    const parent = e.parentElement;\r\n    if (parent instanceof SVGElement) {\r\n        let r;\r\n        e.removeAttribute(custtome_attributes_1.CustomAttributeNames.customElement);\r\n        if (type == enums_1.ShapeObjectType.Callout) {\r\n            const option = g_callout_1.GCallout.constructAttributes(e, true);\r\n            r = new g_callout_1.GCallout(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.ArrowCallout) {\r\n            const option = g_arrow_callout_1.GArrowCallout.constructAttributes(e, true);\r\n            r = new g_arrow_callout_1.GArrowCallout(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Ellipse) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_ellipse_1.GEllipse(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Rect) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_rect_1.GRect(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Edge) {\r\n            const option = g_edge_1.GEdge.constructAttributes(e, true);\r\n            r = new g_edge_1.GEdge(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Graph) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_graph_1.GGraph(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.Table) {\r\n            const option = g_table_1.GTable.constructAttributes(e, true);\r\n            r = new g_table_1.GTable(parent, option);\r\n        }\r\n        else if (type == enums_1.ShapeObjectType.RectButton) {\r\n            const option = g_textbox_1.GTextBox.constructAttributes(e, true);\r\n            r = new g_rect_button_1.GRectButton(parent, option);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n        const attrs = e.gtGetAttributes();\r\n        html_functions_1.HTMLFunctions.getChildren(e).forEach((v) => r.svgGroup.appendChild(v));\r\n        e.remove();\r\n        attrs.forEach((v) => {\r\n            var items = v.name.split(\":\");\r\n            if (items.length == 2 && items[0] == \"surface\") {\r\n                if (r.svgSurface != null) {\r\n                    r.svgSurface.setAttribute(items[1], v.value);\r\n                }\r\n            }\r\n            else {\r\n                r.svgGroup.setAttribute(v.name, v.value);\r\n            }\r\n        });\r\n        if (r instanceof g_graph_1.GGraph) {\r\n            r.relocate();\r\n        }\r\n        return r;\r\n    }\r\n    else {\r\n        throw Error(\"error!\");\r\n    }\r\n}\r\nlet timerInterval = 100;\r\nfunction lazyOpenSVG() {\r\n    const p = document.getElementsByTagName(\"svg\");\r\n    const svgElements = [];\r\n    for (let i = 0; i < p.length; i++) {\r\n        const svgNode = p.item(i);\r\n        if (svgNode instanceof SVGSVGElement)\r\n            svgElements.push(svgNode);\r\n    }\r\n    svgElements.forEach((svgsvg) => lazyElementDic.push(svgsvg));\r\n    if (lazyElementDic.length > 0)\r\n        setTimeout(observelazyElementTimer, timerInterval);\r\n}\r\nexports.lazyOpenSVG = lazyOpenSVG;\r\nlet lazyElementDic = [];\r\nfunction observelazyElementTimer() {\r\n    for (let i = 0; i < lazyElementDic.length; i++) {\r\n        const element = lazyElementDic[i];\r\n        if (html_functions_1.HTMLFunctions.isInsideElement(element)) {\r\n            openSVG(element);\r\n            lazyElementDic.splice(i, 1);\r\n            i = -1;\r\n        }\r\n    }\r\n    if (lazyElementDic.length > 0)\r\n        setTimeout(observelazyElementTimer, timerInterval);\r\n}\r\nfunction openSVG(inputItem = null, output = []) {\r\n    if (typeof inputItem == \"string\") {\r\n        const item = document.getElementById(inputItem);\r\n        if (item != null && item instanceof SVGSVGElement) {\r\n            return openSVG(item, output);\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    else if (inputItem === null) {\r\n        const p = document.getElementsByTagName(\"svg\");\r\n        const svgElements = [];\r\n        for (let i = 0; i < p.length; i++) {\r\n            const svgNode = p.item(i);\r\n            if (svgNode instanceof SVGSVGElement)\r\n                svgElements.push(svgNode);\r\n        }\r\n        svgElements.forEach((svgsvg) => openSVG(svgsvg, output));\r\n        return output;\r\n    }\r\n    else if (inputItem instanceof SVGSVGElement) {\r\n        const svgsvg = inputItem;\r\n        html_functions_1.HTMLFunctions.getDescendants(svgsvg).forEach(v => {\r\n            const shapeType = enums_1.ShapeObjectType.toShapeObjectType(v.nodeName);\r\n            if (shapeType != null) {\r\n                toSVGUnknownElement(v);\r\n            }\r\n        });\r\n        const startTime = performance.now();\r\n        html_functions_1.HTMLFunctions.getDescendantsByPostorder(svgsvg).forEach((v) => {\r\n            if (v instanceof SVGElement) {\r\n                if (isGCustomElement(v)) {\r\n                    const p = openCustomElement(v);\r\n                    if (p != null) {\r\n                        output.push(p);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        const endTime = performance.now();\r\n        const time = endTime - startTime;\r\n        gui_observer_1.GUIObserver.observeSVGSVG(svgsvg);\r\n    }\r\n    else {\r\n        throw Error(\"errror\");\r\n    }\r\n    return output;\r\n}\r\nexports.openSVG = openSVG;\r\nfunction createShape(parent, type, option = {}) {\r\n    let _parent;\r\n    if (parent instanceof g_object_1.GObject) {\r\n        _parent = parent.svgGroup;\r\n    }\r\n    else if (parent instanceof SVGElement) {\r\n        _parent = parent;\r\n    }\r\n    else {\r\n        _parent = document.getElementById(parent);\r\n    }\r\n    switch (type) {\r\n        case enums_1.ShapeObjectType.Callout: return new g_callout_1.GCallout(_parent, option);\r\n        case enums_1.ShapeObjectType.ArrowCallout: return new g_arrow_callout_1.GArrowCallout(_parent, option);\r\n        case enums_1.ShapeObjectType.Ellipse: return new g_ellipse_1.GEllipse(_parent, option);\r\n        case enums_1.ShapeObjectType.Rect: return new g_rect_1.GRect(_parent, option);\r\n        case enums_1.ShapeObjectType.Edge: return new g_edge_1.GEdge(_parent, option);\r\n        case enums_1.ShapeObjectType.Graph: return new g_graph_1.GGraph(_parent, option);\r\n        case enums_1.ShapeObjectType.Table: return new g_table_1.GTable(_parent, option);\r\n        case enums_1.ShapeObjectType.RectButton: return new g_rect_button_1.GRectButton(_parent, option);\r\n    }\r\n    throw Error(\"error\");\r\n}\r\nexports.createShape = createShape;\r\nfunction createVertex(parent, option = {}) {\r\n    let _parent = parent.svgGroup;\r\n    if (option.class == undefined)\r\n        option.class = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultVertexClass;\r\n    const type = option.class == undefined ? null : parent.getStyleValue(option.class, custtome_attributes_1.CustomAttributeNames.Style.defaultSurfaceType);\r\n    if (type != null) {\r\n        switch (type) {\r\n            case enums_1.ShapeObjectType.Callout: return new g_callout_1.GCallout(_parent, option);\r\n            case enums_1.ShapeObjectType.ArrowCallout: return new g_arrow_callout_1.GArrowCallout(_parent, option);\r\n            case enums_1.ShapeObjectType.Ellipse: return new g_ellipse_1.GEllipse(_parent, option);\r\n            case enums_1.ShapeObjectType.Rect: return new g_rect_1.GRect(_parent, option);\r\n        }\r\n    }\r\n    return new g_ellipse_1.GEllipse(_parent, option);\r\n}\r\nexports.createVertex = createVertex;\r\nfunction toSVGUnknownElement(e) {\r\n    const type = enums_1.ShapeObjectType.toShapeObjectTypeOrCustomTag(e.nodeName);\r\n    if (type == null) {\r\n    }\r\n    else {\r\n        const ns = document.createElementNS('http://www.w3.org/2000/svg', \"g\");\r\n        ns.setAttribute(custtome_attributes_1.CustomAttributeNames.customElement, e.nodeName);\r\n        for (let i = 0; i < e.attributes.length; i++) {\r\n            const attr = e.attributes.item(i);\r\n            ns.setAttribute(attr.name, attr.value);\r\n        }\r\n        ns.innerHTML = e.innerHTML;\r\n        const p = e.parentElement;\r\n        if (p != null) {\r\n            p.insertBefore(ns, e);\r\n            e.remove();\r\n        }\r\n        const children = html_functions_1.HTMLFunctions.getChildren(ns);\r\n        children.forEach((v) => toSVGUnknownElement(v));\r\n    }\r\n}\r\nexports.toSVGUnknownElement = toSVGUnknownElement;\r\nfunction toDivElement(e) {\r\n    const type = e.nodeName == \"G-TABLE\" ? \"g-table\" : e.nodeName == \"ROW\" ? \"row\" : e.nodeName == \"CELL\" ? \"cell\" : null;\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        const ns = document.createElement(\"div\");\r\n        ns.setAttribute(custtome_attributes_1.CustomAttributeNames.customElement, type);\r\n        for (let i = 0; i < e.attributes.length; i++) {\r\n            const attr = e.attributes.item(i);\r\n            ns.setAttribute(attr.name, attr.value);\r\n        }\r\n        ns.innerHTML = e.innerHTML;\r\n        const p = e.parentElement;\r\n        if (p != null) {\r\n            p.insertBefore(ns, e);\r\n            e.remove();\r\n        }\r\n        const children = html_functions_1.HTMLFunctions.getChildren(ns);\r\n        children.forEach((v) => toDivElement(v));\r\n        return ns;\r\n    }\r\n}\r\nexports.toDivElement = toDivElement;\r\nfunction isSVGElement(e) {\r\n    if (e.parentElement == null) {\r\n        return false;\r\n    }\r\n    else {\r\n        if (e.parentElement instanceof SVGSVGElement) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isSVGElement(e.parentElement);\r\n        }\r\n    }\r\n}\r\nfunction openHTML(id = null) {\r\n    if (id == null) {\r\n        const p = document.getElementsByTagName(\"g-table\");\r\n        const svgElements = [];\r\n        for (let i = 0; i < p.length; i++) {\r\n            const svgNode = p.item(i);\r\n            if (svgNode != null) {\r\n                if (!isSVGElement(svgNode) && svgNode instanceof HTMLElement)\r\n                    svgElements.push(svgNode);\r\n            }\r\n        }\r\n        svgElements.forEach((e) => openHTML(e));\r\n    }\r\n    else if (typeof (id) == \"string\") {\r\n        const e = document.getElementById(id);\r\n        if (e instanceof HTMLElement) {\r\n            openHTML(e);\r\n        }\r\n    }\r\n    else {\r\n        const newE = toDivElement(id);\r\n        if (newE != null) {\r\n            const table = HTMLTable.HTMLFunctions.createHTMLTable(newE);\r\n            newE.insertAdjacentElement('beforebegin', table);\r\n            newE.remove();\r\n        }\r\n    }\r\n}\r\nexports.openHTML = openHTML;\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/open_svg.ts?");

/***/ }),

/***/ "../GraphTableSVG/src/options/table_dictionary.ts":
/*!********************************************************!*\
  !*** ../GraphTableSVG/src/options/table_dictionary.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_tree_1 = __webpack_require__(/*! ./logic_tree */ \"../GraphTableSVG/src/options/logic_tree.ts\");\r\nconst logic_table_1 = __webpack_require__(/*! ./logic_table */ \"../GraphTableSVG/src/options/logic_table.ts\");\r\nconst custtome_attributes_1 = __webpack_require__(/*! ../basic/common/custtome_attributes */ \"../GraphTableSVG/src/basic/common/custtome_attributes.ts\");\r\nclass TableDictionary {\r\n    constructor() {\r\n        this.columnMapper = new Map();\r\n        this.rows = new Array();\r\n        this.objects = new Array();\r\n        this.columnMapper.set(TableDictionary.IndexName, 0);\r\n    }\r\n    construct(item) {\r\n        if (item instanceof Array) {\r\n            item.forEach((v) => {\r\n                this.add(v);\r\n            });\r\n        }\r\n        else {\r\n            this.add(item);\r\n        }\r\n    }\r\n    addValue(i, key, value) {\r\n        const column = this.columnMapper.get(key);\r\n        if (column === undefined) {\r\n            this.columnMapper.set(key, this.columnMapper.size);\r\n        }\r\n        this.rows[i].set(key, value);\r\n    }\r\n    add(item) {\r\n        this.rows.push(new Map());\r\n        this.objects.push(item);\r\n        const x = this.rows.length - 1;\r\n        this.addValue(x, TableDictionary.IndexName, x.toString());\r\n        if (item instanceof Array) {\r\n            for (let i = 0; i < item.length; i++) {\r\n                const cell = item[i];\r\n                if (cell != undefined) {\r\n                    this.addValue(x, i.toString(), cell);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (typeof item === \"string\" || typeof item === \"number\" || typeof item === \"boolean\") {\r\n                this.addValue(x, TableDictionary.ValueName, item.toString());\r\n            }\r\n            else if (typeof item === \"object\") {\r\n                Object.keys(item).forEach((key) => {\r\n                    const value = item[key];\r\n                    this.addValue(x, key.toString(), value);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    toLogicTable() {\r\n        const table = new logic_table_1.LogicTable({ columnCount: this.columnMapper.size, rowCount: this.rows.length + 1 });\r\n        this.columnMapper.forEach((value, key) => {\r\n            table.cells[0][value].textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellTextClass;\r\n            table.cells[0][value].backgroundClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellBackgroundClass;\r\n            if (key == TableDictionary.IndexName) {\r\n                table.cells[0][value].text = \"(index)\";\r\n            }\r\n            else if (key == TableDictionary.ValueName) {\r\n                table.cells[0][value].text = \"(value)\";\r\n            }\r\n            else {\r\n                table.cells[0][value].text = key;\r\n            }\r\n        });\r\n        this.rows.forEach((map, index) => {\r\n            const tableIndex = index + 1;\r\n            for (let i = 0; i < this.columnMapper.size; i++) {\r\n                table.cells[tableIndex][i].text = \"undefined\";\r\n                table.cells[tableIndex][i].textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultConsoleColumnTitleCellUndefinedTextClass;\r\n            }\r\n            map.forEach((value, key) => {\r\n                const columnIndex = this.columnMapper.get(key);\r\n                if (columnIndex != undefined) {\r\n                    const cell = this.rows[index].get(key);\r\n                    if (cell == null) {\r\n                        table.cells[tableIndex][columnIndex].text = \"null\";\r\n                    }\r\n                    else if (cell != undefined) {\r\n                        table.cells[tableIndex][columnIndex].text = cell.toString();\r\n                        table.cells[tableIndex][columnIndex].textClass = custtome_attributes_1.CustomAttributeNames.StyleValue.defaultTextClass;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        return table;\r\n    }\r\n    createNode(item, graph, dic) {\r\n        if (typeof item === \"object\") {\r\n            let node = dic.get(item);\r\n            if (node !== undefined) {\r\n                return node;\r\n            }\r\n            else {\r\n                node = graph.addNode();\r\n                if (item !== undefined && item != null) {\r\n                    dic.set(item, node);\r\n                    Object.keys(item).forEach((key) => {\r\n                        const value = item[key];\r\n                        const child = this.createNode(value, graph, dic);\r\n                        const edge = graph.createEdge();\r\n                        edge.endNodeIndex = graph.getIndex(child);\r\n                        edge.text = key.toString();\r\n                        node.addEdge(edge);\r\n                    });\r\n                }\r\n                else {\r\n                    node.text = \"null\";\r\n                }\r\n                return node;\r\n            }\r\n        }\r\n        else {\r\n            const node = graph.addNode();\r\n            if (typeof item === \"undefined\") {\r\n                node.text = \"undefined\";\r\n            }\r\n            else {\r\n                node.text = item.toString();\r\n            }\r\n            return node;\r\n        }\r\n    }\r\n    toLogicGraph() {\r\n        const dic = new Map();\r\n        const graph = new logic_tree_1.LogicGraph();\r\n        this.rows.forEach((v, i) => {\r\n            const obj = this.objects[i];\r\n            this.createNode(obj, graph, dic);\r\n        });\r\n        return graph;\r\n    }\r\n}\r\nexports.TableDictionary = TableDictionary;\r\nTableDictionary.IndexName = \"___GraphTableSVG_Console_Index\";\r\nTableDictionary.ValueName = \"___GraphTableSVG_Console_Value\";\r\n\n\n//# sourceURL=webpack://Sutoring/../GraphTableSVG/src/options/table_dictionary.ts?");

/***/ }),

/***/ "./src/graph_table.ts":
/*!****************************!*\
  !*** ./src/graph_table.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst logic_table_1 = __webpack_require__(/*! logic_table */ \"../GraphTableSVG/src/options/logic_table.ts\");\r\nvar LogicGraphTable;\r\n(function (LogicGraphTable) {\r\n    function setRow(table, ithRow, name, values) {\r\n        table.cells[ithRow][0].text = name;\r\n        values.forEach((v, i) => { table.cells[ithRow][i + 1].text = v.toString(); });\r\n    }\r\n    LogicGraphTable.setRow = setRow;\r\n    function setColumn(table, ithColumn, name, values) {\r\n        table.cells[0][ithColumn].text = name;\r\n        values.forEach((v, i) => { table.cells[i + 1][ithColumn].text = v.toString(); });\r\n    }\r\n    LogicGraphTable.setColumn = setColumn;\r\n    function createLogicTable(lines, option) {\r\n        if (option == undefined)\r\n            option = {};\r\n        if (option.isRowLines == undefined)\r\n            option.isRowLines = true;\r\n        if (option.withIndex == undefined)\r\n            option.withIndex = false;\r\n        if (lines instanceof Array) {\r\n            let maximalLineLength = 0;\r\n            lines.forEach((v) => {\r\n                if (maximalLineLength < v.values.length) {\r\n                    maximalLineLength = v.values.length;\r\n                }\r\n            });\r\n            if (option.withIndex) {\r\n                const newLines = new Array();\r\n                newLines.push({ name: \"Index\", values: Array.from(Array(maximalLineLength).keys()).map((i) => option.zeroBased ? i : (i + 1)) });\r\n                lines.forEach((v) => newLines.push(v));\r\n                option.withIndex = false;\r\n                return createLogicTable(newLines, option);\r\n            }\r\n            const rowCount = option.isRowLines ? lines.length : maximalLineLength + 1;\r\n            const columnCount = option.isRowLines ? maximalLineLength + 1 : lines.length;\r\n            const table = new logic_table_1.LogicTable({ rowCount: rowCount, columnCount: columnCount });\r\n            if (option.isRowLines) {\r\n                lines.forEach((v, i) => {\r\n                    LogicGraphTable.setRow(table, i, v.name, v.values);\r\n                });\r\n            }\r\n            else {\r\n                lines.forEach((v, i) => {\r\n                    LogicGraphTable.setColumn(table, i, v.name, v.values);\r\n                });\r\n            }\r\n            return table;\r\n        }\r\n        else {\r\n            return createLogicTable([lines], option);\r\n        }\r\n    }\r\n    LogicGraphTable.createLogicTable = createLogicTable;\r\n})(LogicGraphTable = exports.LogicGraphTable || (exports.LogicGraphTable = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/./src/graph_table.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_1 = __webpack_require__(/*! ./graph_table */ \"./src/graph_table.ts\");\r\nexports.LogicGraphTable = graph_table_1.LogicGraphTable;\r\nconst lz78_1 = __webpack_require__(/*! ./lz78 */ \"./src/lz78.ts\");\r\nexports.LZ78 = lz78_1.LZ78;\r\nconst suffix_array_1 = __webpack_require__(/*! ./suffix_array */ \"./src/suffix_array.ts\");\r\nexports.SuffixArray = suffix_array_1.SuffixArray;\r\nconst minimal_unique_substrings_1 = __webpack_require__(/*! ./minimal_unique_substrings */ \"./src/minimal_unique_substrings.ts\");\r\nexports.MinimalUniqueSubstrings = minimal_unique_substrings_1.MinimalUniqueSubstrings;\r\nconsole.log(\"Loaded Index.ts\");\r\n\n\n//# sourceURL=webpack://Sutoring/./src/index.ts?");

/***/ }),

/***/ "./src/lz78.ts":
/*!*********************!*\
  !*** ./src/lz78.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_1 = __webpack_require__(/*! ./graph_table */ \"./src/graph_table.ts\");\r\nconst logic_tree_1 = __webpack_require__(/*! logic_tree */ \"../GraphTableSVG/src/options/logic_tree.ts\");\r\nvar LZ78;\r\n(function (LZ78) {\r\n    function preprocess(text) {\r\n        let nodeCount = 0;\r\n        const root = { id: nodeCount++, children: new Map() };\r\n        let currentNode = root;\r\n        let factors = new Array();\r\n        const nodes = [root];\r\n        for (let i = 0; i < text.length; i++) {\r\n            const char = text[i];\r\n            if (currentNode.children.has(char)) {\r\n                currentNode = currentNode.children.get(char);\r\n            }\r\n            else {\r\n                factors.push({ id: currentNode.id, nextChar: char });\r\n                const newNode = { id: nodeCount++, children: new Map() };\r\n                currentNode.children.set(char, newNode);\r\n                currentNode = root;\r\n                nodes.push(newNode);\r\n            }\r\n        }\r\n        if (currentNode != root) {\r\n            factors.push({ id: currentNode.id, nextChar: \"\" });\r\n            const newNode = { id: nodeCount++, children: new Map() };\r\n            currentNode.children.set(\"\", newNode);\r\n            currentNode = root;\r\n            nodes.push(newNode);\r\n        }\r\n        return [factors, nodes];\r\n    }\r\n    function extract(factors) {\r\n        const r = new Array();\r\n        factors.forEach((f, i) => {\r\n            if (f.id == 0) {\r\n                r.push(f.nextChar);\r\n            }\r\n            else {\r\n                const str = r[f.id - 1] + f.nextChar;\r\n                r.push(str);\r\n            }\r\n        });\r\n        return r;\r\n    }\r\n    function factorize(text) {\r\n        const p = preprocess(text);\r\n        const parsedStrings = extract(p[0]);\r\n        return parsedStrings;\r\n    }\r\n    LZ78.factorize = factorize;\r\n    function compress(text) {\r\n        const p = preprocess(text);\r\n        return p[0];\r\n    }\r\n    LZ78.compress = compress;\r\n    function constructLZ78Table(text) {\r\n        const comp = compress(text);\r\n        return graph_table_1.LogicGraphTable.createLogicTable([\r\n            { name: \"id\", values: comp.map((v, i) => v.id) },\r\n            { name: \"character\", values: comp.map((v, i) => v.nextChar) }\r\n        ], { isRowLines: true, withIndex: true });\r\n    }\r\n    LZ78.constructLZ78Table = constructLZ78Table;\r\n    function constructLZ78Trie(text) {\r\n        const nodes = preprocess(text)[1];\r\n        const graphNodes = nodes.map((v) => new logic_tree_1.LogicTree());\r\n        nodes.forEach((v, i) => {\r\n            graphNodes[v.id].vertexText = (v.id).toString();\r\n            v.children.forEach((value, key) => {\r\n                const child = graphNodes[value.id];\r\n                child.parentEdgeText = key;\r\n                graphNodes[v.id].children.push(child);\r\n            });\r\n        });\r\n        return graphNodes[0];\r\n    }\r\n    LZ78.constructLZ78Trie = constructLZ78Trie;\r\n})(LZ78 = exports.LZ78 || (exports.LZ78 = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/./src/lz78.ts?");

/***/ }),

/***/ "./src/minimal_unique_substrings.ts":
/*!******************************************!*\
  !*** ./src/minimal_unique_substrings.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DistinctSubstrings;\r\n(function (DistinctSubstrings) {\r\n    function sort(strings) {\r\n        strings.sort((a, b) => {\r\n            if (a < b)\r\n                return -1;\r\n            if (a > b)\r\n                return 1;\r\n            return 0;\r\n        });\r\n    }\r\n    DistinctSubstrings.sort = sort;\r\n    function enumerate(text) {\r\n        const map = enumerateWithOccurrences(text);\r\n        const r = new Array(0);\r\n        map.forEach((value, key) => {\r\n            r.push(key);\r\n        });\r\n        DistinctSubstrings.sort(r);\r\n        return r;\r\n    }\r\n    DistinctSubstrings.enumerate = enumerate;\r\n    function enumerateWithOccurrences(text) {\r\n        let map = new Map();\r\n        for (let i = 0; i < text.length; i++) {\r\n            for (let len = 1; len <= text.length - i; len++) {\r\n                const substr = text.substr(i, len);\r\n                if (map.has(substr)) {\r\n                    const occs = map.get(substr);\r\n                    occs.push(i);\r\n                    map.set(substr, occs);\r\n                }\r\n                else {\r\n                    map.set(substr, [i]);\r\n                }\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n    DistinctSubstrings.enumerateWithOccurrences = enumerateWithOccurrences;\r\n})(DistinctSubstrings = exports.DistinctSubstrings || (exports.DistinctSubstrings = {}));\r\nvar MinimalUniqueSubstrings;\r\n(function (MinimalUniqueSubstrings) {\r\n    function enumerate(text) {\r\n        const map = DistinctSubstrings.enumerateWithOccurrences(text);\r\n        const r = new Array(0);\r\n        map.forEach((occs, substr) => {\r\n            if (occs.length == 1) {\r\n                if (substr.length == 1) {\r\n                    r.push(substr);\r\n                }\r\n                else {\r\n                    const left = substr.substr(1);\r\n                    const right = substr.substr(0, substr.length - 1);\r\n                    if (map.get(left).length > 1 && map.get(right).length > 1) {\r\n                        r.push(substr);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        DistinctSubstrings.sort(r);\r\n        return r;\r\n    }\r\n    MinimalUniqueSubstrings.enumerate = enumerate;\r\n})(MinimalUniqueSubstrings = exports.MinimalUniqueSubstrings || (exports.MinimalUniqueSubstrings = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/./src/minimal_unique_substrings.ts?");

/***/ }),

/***/ "./src/suffix_array.ts":
/*!*****************************!*\
  !*** ./src/suffix_array.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst graph_table_1 = __webpack_require__(/*! ./graph_table */ \"./src/graph_table.ts\");\r\nvar SuffixArray;\r\n(function (SuffixArray) {\r\n    function construct(str, zero_based = true) {\r\n        const arr = new Array(str.length);\r\n        for (let i = 0; i < str.length; i++) {\r\n            arr[i] = i;\r\n        }\r\n        const func = function (item1, item2) {\r\n            for (let i = 0; i <= str.length; i++) {\r\n                if (item1 + i >= str.length || item2 + i >= str.length)\r\n                    break;\r\n                if (str.charAt(item1 + i) < str.charAt(item2 + i)) {\r\n                    return -1;\r\n                }\r\n                else if (str.charAt(item1 + i) > str.charAt(item2 + i)) {\r\n                    return 1;\r\n                }\r\n            }\r\n            if (item1 == item2) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return item1 < item2 ? 1 : -1;\r\n            }\r\n        };\r\n        arr.sort(func);\r\n        if (zero_based) {\r\n            return arr;\r\n        }\r\n        else {\r\n            return arr.map((v) => v + 1);\r\n        }\r\n    }\r\n    SuffixArray.construct = construct;\r\n    function constructSATable(text, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: false, withIndex: true }) {\r\n        if (option.zeroBased == undefined)\r\n            option.zeroBased = true;\r\n        if (option.withSA == undefined)\r\n            option.withSA = true;\r\n        if (option.withLCP == undefined)\r\n            option.withLCP = false;\r\n        if (option.withBWT == undefined)\r\n            option.withBWT = false;\r\n        if (option.withIndex == undefined)\r\n            option.withIndex = true;\r\n        const sa = construct(text);\r\n        const view_sa = option.zeroBased ? sa : sa.map((v) => v + 1);\r\n        const indexes = option.zeroBased ? sa.map((v, i) => i) : sa.map((v, i) => i + 1);\r\n        const lcpArray = LCPArray.construct(text);\r\n        const bwt = BWT.construct(text).map((v) => v);\r\n        const arrays = new Array(0);\r\n        if (option.withSA) {\r\n            arrays.push({ name: \"SA\", values: view_sa });\r\n        }\r\n        if (option.withLCP) {\r\n            arrays.push({ name: \"LCP\", values: lcpArray });\r\n        }\r\n        if (option.withBWT) {\r\n            arrays.push({ name: \"BWT\", values: bwt });\r\n        }\r\n        arrays.push({ name: \"Suffix\", values: sa.map((v) => text.substr(v)) });\r\n        return graph_table_1.LogicGraphTable.createLogicTable(arrays, { isRowLines: false, withIndex: option.withIndex, zeroBased: option.zeroBased });\r\n    }\r\n    SuffixArray.constructSATable = constructSATable;\r\n})(SuffixArray = exports.SuffixArray || (exports.SuffixArray = {}));\r\nvar LCPArray;\r\n(function (LCPArray) {\r\n    function lcp(text1, text2) {\r\n        const max = text1.length < text2.length ? text2.length : text1.length;\r\n        for (let i = 0; i < max; i++) {\r\n            if (text1[i] != text2[i])\r\n                return i;\r\n        }\r\n        return max;\r\n    }\r\n    function construct(text) {\r\n        const sa = SuffixArray.construct(text);\r\n        const lcpArray = sa.map((_, i) => {\r\n            if (i == 0) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return lcp(text.substr(sa[i]), text.substr(sa[i - 1]));\r\n            }\r\n        });\r\n        return lcpArray;\r\n    }\r\n    LCPArray.construct = construct;\r\n    function constructLCPTable(text, option = { zeroBased: true, withSA: true, withLCP: true, withBWT: false }) {\r\n        return SuffixArray.constructSATable(text, option);\r\n    }\r\n    LCPArray.constructLCPTable = constructLCPTable;\r\n})(LCPArray = exports.LCPArray || (exports.LCPArray = {}));\r\nvar BWT;\r\n(function (BWT) {\r\n    function getCircularString(text, nth) {\r\n        return text.substr(nth) + text.substr(0, nth);\r\n    }\r\n    function compare(text, ith, jth) {\r\n        const ithStr = getCircularString(text, ith);\r\n        const jthStr = getCircularString(text, jth);\r\n        if (ithStr == jthStr) {\r\n            return ith - jth;\r\n        }\r\n        else {\r\n            if (ithStr < jthStr) {\r\n                return -1;\r\n            }\r\n            else {\r\n                return 1;\r\n            }\r\n        }\r\n    }\r\n    function construct(text) {\r\n        const r = Array.from(Array(text.length).keys());\r\n        r.sort((a, b) => {\r\n            return compare(text, a, b);\r\n        });\r\n        return r.map((v) => {\r\n            if (v == 0) {\r\n                return text[text.length - 1];\r\n            }\r\n            else {\r\n                return text[v - 1];\r\n            }\r\n        });\r\n    }\r\n    BWT.construct = construct;\r\n    function constructBWTTable(text, option = { zeroBased: true, withSA: true, withLCP: false, withBWT: true }) {\r\n        return SuffixArray.constructSATable(text, option);\r\n    }\r\n    BWT.constructBWTTable = constructBWTTable;\r\n})(BWT = exports.BWT || (exports.BWT = {}));\r\n\n\n//# sourceURL=webpack://Sutoring/./src/suffix_array.ts?");

/***/ })

/******/ });